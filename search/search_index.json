{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Hyperon experimental documentation","text":""},{"location":"CONTRIBUTING/","title":"How to contribute","text":""},{"location":"CONTRIBUTING/#making-changes","title":"Making changes","text":"<p>Before making changes create a personal fork of the repository. Sync fork and create new branch from the latest version of the <code>main</code> branch. Create separate branch for each change. Thus it is simpler to support consistent state of the <code>main</code> in your fork.</p> <p>Prefer incremental commits to one big commit which contains the whole change. Prefer commits which passes all of the tests. If it is not possible to satisfy both requirements at once you can make single commit which passes tests or mark tests as ignored until change is done.</p> <p>Each commit should have a message in the following format: <pre><code>Change summary in 50 characters (less than 73 characters)\n\nOptional detailed description of the change when required. Each line\nis less than 73 character long.\n</code></pre> Such commits looks better in GitHub history.</p> <p>Please avoid generic commit messages like <code>Update README.md</code>. Good commit message should describe the change, not a fact of the change. For example <code>Add troubleshooting section about No module named 'hyperonpy'</code>. By looking to the commit message history the reviewer should understand the order and brief description of changes.</p> <p>Please don't include number and description of the issue into a commit summary line. Use <code>Fixes #&lt;issue-number&gt;</code> in the pull request description instead to link the PR and the issue.</p> <p>PR should satisfy the following requirement before being merged: - contain latest changes from the repo; - pass tests; - be reviewed.</p> <p>Feel free to raise draft PR if you need an advice or help with your changes.</p>"},{"location":"CONTRIBUTING/#code-style","title":"Code style","text":"<p>We have small set of code style rules for now. The rule of thumb is to take a look at the existing code and stick to its style.</p>"},{"location":"CONTRIBUTING/#general","title":"General","text":"<p>If you want to leave some reminder in code, for example to fix something later, you can do it by two ways. Add a comment starting with <code>FIXME</code> to mark something which should be done before the PR is merged. Add a comment starting with <code>TODO</code> to mark the improvement which can be postponed and done later by a separate PR. The main purpose of a <code>TODO</code> comment is to trigger a developer who looks at the code after you and make him fix the issue if it is appropriate. If the change or question is big enough or it affects the API of the module it is better to raise an issue instead.</p>"},{"location":"CONTRIBUTING/#libraries","title":"Libraries","text":"<p>When adding new library into the project please ensure you specify the exact version instead of using ranges. The minor update of the library can break the build unexpectedly. The broken build is a real burden because most of the users build the project from the source.</p>"},{"location":"CONTRIBUTING/#rust","title":"Rust","text":"<p>When working on Rust C API prefer making <code>unsafe</code> blocks as small as possible. This makes it easier to find blocks that might be source of issues. Usually it is not required to mark C API functions <code>unsafe</code> because they are not intended to be used from the Rust safe code.</p>"},{"location":"CONTRIBUTING/#git","title":"Git","text":"<p><code>.gitignore</code> file is also used to exclued files going into Docker image building context. All ignored files should be put into the same <code>.gitignore</code> at the root of the repository by this reason.</p>"},{"location":"DEVELOPMENT/","title":"Instructions for developers","text":""},{"location":"DEVELOPMENT/#how-to-release-python-distribution-packages-locally","title":"How to release Python distribution packages locally","text":"<p>Python packages are released using cibuildwheel. First step is to setup it. Usually it means setup docker and install the package from PyPi (see setup instructions).</p> <p>There are additional preparations to be made. First it is needed to allow building and installing <code>libhyperonc</code> library on a build environment. <code>cibuildwheel</code> uses isolated docker container for each kind of platform it supports. Only code of the Python package is copied into container automatically. Code of the <code>libhyperonc</code> library should be downloaded from outside. It means one need to have the code in some repo accessible from the container before starting release. The simplest way is to push the changes in your GitHub repo fork.</p> <p>By default library downloads and installs version from the <code>main</code> branch of the <code>trueagi-io/hyperon-experimental</code> repository. Using a custom branch is done by passing custom parameters to the <code>install-hyperonc.sh</code> script through CIBW_BEFORE_ALL environment variable: <pre><code>export CIBW_BEFORE_ALL='sh -c \"./python/install-hyperonc.sh -u &lt;git-repo-url&gt; -r &lt;git-branch&gt;\"'\n</code></pre> One should replace <code>&lt;git-repo-url&gt;</code> and <code>&lt;git-branch&gt;</code> by the repo URL and branch which are used in release.</p> <p>Also it is possible to start from building the only platform to quickly check whether release works. This can be done using CIBW_BUILD variable: <pre><code>export CIBW_BUILD=cp310-manylinux_x86_64\n</code></pre></p> <p>After exporting the variables above one can start release by executing <code>cibuildwheel ./python</code> from the root directory of the repo. See cibuildwheel documentation for details.</p>"},{"location":"DEVELOPMENT/#how-to-update-the-version","title":"How to update the version","text":"<p>Usually it is needed before releasing the artifacts or before making a test release.</p> <p>There are three locations to update: - /Cargo.toml file:   - <code>workspace.package.version</code> property   - <code>workspace.dependencies.hyperon.version</code> property - /python/VERSION file</p> <p>All three locations should contain the same version.</p>"},{"location":"DEVELOPMENT/#how-to-release-binaries","title":"How to release binaries","text":"<p>Update the version How to update the version in the main branch of the repository, raise PR and merge it. Use Create a new release link on the main page of the GitHub repo. Press <code>Choose a tag</code> control and type new tag which should be in form of <code>v&lt;version&gt;</code> (for example if version is <code>0.1.7</code> then tag is <code>v0.1.7</code>). After typing the tag press <code>Create new tag on publish</code>. Now press <code>Generate release notes</code> button. It will automatically fill the <code>Release title</code> and <code>Release description</code> fields. Tick <code>Set as a pre-release</code> checkbox if needed and press <code>Publish release</code> button. Now you have published new GitHub release and triggered a job to build release artifacts.</p> <p>After release job is finished one need to approve publishing artifacts to the PyPi repository. Before approving one can download and test Python wheels built. To check the job status go the <code>Actions/release-pyhon</code> page, and select last workflow run. Links to the archives with the artifacts are located at the bottom of the page.</p> <p>If distribution wheels are good then one can approve the publishing process. At the top of the workflow run page there are two blocks <code>Publish to Test PyPi</code> and <code>Publish to PyPi</code>. First press <code>Publish to Test PyPi</code> block approve it and wait for publishing. It is critical to start from Test PyPi because release cannot be removed from the PyPi after publishing.</p> <p>After release is published check it can be installed executing: <pre><code>python3 -m pip install --index-url https://test.pypi.org/simple/ hyperon\n</code></pre> Check that the latest published version was downloaded and installed. If you are making a test release then you should not publish it to the PyPi. If it is a production release then proceed with <code>Publish to PyPi</code> block.</p>"},{"location":"DEVELOPMENT/#how-to-check-release-job-in-fork","title":"How to check release job in fork","text":"<p>If you don't need to test publishing or Docker building procedures just run release workflow manually. Otherwise you need to trigger release as usual.</p> <p>First you need to select the test release version. It should contain an additional version digit after the latest officially released version. Let's say the latest released version is <code>0.1.7</code>. Then the test release version should be <code>0.1.7.x</code> for instance <code>0.1.7.1</code>. Start from 1 and increment it after each release you published successfully.</p> <p>Make a separate branch to release the code. It is not necessary but it is highly recommended to not pollute the main branch of the fork. In order to be able releasing from the branch one need to temporary make it default branch. It is done by using GitHub repo <code>Settings/General/Default branch</code> control.</p> <p>Update the version in the branch to the test release version you constructed. Commit and push this change in your test branch. Now you are ready to make a test release. See release binaries instruction.</p> <p>After testing the release procedure remove the commit with version update from your branch. And set default branch setting to the previous value.</p>"},{"location":"building_docs/","title":"Howto Build and Publish Documentation","text":""},{"location":"building_docs/#building-rust-documentation","title":"Building Rust Documentation","text":"<p>Run the following command under the root directory of the repository: <pre><code>cargo doc --no-deps\n</code></pre> Docs can be found at <code>./target/doc/hyperon/index.html</code>.</p>"},{"location":"building_docs/#building-c-documentation","title":"Building C Documentation","text":"<ol> <li> <p><code>doxygen</code> must be installed. Depending on your platform it may be easiest to use a package manager.</p> <ul> <li>using apt: <code>sudo apt-get install doxygen</code></li> <li>using homebrew (Mac): <code>brew install doxygen</code></li> <li>installing from source: [https://www.doxygen.nl/manual/install.html]</li> </ul> </li> <li> <p>Build the Hyperon C library, following the instructions here: [https://github.com/trueagi-io/hyperon-experimental?tab=readme-ov-file#c-and-python-api]</p> </li> <li> <p>Set CMake environment variables. Relative to the <code>build</code> directory, run the following:</p> <ul> <li><code>export CMAKE_CURRENT_SOURCE_DIR=../c/</code></li> <li><code>export HYPERONC_INCLUDE_DIR=./hyperonc-install/include/hyperonc/hyperon/</code></li> </ul> </li> <li> <p>Invoke <code>doxygen</code> using the following command: <code>doxygen ../c/hyperonc.doxyfile</code></p> </li> </ol> <p>The top page for the rendered HTML results will be written to <code>./html/index.html</code>, and latex results will be similarly written to <code>./latex/index.tex</code></p>"},{"location":"building_docs/#building-metta-standard-library-documentation","title":"Building MeTTa Standard Library Documentation","text":"<p>Run the following command under the root directory of the repository: <pre><code>cargo run --release --bin metta-repl ./mkdocs.metta\n</code></pre> Docs can be found at <code>./doc/generated/*.md</code>.</p>"},{"location":"building_docs/#building-python-documentation","title":"Building Python Documentation","text":"<p>Install <code>mkdocs</code> and dependencies. <pre><code>pip install mkdocs-material==9.7.0 \\\n    mkdocs-minify-plugin==0.8.0 \\\n    mkdocstrings[python]==0.26.1\n</code></pre></p> <p>Run the following command under the root directory of the repository: <pre><code>mkdocs build\n</code></pre></p>"},{"location":"building_docs/#publishing-the-documentation","title":"Publishing the Documentation","text":"<p>Make all of three steps above. Then copy Rust and C API documentation under the common site tree: <pre><code>cp -R ./target/doc ./site/rust\ncp -R ./build/html ./site/c\n</code></pre></p> <p>Publish <code>./site</code> directory as <code>gh-pages</code> branch of the repository: <pre><code>ghp-import -m 'Deploy documentation' \\\n    --push \\\n    --force \\\n    --no-history \\\n    --remote=&lt;git remote repo&gt; \\\n    --branch=gh-pages \\\n    ./site\n</code></pre></p>"},{"location":"das_setup/","title":"Distributed AtomSpace setup","text":""},{"location":"das_setup/#running-das-module-tests-locally","title":"Running DAS module tests locally","text":""},{"location":"das_setup/#install-das-toolbox-in-order-to-get-das-cli-debian-based-linux-users","title":"Install <code>das-toolbox</code> in order to get <code>das-cli</code> (Debian based Linux users):","text":"<pre><code>sudo apt -y update\nsudo apt -y install wget\n\nwget -O - http://45.77.4.33/apt-repo/setup.sh | sudo bash\n\nsudo apt -y install das-toolbox\n\n# &gt;= 1.0.0\ndas-cli --version\n</code></pre> <p>You can also run <code>das-cli</code> from source, using python3 (other OS): <pre><code>git clone https://github.com/singnet/das-toolbox.git\n\ncd das-toolbox\ngit checkout tags/1.0.0\n\n# Optional - Create a virtual env\npython3 -m venv .venv\nsource .venv/bin/activate\n\npip install -e das-cli/\n</code></pre></p> <ol> <li> <p>Set up <code>das-cli</code> configurations <pre><code>das-cli config set\n# Or\npython3 das-cli/src/das_cli.py config set\n\n# For all other prompts, you can just hit ENTER\n\n&gt;&gt;&gt;\n? Choose the AtomDB backend:  MongoDB + Redis\nEnter Redis port [40020]: \nIs it a Redis cluster? [y/N]: \nEnter MongoDB port [40021]: \nEnter MongoDB username [admin]: \nEnter MongoDB password [admin]: \nIs it a MongoDB cluster? [y/N]: \nEnter Jupyter Notebook port [40019]: \nEnter the Attention Broker port [40001]: \nEnter the Query Agent port [40002]: \nEnter the Link Creation Agent Server port [40003]: \nEnter the Inference Agent port [40004]: \nEnter the Evolution agent port [40005]: \nEnter the Context Broker port [40006]: \nConfiguration file saved -&gt; /Users/arturgontijo/.das\n</code></pre></p> </li> <li> <p>Start Databases <pre><code>das-cli db start\n# Or\npython3 das-cli/src/das_cli.py db start\n\n&gt;&gt;&gt;\nStarting Redis service...\nRedis has started successfully on port 40020 at localhost, operating under the server user arturgontijo.\nStarting MongoDB service...\nMongoDB has started successfully on port 40021 at localhost, operating under the server user arturgontijo.\n</code></pre></p> </li> <li> <p>Load Databases with <code>animals.metta</code> content: <pre><code># We need the metta file's absolute path, moving it to /tmp for convinience\ncp integration_tests/das/animals.metta /tmp\n\n# Then\ndas-cli metta load /tmp/animals.metta\n# Or\npython3 das-cli/src/das_cli.py metta load /tmp/animals.metta\n\n&gt;&gt;&gt;\ndas-cli-mongodb-40021 is running on port 40021\ndas-cli-redis-40020 is running on port 40020\nLoading metta file /tmp/animals.metta...\nConnecting to Redis at localhost:40020\nConnecting to MongoDB at localhost:40021\nDone.\n</code></pre></p> </li> <li> <p>Start Attention Broker service <pre><code>das-cli ab start\n# Or\npython3 das-cli/src/das_cli.py ab start\n\n&gt;&gt;&gt;\nStarting Attention Broker service...\nAttention Broker started on port 40001\n</code></pre></p> </li> <li> <p>Start Query Broker service <pre><code>das-cli qa start\n# Or\npython3 das-cli/src/das_cli.py qa start\n\n&gt;&gt;&gt;\nStarting Query Agent service...\nQuery Agent started on port 40002\n</code></pre></p> </li> <li> <p>Running DAS tests <pre><code># Run it passing a metta file (from repo's root)\ncargo run -r --bin metta-repl integration_tests/das/test.metta\n\n&gt;&gt;&gt;\n[()]\n[()]\n[ServiceAvailable: pattern_matching_query]\n[()]\n[()]\n[()]\n[()]\n[()]\n\n# Optional: use RUST_LOG=das=LEVEL to inspect workflow\nRUST_LOG=das=debug ./target/release/metta-repl integration_tests/das/test.metta\n</code></pre></p> </li> <li> <p>Stop all services (removing their containers) <pre><code>das-cli qa stop\ndas-cli ab stop\ndas-cli db stop\n\n# Or\npython3 das-cli/src/das_cli.py qa stop\npython3 das-cli/src/das_cli.py ab stop\npython3 das-cli/src/das_cli.py db stop\n</code></pre></p> </li> </ol>"},{"location":"metta/","title":"MeTTa language specification","text":"<p>This document covers MeTTa language specification implemented by hyperon-experimental interpreter.</p>"},{"location":"metta/#syntax","title":"Syntax","text":""},{"location":"metta/#s-expression-grammar","title":"S-expression grammar","text":"<p>This is the S-expression grammar of the MeTTa language. The program is consisted of the atoms prefixed or not prefixed by the <code>!</code> sign.</p> <pre><code>METTA ::= { [ '!', [ DELIM ] ], ATOM, [ DELIM ] } ;\n\nATOM ::= SYMBOL | VARIABLE | GROUNDED | EXPRESSION ;\nSYMBOL ::= WORD;\nWORD ::= ( CHAR | '#' ), { CHAR | '\"' | '#' } ;\nVARIABLE ::= '$', ( CHAR | '\"' ), { CHAR | '\"' } ;\nGROUNDED ::= STRING | WORD ;\nEXPRESSION ::= '(', { ATOM, [ DELIM ] }, ')' ;\n\nSTRING ::= '\"', { CHAR | WHITESPACE | '#' | '(' | ')' | ';' }, '\"' ;\nCOMMENT ::= ';', { CHAR | ' ' | '\\t' | '\"' | '#' | '(' | ')' | ';' } ! EOL ;\nDELIM ::= { WHITESPACE | COMMENT } ;\n\nCHAR ::= &lt;any character except WHITESPACE and ( '\"' | '#' | '(' | ')' | ';' )&gt; ;\nWHITESPACE ::= ' ' | '\\t' | EOL ;\nEOL ::=  '\\r' | '\\n' ;\n</code></pre> <p>(*) Symbol atom can start with the <code>!</code> character. For example <code>!name</code> is a valid symbol and not an atom prefixed by <code>!</code>. This is an artifact of the HE parser evolution process and not a strong requirement.</p> <p>(*) The <code>#</code> character is used internally by HE to represent the automatically generated variables. It is the reason why <code>#</code> is reserved and cannot be used inside a variable name.</p> <p>(*) Whitespace character is any character for which <code>char.is_whitespace()</code> method from the Rust standard library returns true.</p> <p>The symbol and grounded atoms are very similar from the grammar perspective. The difference is in the way how they are represented in memory. A symbol can be considered an id. A grounded atom on the other hand may have state and usually has some natural representation in the host language (i.e. Rust, Python or other programming language).</p> <p>The grounded atoms are constructed from the <code>WORD</code> or <code>STRING</code> grammar tokens by a tokenizer. Tokenizer is a collection of the pairs <code>(&lt;token regexp&gt;, &lt;constructor function&gt;)</code>. If the <code>WORD</code> or <code>STRING</code> token is matched by one of the <code>&lt;token regexp&gt;</code> from the tokenizer then a grounded atom is constructed by <code>&lt;constructor function&gt;</code>. <code>&lt;constructor function&gt;</code> gets the matched token as an argument. For instance it is possible instantiating the integer grounded atoms by adding the pair <code>([0-9]+, &lt;int parser&gt;)</code> into the tokenizer.</p>"},{"location":"metta/#special-expressions","title":"Special expressions","text":"<p>This section lists atoms with some special meaning in the interpreter.  The expressions listed below are not the only expressions possible when the special atoms are used. For example having the <code>(= ...)</code> expression with more than two arguments is absolutely normal. In such case the interpreter will not recognize it as a function definition but the expression still can be the part of the knowledge base.</p> <p>In general the symbols listed below are similar to the reserved words in the other languages. In MeTTa the programmer still can use these symbols in an unusual context but it should be noted that the interpreter has a special meaning for them.</p>"},{"location":"metta/#function-expression","title":"Function expression","text":"<p>The <code>=</code> atom is used to define a function expression in the following form: <pre><code>(= &lt;call recognition template&gt; &lt;body template&gt;)\n</code></pre></p> <p>For example the <code>if</code> function can be defined as following: <pre><code>(= (if True $then $else) $then)\n(= (if False $then $else) $else)\n</code></pre></p>"},{"location":"metta/#type-assignment","title":"Type assignment","text":"<p>The <code>:</code> atom is used to define the type of the atom: <pre><code>(: &lt;atom&gt; &lt;type&gt;)\n</code></pre></p> <p>For example the <code>if</code> function could have the following type definition: <pre><code>(: if (-&gt; Bool Atom Atom $t))\n</code></pre></p>"},{"location":"metta/#function-type","title":"Function type","text":"<p>The <code>-&gt;</code> atom is used to introduce a type of a function: <pre><code>(-&gt; arg1_type arg2_type ... argN_type ret_type)\n</code></pre></p> <p>For example the type of the <code>if</code> function: <pre><code>(-&gt; Bool Atom Atom $t)\n</code></pre></p>"},{"location":"metta/#elementary-types","title":"Elementary types","text":"<p>There are the number of symbols which are used as the basic types: - <code>Type</code> - the type of any type - <code>%Undefined%</code> - the unknown type - <code>Atom</code> - the type of any atom - <code>Symbol</code> - the type of the symbol atom - <code>Variable</code> - the type of the variable atom - <code>Expression</code> - the type of the expression atom - <code>Grounded</code> - the type of the grounded atom</p> <p>All of them except the <code>Type</code> affect the order of the expression evaluation. Last four types correspond to the types of the atoms defined by the grammar. These types plus <code>Atom</code> are referred below as meta-types. <code>Atom</code> is a special meta-type which matches any atom and used for changing the order of evaluation.</p>"},{"location":"metta/#special-function-results","title":"Special function results","text":"<ul> <li><code>Empty</code> - the function doesn't return any result, it is different from the   void or unit result in other languages</li> <li><code>NotReducible</code> - returns the unchanged function call instead</li> <li><code>Error</code> - the error result constructor</li> </ul> <p>The <code>Error</code> expression has the following format: <pre><code>(Error &lt;atom with error&gt; &lt;error message&gt;)\n</code></pre> where <code>&lt;error message&gt;</code> is either a string or a symbol or one of the following: - <code>StackOverflow</code> - returned by the interpreter when the stack depth is   restricted and maximum depth is reached - <code>NoReturn</code> - this error is reserved by the minimal MeTTa interpreter and   should not be returned if program doesn't have <code>(function ...)</code> minimal MeTTa   blocks (see minimal MeTTa documentation   for more information) - <code>IncorrectNumberOfArguments</code> - the number of argument in the call doesn't   equal to the number of parameters of the called function - <code>(BadArgType &lt;arg position&gt; &lt;expected type&gt; &lt;actual type&gt;)</code> - the argument   type error - <code>(BadType &lt;expected type&gt; &lt;actual type&gt;)</code> - the type cast error</p> <p>(*) <code>ErrorType</code> is a type of the error atom which is returned by the <code>Error</code> type constructor. This symbol has no special meaning in HE. On the other hand it could be used to introduce custom type constructors. This could be implemented by making an interpreter treating any expression which has <code>ErrorType</code> type as an error.</p>"},{"location":"metta/#minimal-metta-instructions","title":"Minimal MeTTa instructions","text":"<p>The minimal MeTTa is an attempt to create an assembly language for MeTTa. Minimal MeTTa related atoms are listed here because while they are not a part of the standard library they are still recognized and evaluated by the MeTTa interpreter. Full documentation on minimal MeTTa can be found at minimal-metta.md.</p> <p>(*) It is possible to implement MeTTa interpreter in minimal MeTTa and HE interpreter is implemented in this way. Implementing minimal MeTTa interpreter in pure MeTTa is not possible. But on the other hand one could implement minimal MeTTa as a MeTTa library containing the corresponding grounded functions. Some internal APIs of HE should be changed to make this doable. Main reason is that the grounded functions don't have access to the context of the MeTTa interpreter, for instance to the current working atomspace.</p> <p>Minimal MeTTa instructions: - <code>(eval &lt;atom to evaluate&gt;)</code> - makes one step of the evaluation - <code>(evalc &lt;atom to evaluate&gt; &lt;context space&gt;)</code> - makes one step of the   evaluation in the context of the passed space - <code>(chain &lt;atom&gt; &lt;var&gt; &lt;template&gt;)</code> -  interpret <code>&lt;atom&gt;</code> and substitute   <code>&lt;var&gt;</code> in <code>&lt;template&gt;</code> by the result of the interpretation - <code>(unify &lt;atom&gt; &lt;pattern&gt; &lt;then&gt; &lt;else&gt;)</code> - unify <code>&lt;atom&gt;</code> argument with   <code>&lt;pattern&gt;</code> argument and return <code>&lt;then&gt;</code> argument if the unification is   successful and <code>&lt;else&gt;</code> argument otherwise. - <code>(decons-atom &lt;expression&gt;)</code> - return the head and the tail of the passed   expression - <code>(cons-atom &lt;head&gt; &lt;tail&gt;)</code> - return the expression constructed from <code>&lt;head&gt;</code>   and <code>&lt;tail&gt;</code> - <code>(function &lt;body&gt;)</code> - evaluate <code>&lt;body&gt;</code> until <code>(return &lt;atom&gt;)</code> is evaluated - <code>(return &lt;atom&gt;)</code> - finish the evaluation of an outer function with <code>&lt;atom&gt;</code>   as the result - <code>(collapse-bind &lt;atom&gt;)</code> - interpret <code>&lt;atom&gt;</code> and return a tuple which   contains all of the results - <code>(superpose-bind &lt;result of collapse-bind&gt;)</code> - continue the process of the   interpretation from the moment where <code>collapse-bind</code> stopped - <code>(metta &lt;atom&gt; &lt;type&gt; &lt;space&gt;)</code> - evaluate <code>&lt;atom&gt;</code> in MeTTa interpreter   using <code>&lt;space&gt;</code> as a context and expecting result with <code>&lt;type&gt;</code> - <code>(context-space)</code> - return the space which is used by the interpreter - <code>(call-native &lt;function name&gt; &lt;pointer to the function&gt; &lt;arguments&gt;)</code> - call   the passed Rust function with the passed arguments</p> <p>(*) <code>call-native</code> instruction cannot be called from a MeTTa program, but it can be returned by a grounded function for the further evaluation.</p>"},{"location":"metta/#interpretation","title":"Interpretation","text":"<p>MeTTa program is interpreted atom by atom. If an atom is not prefixed by <code>!</code> it is added into the atomspace of the top module. Hierarchy of modules is explained later. For now one can count that there is no atomspaces except the top module's atomspace. When an atom is prefixed by <code>!</code> sign it is evaluated and the result of the evaluation is returned to the user. The result is not added into the atomspace. The \"atom by atom\" evaluation means that each atom sees the effects which were applied by the preceding atom evaluations or atomspace modifications.</p> <p>The evaluation of the atom is a call of the <code>metta</code> symbol with four arguments: atom to be evaluated, expected type, context space, and variable bindings. The expected type of the evaluated atom is <code>%Undefined%</code> because we don't have the syntax for specifying it. The variable bindings are empty at the beginning of the evaluation.</p> <p><code>metta</code> symbol itself is a part of the interpreter implementation. It allows calling the interpreter within the MeTTa program itself. Thus the algorithm of the evaluation of the <code>metta</code> symbol is the algorithm of the interpreter implementation. This algorithm is listed below in Evaluation section. This algorithm is not equal to the Rust implementation of the HE but in many aspects it is similar and usually one can see the correspondence with the Rust code.</p> <p>The algorithm is presented in a form of a program on some Python-like pseudo programming language.  <code>&lt;...&gt;</code> notation is used to embed the statements which depend on the data structures used because this details are not the part of the specification. The names of the variables in the pseudo code are started with <code>$</code> sign to differentiate them from MeTTa symbols which are written in the same way they are used in MeTTa programs. Also there is a <code>~</code> operator which designates the matching of the atom variable with some atom pattern. This operator is used to make the specification shorter.</p> <p>Two special functions are not specified: <code>match_atoms</code> and <code>merge_bindings</code>. They will be specified in the following sections. For now one can rely on intuitive understanding how two-side unification and bindings merging works.</p>"},{"location":"metta/#evaluation","title":"Evaluation","text":""},{"location":"metta/#evaluate-atom-metta","title":"Evaluate atom (metta)","text":"<pre><code>Input:\n- $atom - atom to be evaluated\n- $type - expected type of the result\n- $space - context atomspace\n- $bindings - current variable bindings\n\nOutput:\n- [(Atom, Bindings)]\n\n$metatype =  &lt;meta-type of the $atom&gt;\nif $atom == Empty or $atom ~ (Error ...):\n    return [($atom, $bindings)]\nelif $type == Atom or $type == $metatype or $metatype == Variable:\n    return [($atom, $bindings)]\nelif $metatype == Expression and &lt;$atom is evaluated already&gt;:\n    return [($atom, $bindings)]\nelif $metatype == Symbol or $metatype == Grounded or $atom == ():\n    return type_cast($atom, $bindings, $type, $space)\nelse:\n    $results = interpret_expression($atom, $type, $space, $bindings)\n    $error = filter(lambda $a: $a ~ (Error ...), $results)\n    $success = filter(lambda $a: not($a ~ (Error ...)), $results)\n    if len($success) &gt; 0:\n        for $a in $success:\n            if &lt;$a is expression&gt;:\n                # this is an optimization step\n                &lt;mark $a as evaluated&gt;\n        return $success\n    else:\n        return $error\n</code></pre>"},{"location":"metta/#cast-types-type_cast","title":"Cast types (type_cast)","text":"<pre><code>Input:\n- $atom - atom to cast\n- $type - type to cast to\n- $space - context atomspace\n- $bindings - current variable bindings\n\nOutput:\n- [(Atom, Bindings)]\n\n$types = &lt;list of the types of the $atom from the $space&gt;\n$no_match = []\nfor $t in $types:\n    $matches = match_types($t, $type, $bindings):\n    if $matches == []:\n        $no_match += [$t]\n    else:\n        return [($atom, $m) for $m in $matches]\nreturn [((Error $atom (BadType $type $t)), $bindings) for $t in $no_match]\n</code></pre>"},{"location":"metta/#match-types-match_types","title":"Match types (match_types)","text":"<pre><code>Input:\n- $type1 - first type\n- $type2 - second type\n- $bindings - current variable bindings\n\nOutput:\n- [Bindings]\n\nif $type1 == %Undefined% or $type1 == Atom\n    or $type2 == %Undefined% or $type2 == Atom:\n        return [$bindings]\n\nreturn match_atoms($type1, $type2)\n</code></pre>"},{"location":"metta/#interpret-expression-interpret_expression","title":"Interpret expression (interpret_expression)","text":"<pre><code>Input:\n- $atom - atom to be evaluated\n- $type - expected type of the result\n- $space - context atomspace\n- $bindings - current variable bindings\n\nOutput:\n- [(Atom, Bindings)]\n\n$op = &lt;first item of the $atom tuple&gt;\nif &lt;$op is an atom with incorrect type&gt;:\n    # it may happen if $op is a function call\n    return &lt;list of (Error $op (BadArgType ...)) for each erroneous type found&gt;\n$actual_types = &lt;list of the types of the $op&gt;\n\n$errors = []\nfor $f in &lt;items from $actual_types which are valid function types&gt;:\n    match check_if_function_type_is_applicable($atom, $f, $type, $space, $bindings):\n        case Err($errs):\n            $errors += [($e, $bindings) for $e in $errs]\n        case Ok($succs):\n            $ret_type = &lt;return type of $f&gt;\n            if $ret_type == Expression:\n                # it is to prevent Expression working like Atom return type\n                $ret_type = %Undefined%\n            $result = []\n            for $b in $succs:\n                for ($a, $b) in interpret_function($atom, $f, $type, $space, $b):\n                    result += metta_call($a, $ret_type, $space, $b)\n            return $result\n\n$tuples = []\nif &lt;$actual_types contains non function types or %Undefined% type&gt;:\n    for ($a, $b) in interpret_tuple($atom, $space, $bindings):\n        $tuples += metta_call($a, $type, $space, $b)\n\nreturn $tuples + $errors\n</code></pre>"},{"location":"metta/#interpret-tuple-interpret_tuple","title":"Interpret tuple (interpret_tuple)","text":"<pre><code>Input:\n- $atom - atom to be evaluated\n- $space - context atomspace\n- $bindings - current variable bindings\n\nOutput:\n- [(Atom, Bindings)]\n\n$result = []\n$head = &lt;head of the $atom tuple&gt;\n$tail = &lt;tail of the $atom tuple&gt;\nfor ($h, $hb) in metta($head, %Undefined%, $space, $bindings):\n    if $h == Empty or $h ~ (Error ...):\n        $result += [($h, $hb)]\n    else:\n        for ($t, $tb) in interpret_tuple($tail, $space, $hb):\n            if $t == Empty or $t ~ (Error ...):\n                $result += [($t, $tb)]\n            else:\n                $result += [(&lt;tuple with head $h and tail $t&gt;, $tb)]\nreturn $result\n</code></pre>"},{"location":"metta/#check-if-function-type-is-applicable-check_if_function_type_is_applicable","title":"Check if function type is applicable (check_if_function_type_is_applicable)","text":"<pre><code>Input:\n- $atom - function call to check\n- $func_type - function type\n- $expected_type - expected return type\n- $space - context atomspace\n- $bindings - current variable bindings\n\nOutput:\n- Err([Atom]) | Ok([Bindings])\n\nif &lt;number of arguments in $func_type&gt; != &lt;number of arguments in $atom&gt;:\n    return [Err((Error $atom IncorrectNumberOfArguments), $bindings)]\n\n$errors = []\n$results = [$bindings]\nfor $idx in range(1, len($atom)):\n    $arg = $atom[$idx]\n    $next = []\n    for $r in $results:\n        $check = check_argument_type($arg, $func_type[$idx], $space, $r)\n        for $c in $check:\n            if $c ~ Err($t):\n                $errors += [(Error $atom (BadArgType ($idx - 1) $func_type[$idx] $t))]\n            if $c ~ Ok($b):\n                $next += [$b]\n    $results = $next\n\n$next = []\nfor $r in $results:\n    $matched = match_types($expected_type, $func_type.last, $r)\n    if matched == []:\n        $errors += [(Error $atom (BadType $expected_type $func_type.last))]\n    else:\n        $next += $matched\n$results = $next\n\nif len($results) == 0:\n    return Err($errors)\nelse:\n    return Ok($results)\n</code></pre>"},{"location":"metta/#check-argument-type-check_argument_type","title":"Check argument type (check_argument_type)","text":"<pre><code>Input:\n- $argument - argument to check\n- $expected_type - expected type\n- $space - context atomspace\n- $bindings - current variable bindings\n\nOutput:\n- [Err(Type) | Ok(Bindings)]\n\n$actual_types = &lt;list of the types of the $argument from the $space&gt;\n$result = []\nfor $t in $actual_types:\n    $matched = match_types($expected_type, $t, $bindings)\n    if $matches == []:\n        $result += [Err($t)]\n    else:\n        $result += [Ok($m) for $m in $matches]\nreturn $result\n</code></pre>"},{"location":"metta/#interpret-function-interpret_function","title":"Interpret function (interpret_function)","text":"<pre><code>Input:\n- $atom - atom to be evaluated\n- $op_type - type of the function\n- $return_type - expected return type\n- $space - context atomspace\n- $bindings - current variable bindings\n\nOutput:\n- [(Atom, Bindings)]\n\n$result = []\n$op = &lt;head of the $atom tuple&gt;\n$args = &lt;tail of the $atom tuple&gt;\n$arg_types = &lt;list of the argument types extracted from $op_type&gt;\nfor ($h, $hb) in metta($op, $op_type, $space, $bindings):\n    if $h == Empty or $h ~ (Error ...):\n        $result += [($h, $hb)]\n    else:\n        for ($t, $tb) in interpret_args($args, $arg_types, $space, $hb):\n            if $t == Empty or $t ~ (Error ...):\n                $result += [($t, $tb)]\n            else:\n                $result += [(&lt;tuple with head $h and tail $t&gt;, $tb)]\nreturn $result\n</code></pre>"},{"location":"metta/#interpret-arguments-interpret_args","title":"Interpret arguments (interpret_args)","text":"<pre><code>Input:\n- $args - args to be evaluated\n- $types - types of the args\n- $space - context atomspace\n- $bindings - current variable bindings\n\nOutput:\n- [(Atom, Bindings)]\n\n$result = []\n$atom = &lt;head of the $args tuple&gt;\n$args_tail = &lt;tail of the $args tuple&gt;\n$type = &lt;head of the $types tuple&gt;\n$types_tail = &lt;tail of the $types tuple&gt;\nfor ($h, $hb) in metta($atom, $type, $space, $bindings):\n    if ($h == Empty or $h ~ (Error ...)) and $h != $atom:\n        $result += [($h, $hb)]\n    else:\n        for ($t, $tb) in interpret_args($args_tail, $types_tail, $space, $hb):\n            if $t == Empty or $t ~ (Error ...):\n                $result += [($t, $tb)]\n            else:\n                $result += [(&lt;tuple with head $h and tail $t&gt;, $tb)]\nreturn $result\n</code></pre>"},{"location":"metta/#call-metta-expression-metta_call","title":"Call MeTTa expression (metta_call)","text":"<pre><code>Input:\n- $atom - atom to be evaluated\n- $type - expected type of the result\n- $space - context atomspace\n- $bindings - current variable bindings\n\nOutput:\n- [(Atom, Bindings)]\n\nif $atom ~ (Error ...):\n    return [($atom, $bindings)]\n\n$op = &lt;head atom of the $atom expression&gt;\n$args = &lt;tail of the $atom expression&gt;\n$results = []\nif &lt;$op is executable grounded atom&gt;:\n    match &lt;call $op native function passing $args as arguments&gt;:\n        case Ok($results):\n            $results = [metta($r, $type, $space, $mb) for ($r, $rb) in $results for $mb in merge_bindings($rb, $bindings)]\n        case RuntimeError($message):\n            return [(Error $atom &lt;symbol atom containing $message&gt;)]\n        case NoReduce:\n            return [($atom, $bindings)]\n        case IncorrectArgument:\n            return [($atom, $bindings)]\nelse:\n    $query_output = query($space, (= $atom $X))\n    if len($query_output) &gt; 0:\n        for $rb in $query_output:\n            for $mb in merge_bindings($rb, $bindings):\n                if not(&lt;$mb has loop bindings&gt;) and &lt;$mb contains value for the $X variable&gt;:\n                    $x = &lt;get value of the $X variable from $mb&gt;\n                    $results += [metta($x, $type, $space, $mb)]\n    else:\n        $results += [($atom, $bindings)]\n\nif len($results) == 0:\n    return [(Empty, $bindings)]\nelse:\n    return $results\n</code></pre>"},{"location":"metta/#matching","title":"Matching","text":"<p>This section explains the atom matching algorithm. The result of matching is list of variable binding sets. If two atoms matched don't contain grounded atoms with custom matching procedure then the result of matching is exactly one binding set (because two atoms are either equal or not). But in general case custom matching is possible and the result may be a list of binding sets.</p> <p>Each binding is a set of two kinds of relations. First kind of relation is assigning a value to a variable. This relation is designated by <code>&lt;-</code> arrow. For example <code>$x &lt;- SomeValue</code> means the symbol atom <code>SomeValue</code> is assigned to the variable <code>$x</code>.  Second kind of relation is equality of two variables. This relation is designated by <code>=</code> sign. For eample <code>$x = $y</code> means variables <code>$x</code> and <code>$y</code> are equal. The equality means variables have equal or matchable values. The full set of bindings is designated using curly braces with relations inside listed using comma. For example: <code>{ $x &lt;- SomeValue, $x = $y }</code>. The order of relations doesn't matter.</p> <p>For a sake of simplicity I used operations <code>+</code> and <code>-</code> in algorithms below to explain how binding set is modified. For example <code>$bindings - { $b &lt;- $b_value } + { $a = $b }</code> means one need remove relation <code>$b &lt;- $b_value</code> from $bindings and add relation <code>$a = $b</code>.</p>"},{"location":"metta/#match-atoms-match_atoms","title":"Match atoms (match_atoms)","text":"<pre><code>Input:\n- $left - atom to be evaluated\n- $right - expected type of the result\n\nOutput:\n- [Bindings]\n\n$ml = &lt;meta type of the $left atom&gt;\n$mr = &lt;meta type of the $right atom&gt;\n$result = [{}] \n\nif $ml == Symbol and $mr == Symbol and $left == $right:\n    $result = [{}]\nelif $ml == Variable and $mr == Variable:\n    $result = [{ $left = $right }]\nelif $ml == Variable:\n    $result = [{ $left &lt;- $right }]\nelif $mr == Variable:\n    $result = [{ $right &lt;- $left }]\nelif $ml == Expression and $mr == Expression and len($left) == len($right):\n    for $i in range(0, len($left)):\n        $sub = match_atoms($left[$i], $right[$i])\n        $next = []\n        for $a in $result:\n            for $b in $sub:\n                $next += merge_bindings($a, $b)\n        $result = $next\nelif $ml == Grounded and &lt;$left has custom matching implementation&gt;:\n    $result = &lt;call $left custom matching on $right&gt;\nelif $mr == Grounded and &lt;$right has custom matching implementation&gt;:\n    $result = &lt;call $right custom matching on $left&gt;\nelif $ml == Grounded and $mr == Grounded:\n    $result = [{}]\nelse:\n    $result = []\n\nreturn filter(lambda $b: &lt;$b doesn't have variable loops&gt;, $results)\n</code></pre>"},{"location":"metta/#merge-bindings-merge_bindings","title":"Merge bindings (merge_bindings)","text":"<pre><code>Input:\n- $left - variable bindings\n- $right - variable bindings\n\nOutput:\n- [Bindings]\n\n$result = [$left]\nfor $rel in &lt;set of \"assign value to var\" or \"vars are equal\" relations of $right&gt;:\n    if &lt;$rel is \"assign value $val to var $var\" relation&gt;:\n        $result = [ add_var_binding($r, $var, $val) for $r in $result]\n    if &lt;$rel is \"var $a is equal to var $b\"&gt;:\n        $result = [ add_var_equality($r, $a, $b) for $r in $result]\nreturn $result\n</code></pre>"},{"location":"metta/#add-variable-binding-to-binding-set-add_var_binding","title":"Add variable binding to binding set (add_var_binding)","text":"<pre><code>Input:\n- $bindings - variable bindings\n- $var - variable atom\n- $val - value atom\n\nOutput:\n- [Bindings]\n\n$prev = &lt;value of $var in $bindings or None&gt;\nif $prev is None:\n    return [$bindings + { $var &lt;- $val }]\nelif $val == $prev:\n    return [$bindings]\nelse:\n    $match = match_atoms($prev, $val)\n    for $b in $match:\n        $result += merge_bindings($bindings, $b)\n    return $result\n</code></pre>"},{"location":"metta/#add-variable-equality-to-binding-set-add_var_equality","title":"Add variable equality to binding set (add_var_equality)","text":"<pre><code>Input:\n- $bindings - variable bindings\n- $a - first variable atom\n- $b - second variable atom\n\nOutput:\n- [Bindings]\n\n$a_value = &lt;value of $a in $bindings or None&gt;\n$b_value = &lt;value of $b in $bindings or None&gt;\n\nif $a_value is None or $b_value is None or $a_value == $b_value:\n    return [$bindings - { $b &lt;- $b_value } + { $a = $b }]\nelse:\n    $result = []\n    $match = match_atoms($a_value, $b_value)\n    for $b in $match:\n        $result += merge_bindings($bindings, $b)\n    return $result\n</code></pre>"},{"location":"metta/#standard-library","title":"Standard library","text":""},{"location":"minimal-metta/","title":"Minimal MeTTa specification","text":"<p>This document describes the minimal set of embedded MeTTa instructions which is designed to write the complete MeTTa interpreter in MeTTa. Current version of the document includes improvements which were added after experimenting with the first version of such an interpreter. It is not a final version and some directions of the future work is explained at the end of the document.</p>"},{"location":"minimal-metta/#minimal-instruction-set","title":"Minimal instruction set","text":""},{"location":"minimal-metta/#interpreter-state","title":"Interpreter state","text":"<p>The MeTTa interpreter evaluates an atom passed as an input. It evaluates it step by step executing a single instruction on each step. In order to do that the interpreter needs a context which is wider than the atom itself. The context also includes: - an atomspace which contains the knowledge which drives the evaluation of the   expressions; - bindings of the variables which are used to evaluate expressions; the   bindings are empty at the beginning (see Explicit atomspace variable   bindings).</p> <p>Each step of interpretation inputs and outputs a list of pairs (<code>&lt;atom&gt;</code>, <code>&lt;bindings&gt;</code>) which is called interpretation plan. Each pair in the plan represents one possible way of interpreting the original atom or possible branch of the evaluation. Interpreter doesn't select one of them for further processing. It continues interpreting all of the branches in parallel. Below this is called non-deterministic evaluation.</p> <p>One step of the interpretation is an execution of a single instruction from a plan. An interpreter extracts atom and bindings from the plan and evaluates the atom. The result of the operation is a set of pairs (<code>&lt;atom&gt;</code>, <code>&lt;bindings&gt;</code>). Bindings of the result are merged with the previous bindings. Merge operation can also bring more than one result. Each such result is added as a separate pair into a result set. Finally all results from result set are added into the plan and step finishes.</p> <p>Here we suppose that on the top level the plan contains only the instructions from the minimal set. If an instruction returns the atom which is not from the minimal set it is not interpreted further and returned as a part of the final result. Thus only the instructions of the minimal set are considered a code other atoms are considered a data.</p>"},{"location":"minimal-metta/#evaluation-order","title":"Evaluation order","text":"<p>MeTTa implements the applicative evaluation order by default, arguments are evaluated before they are passed to the function. User can change this order using special meta-types as the types of the arguments. Minimal MeTTa operations don't rely on types and minimal MeTTa uses the fixed normal evaluation order, arguments are passed to the function without evaluation. But there is a chain operation which can be used to evaluate an argument before passing it. Thus <code>chain</code> can be used to change evaluation order in MeTTa interpreter.</p>"},{"location":"minimal-metta/#erroremptynotreducible","title":"Error/Empty/NotReducible/()","text":"<p>There are atoms which can be returned to designate a special situation in a code: - <code>(Error &lt;atom&gt; &lt;message&gt;)</code> means the interpretation is finished with error; - <code>Empty</code> means the corresponding branch of the evaluation returned no results,   such result is not returned among other results when interpreting is   finished; - <code>NotReducible</code> can be returned by <code>eval</code> in order to designate that function   can not be reduced further; for example it can happen when code tries to call   a type constructor (which has no definition), partially defined function   (with argument values which are not handled), or grounded function which   returns <code>NotReducible</code> explicitly; this atom is introduced to separate the   situations when atom should be returned \"as is\" from <code>Empty</code> when atom should   be removed from results; - Empty expression <code>()</code> is an instance of the unit type which is mainly used by   functions with side effects which has no meaningful value to return.</p> <p>These atoms are not interpreted further as they are not a part of the minimal set of instructions and considered a data.</p>"},{"location":"minimal-metta/#eval","title":"eval","text":"<p><code>(eval &lt;atom&gt;)</code> is a first instruction which evaluates an atom passed as an argument. Evaluation is different for the grounded function calls (the expression with a grounded atom on a first position) and pure MeTTa expressions. For the pure MeTTa expression the interpreter searches the <code>(= &lt;atom&gt; &lt;var&gt;)</code> expression in the atomspace. The found values of the <code>&lt;var&gt;</code> are the result of evaluation. Execution of the grounded atom leads to the call of the foreign function passing the tail of the expression as arguments. For example <code>(+ 1 2)</code> calls the implementation of addition with <code>1</code> and <code>2</code> as arguments. The list of atoms returned by the grounded function is a result of the evaluation in this case. A grounded function can have side effects as well. In both cases bindings of the <code>eval</code>'s argument are merged to the bindings of the result.</p> <p>Atomspace search can bring the list of results which is empty. When search returns no results then <code>NotReducible</code> atom is a result of the instruction. Grounded function can return a list of atoms, empty result, <code>ExecError::Runtime(&lt;message&gt;)</code> or <code>ExecError::NoReduce</code> result. The result of the instruction for a special values are the following: - <code>ExecError::Runtime(&lt;message&gt;)</code> returns <code>(Error &lt;original-atom&gt; &lt;message&gt;)</code>   atom; - <code>ExecError::NoReduce</code> returns <code>NotReducible</code> atom; - currently empty result removes result from the result set. It is done mainly   for compatibility. There is no valid reason to return an empty result from a   grounded function. Function can return <code>()/Empty/NotReducible</code> to express \"no   result\"/\"remove my result\"/\"not defined on data\".</p>"},{"location":"minimal-metta/#chain","title":"chain","text":"<p>Minimal MeTTa implements normal evaluation order (see Evaluation order. Arguments are passed to the function without evaluation. In case when argument should be evaluated before calling a function one can use <code>chain</code> instruction.</p> <p><code>chain</code>'s signature is <code>(chain &lt;atom&gt; &lt;var&gt; &lt;template&gt;)</code> and it is executed in two steps. <code>&lt;atom&gt;</code> argument is evaluated first and bindings of the evaluation result are merged to the bindings of the current result. After that <code>chain</code> substitutes all occurrences of <code>&lt;var&gt;</code> in <code>&lt;template&gt;</code> by the result of the evaluation and returns result of the substitution. When evaluation of the <code>&lt;atom&gt;</code> brings more than a single result <code>chain</code> returns one instance of the <code>&lt;template&gt;</code> expression for each result.</p>"},{"location":"minimal-metta/#functionreturn","title":"function/return","text":"<p><code>function</code> operation has the signature <code>(function &lt;atom&gt;)</code>. It evaluates the <code>&lt;atom&gt;</code> until it becomes <code>(return &lt;atom&gt;)</code>. Then <code>(function (return &lt;atom&gt;))</code> expression returns the <code>&lt;atom&gt;</code>.</p> <p>These operations are introduced for two reasons. First it should be possible to evaluate an atom until some result and prevent further result evaluation. This aspect is discussed in eval or return section.</p> <p>Second without having an abstraction of a function call it is difficult to debug the evaluation process. <code>function/return</code> allows representing nested function calls as a stack and provide controls to put the breakpoints on parts of this stack. Nevertheless using <code>chain</code> instead of <code>function</code> to implement the evaluation loop also allows representing stack in a natural form.</p> <p>Evaluation of the <code>function</code> should always end by evaluating <code>(return &lt;atom&gt;)</code> expression. But as a result of an error some branch may end by non evaluable atom instead. In such case interpreter returns <code>(Error NoReturn)</code> error.</p>"},{"location":"minimal-metta/#unify","title":"unify","text":"<p><code>unify</code> operation allows conditioning on the results of the evaluation. <code>unify</code>'s signature is <code>(unify &lt;atom&gt; &lt;pattern&gt; &lt;then&gt; &lt;else&gt;)</code>. The operation matches <code>&lt;atom&gt;</code> with a <code>&lt;pattern&gt;</code>. If match is successful then it returns <code>&lt;then&gt;</code> atom and merges bindings of the original <code>&lt;atom&gt;</code> to resulting variable bindings. If matching is not successful then it returns the <code>&lt;else&gt;</code> branch with the original variable bindings.</p>"},{"location":"minimal-metta/#cons-atomdecons-atom","title":"cons-atom/decons-atom","text":"<p><code>cons-atom</code> and <code>decons-atom</code> allows constructing and deconstructing the expression atom from/to pair of the head and tail. <code>(decons-atom &lt;expr&gt;)</code> expects non-empty expression as an argument and returns a pair <code>(&lt;head&gt; &lt;tail&gt;)</code>. <code>(cons-atom &lt;head&gt; &lt;tail&gt;)</code> returns an expression where the first sub-atom is <code>&lt;head&gt;</code> and others are copied from <code>&lt;tail&gt;</code>.</p>"},{"location":"minimal-metta/#collapse-bind","title":"collapse-bind","text":"<p><code>collapse-bind</code> has the signature <code>(collapse-bind &lt;atom&gt;)</code>. It evaluates the <code>&lt;atom&gt;</code> and returns an expression which contains all alternative evaluations in a form <code>(&lt;atom&gt; &lt;bindings&gt;)</code>. <code>&lt;bindings&gt;</code> are represented in a form of a grounded atom.</p> <p><code>collapse-bind</code> is part of the inference control provided by a minimal MeTTa interpreter. For example it can be used to get all alternative interpretations of the atom and filter out ones which led to errors.</p> <p>Name <code>collapse-bind</code> is temporary and chosen to eliminate conflict with <code>collapse</code> which is part of the standard library.</p>"},{"location":"minimal-metta/#superpose-bind","title":"superpose-bind","text":"<p><code>superpose-bind</code> has the signature <code>(superpose-bind ((&lt;atom&gt; &lt;bindings&gt;) ...))</code>. It puts list of the results into the interpreter plan each pair as a separate alternative.</p> <p><code>superpose-bind</code> is an operation which is complement to the <code>collapse-bind</code>. <code>superpose-bind</code> takes the result of the <code>collapse-bind</code> as an input. Thus user can collect the list of alternatives using <code>collapse-bind</code> filter them and return filtered items to the plan using <code>superpose-bind</code>.</p>"},{"location":"minimal-metta/#scope-of-a-variable","title":"Scope of a variable","text":"<p>Each separately evaluated expression is a variable scope, and therefore variable names are treated as unique inside an expression. reason is that the whole expression is a variable scope. For example one can write the expression <code>(chain (unify $parent Bob () ()) $_ $parent)</code>. And value of the <code>$parent</code> is returned correctly.</p> <p>When a variable is passed as an argument to a function call and matched by a value then the value is assigned to the variable. If variable passed as an actual argument is matched by a formal argument variable then it is referenced by the formal argument variable. In this case the actual argument variable can receive a value outsides of its scope.</p> <p>For example the following code (written using MeTTa runner syntax) returns <code>B</code>: <pre><code>(= (foo $b) (function (chain (unify B $b () ()) $_ (return ()))))\n!(chain (eval (foo $a)) $_ $a)\n</code></pre></p> <p>If two separate expressions in the space have a variable with the same name, but the variables reside in independent scopes, then the variables are different. Consider the following example: <pre><code>(= (foo) (function (chain (unify A $a () ()) $_ (return ()))))\n!(chain (eval (foo)) $_ $a)\n</code></pre> Here the value will not be assigned to the <code>$a</code> from the caller expression because each of the two variables has a different scope and they do not reference each other.</p>"},{"location":"minimal-metta/#examples","title":"Examples","text":"<p>Examples of the programs written using minimal MeTTa interpreter:</p> <p>Recursive switch implementation:</p> <pre><code>(= (switch $atom $cases)\n  (function\n    (chain (decons-atom $cases) $list\n      (chain (eval (switch-internal $atom $list)) $res\n        (unify $res NotReducible (return Empty) (return $res)) ))))\n\n(= (switch-internal $atom (($pattern $template) $tail))\n  (function\n    (unify $atom $pattern\n      (return $template)\n      (chain (eval (switch $atom $tail)) $ret (return $ret)) )))\n</code></pre> <p>Evaluate atom in a loop until result is calculated:</p> <pre><code>(= (subst $atom $var $templ)\n  (unify $atom $var $templ\n    (Error (subst $atom $var $templ)\n      \\\"subst expects a variable as a second argument\\\") ))\n\n(= (reduce $atom $var $templ)\n  (chain (eval $atom) $res\n    (unify $res Empty\n    Empty\n    (unify $res (Error $a $m)\n      (Error $a $m)\n      (unify $res NotReducible\n        (eval (subst $atom $var $templ))\n        (eval (reduce $res $var $templ)) )))))\n</code></pre>"},{"location":"minimal-metta/#properties","title":"Properties","text":""},{"location":"minimal-metta/#turing-completeness","title":"Turing completeness","text":"<p>The following program implements a Turing machine using the minimal MeTTa instruction set (the full code of the example can be found here):</p> <pre><code>(= (tm $rule $state $tape)\n  (function (eval (tm-body $rule $state $tape))) )\n\n(= (tm-body $rule $state $tape)\n  (unify $state HALT\n    (return $tape)\n    (chain (eval (read $tape)) $char\n      (chain (eval ($rule $state $char)) $res\n        (unify $res ($next-state $next-char $dir)\n          (chain (eval (move $tape $next-char $dir)) $next-tape\n            (eval (tm-body $rule $next-state $next-tape)) )\n          (return (Error (tm-body $rule $state $tape) \\\"Incorrect state\\\")) )))))\n\n(= (read ($head $hole $tail)) $hole)\n\n(= (move ($head $hole $tail) $char N) ($head $char $tail))\n(= (move ($head $hole $tail) $char L) (function\n  (chain (cons-atom $char $head) $next-head\n    (chain (decons-atom $tail) $list\n      (unify $list ($next-hole $next-tail)\n        (return ($next-head $next-hole $next-tail))\n        (return ($next-head 0 ())) )))))\n(= (move ($head $hole $tail) $char R) (function\n  (chain (cons-atom $char $tail) $next-tail\n    (chain (decons-atom $head) $list\n      (unify $list ($next-hole $next-head)\n        (return ($next-head $next-hole $next-tail))\n        (return (() 0 $next-tail)) )))))\n</code></pre>"},{"location":"minimal-metta/#comparison-with-metta-operational-semantics","title":"Comparison with MeTTa Operational Semantics","text":"<p>One difference from MOPS [1] is that the minimal instruction set allows relatively easy write deterministic programs and non-determinism is injected only via matching and evaluation. <code>Query</code> and <code>Chain</code> from MOPS are similar to <code>eval</code>. <code>Transform</code> is similar to <code>unify</code>. <code>chain</code> has no analogue in MOPS. <code>cons-atom</code>/<code>decons-atom</code> to some extent are analogues of <code>AtomAdd</code>/<code>AtomRemove</code> in a sense that they can be used to change the state.</p>"},{"location":"minimal-metta/#partial-and-complete-functions","title":"Partial and complete functions","text":"<p>Each instruction in a minimal instruction set is a total function. Nevertheless <code>Empty</code> allows defining partial functions in MeTTa. For example partial <code>if</code> can be defined as follows: <pre><code>(= (if $condition $then) (unify $condition True $then Empty))\n</code></pre></p>"},{"location":"minimal-metta/#eval-or-return","title":"eval or return","text":"<p>Using <code>eval</code> to designate evaluation of the atom seems too verbose. But we need to give a programmer some way to designate whether the atom should be evaluated or not. <code>eval</code> marks atoms which should be evaluated. As an alternative to this solution we could mark atoms which should not be evaluated.</p> <p>Another related issue is that we need ability to make complex evaluations before making a substitution inside <code>chain</code>. For example <code>(chain (eval (foo a)) $x $x)</code> should be able to make and fully evaluate the call of the <code>foo</code> function before inserting the result into the template. We need to define the criteria which specifies when the nested operation is finished and what is the result. Also we need to be able represent evaluation loop inside the code.</p> <p>First version of the minimal interpreter continued the evaluation of the first argument of the <code>chain</code> until it becomes a non-minimal MeTTa instruction. But this approach is too verbose. If it is needed to chain some minimal MeTTa instruction without evaluation then such instruction should be wrapped into a non-minimal MeTTa expression and unwrapped after the substitution is made.</p> <pre><code>  (chain (quote (eval (foo))) $x\n    (unify $x (quote $y)\n      $y\n      (Error $x \"quote expression expected\") ))\n</code></pre> <p>To allow <code>chain</code> relying on the returned result of the first argument the <code>function/return</code> operations are introduced. When user needs to run a complex evaluation inside chain he may wrap it into the <code>function</code> operation. <code>function</code> evaluates its argument in a loop until <code>(return &lt;atom&gt;)</code> is returned. Then it returns the <code>&lt;atom&gt;</code> as a result. If one need to make a substitution it is possible using:</p> <pre><code>  (chain (function (return &lt;atom&gt;)) &lt;var&gt; &lt;templ&gt;)\n</code></pre> <p>One more option is to make <code>chain</code> (and other atoms which can have nested evaluation loops) recognize <code>return</code>. In such case the evaluation loop is executed by the <code>chain</code> itself and <code>function</code> instruction is not needed. Substitution gets the simpler form:</p> <pre><code>  (chain (return &lt;atom&gt;) &lt;var&gt; &lt;templ&gt;)\n</code></pre> <p>The downside of this approach is that loop represented by the outer operation <code>chain</code> and end of the loop represented by <code>return</code> are written in different contexts. Thus programmer should keep in mind that when some function is used from <code>chain</code> and it is not just a equality substitution then <code>return</code> should be used on each exit path while nothing in code of function points to this. Using <code>function</code> operation allows dividing functions on two classes: - functions which evaluate result in a loop and have to use <code>return</code>; - functions which just replace the calling expression by their bodies.</p>"},{"location":"minimal-metta/#metta-interpreter-written-in-rust","title":"MeTTa interpreter written in Rust","text":"<p>MeTTa interpreter written in minimal MeTTa has poor performance. To fix this the interpreter is rewritten in Rust. Rust implementation can be called using <code>(metta &lt;atom&gt; &lt;type&gt; &lt;space&gt;)</code> operation. To be able represent process of the interpretation as a list of steps and keep ability to control the inference <code>metta</code> doesn't evaluate passed atom till the end but instead analyses the atom and returns the plan written in minimal MeTTa. Plan includes steps written as a Rust functions. These steps are called using <code>(call_native &lt;name&gt; &lt;function&gt; &lt;args&gt;)</code> operation.</p> <p>Both <code>metta</code> and <code>call_native</code> could be written as a grounded operations and be a part of a standard library. But this requires grounded operations to be able returning bindings as a results. Returning bindings as results is a nice to have feature anyway to be able representing any functionality as a grounded atom. But it is not implemented yet.</p>"},{"location":"minimal-metta/#future-work","title":"Future work","text":""},{"location":"minimal-metta/#explicit-atomspace-variable-bindings","title":"Explicit atomspace variable bindings","text":"<p>Current implementation implicitly keeps and applies variable bindings during the process of the interpretation. Explicit bindings are used to implement <code>collapse-bind</code> where they are necessary. Bindings can be easily made explicit everywhere but the value of explicit bindings is not obvious see [discussion in issue</p>"},{"location":"minimal-metta/#290httpsgithubcomtrueagi-iohyperon-experimentalissues290issuecomment-1541314289","title":"290](https://github.com/trueagi-io/hyperon-experimental/issues/290#issuecomment-1541314289).","text":"<p>Making atomspace part of the explicit context could make import semantics more straightforward. In the current implementation of the minimal instruction set it is needed to explicitly pass the atomspace to the interpreter because otherwise grounded <code>get-type</code> function didn't work properly. It also could allow defining <code>eval</code> via <code>unify</code> which minimizes the number of instructions and allows defining <code>eval</code> in a MeTTa program itself. Which in turn allows defining different versions of <code>eval</code> to program different kinds of chaining. Nevertheless defining <code>eval</code> through <code>unify</code> requires rework of the grounded functions interface to allow calling them by executing <code>unify</code> instructions. Which is an interesting direction to follow.</p>"},{"location":"minimal-metta/#special-matching-syntax","title":"Special matching syntax","text":"<p>Sometimes it is convenient to change the semantics of the matching within a pattern. Some real examples are provided below. One possible way to extend matching syntax is embrace atoms by expressions with matching modifier on a first position. For instance <code>(:&lt;mod&gt; &lt;atom&gt;)</code> could apply <code>&lt;mod&gt;</code> rule to match the <code>&lt;atom&gt;</code>. How to eliminate interference of this syntax with symbol atoms used by programmers is an open question.</p>"},{"location":"minimal-metta/#syntax-to-match-atom-by-equality","title":"Syntax to match atom by equality","text":"<p>In many situations we need to check that atom is equal to some symbol. <code>unify</code> doesn't work well in such cases because when checked atom is a variable it is matched with anything (for instance <code>(unify $x Empty then else)</code> returns <code>then</code>). It would be convenient to have a special syntax to match the atom by equality. For instance <code>(unify &lt;atom&gt; (:= Empty) then else)</code> should match <code>&lt;atom&gt;</code> with pattern only when <code>&lt;atom&gt;</code> is <code>Empty</code>.</p>"},{"location":"minimal-metta/#syntax-to-match-part-of-the-expression","title":"Syntax to match part of the expression","text":"<p>We could have a specific syntax which would allow matching part of the expressions. For example such syntax could be used to match head and tail of the expression without using <code>cons-atom</code>/<code>decons-atom</code>. Another example is matching part of the expression with some gap, i.e. <code>(A ... D ...)</code> could match <code>(A B C D E)</code> atom.</p>"},{"location":"minimal-metta/#links","title":"Links","text":"<ol> <li>Lucius Gregory Meredith, Ben Goertzel, Jonathan Warrell, and Adam    Vandervorst. Meta-MeTTa: an operational semantics for MeTTa.    https://raw.githubusercontent.com/leithaus/rho4u/main/ai/mops/mops.pdf</li> </ol>"},{"location":"modules_dev/","title":"MeTTa modules","text":""},{"location":"modules_dev/#metta-modules-rust-python-developer-documentation","title":"MeTTa Modules (Rust / Python Developer Documentation)","text":"<p>TODO: Integrate this documentation within the larger MeTTa Book</p> <p>Modules are implementations of free-standing MeTTa functionality that can be imported into other MeTTa modules or programs.  Modules may be implemented in MeTTa code itself, but they may also include functionality implemented with, or linked from host languages such as Rust, C, or Python.  Modules may include additional files and resources as well.</p> <p>NOTE: Importantly, a module can have sub-module dependencies, aka \"downward\" dependencies, but it cannot have \"upward\" dependencies, ie. dependencies on the client code importing the module.</p>"},{"location":"modules_dev/#what-is-a-module","title":"What is a Module?","text":"<p>Fundamentally a module in a persistent encapsulation of a context within which MeTTa code can run.  Every module has a unique [Space] (and also a [Tokenizer], for now).  For MeTTa code running within the context of a module, the <code>&amp;self</code> token will resolve to the module's space.</p> <p>A loaded module is represented with the [MettaMod] struct.  In addition to a [Space] and a [Tokenizer], a module may also contain a filesystem path to the module's resources, the sub-modules imported by the module, a [ModuleDescriptor] object, and a [PkgInfo] struct, the latter of which are documented in the Package Management section.</p> <p>To execute code in the context of any loaded module, use the [RunnerState::new_with_module] method.</p>"},{"location":"modules_dev/#loading-a-module","title":"Loading a Module","text":"<p>Modules are loaded into a [Metta] runner using one of the module loading methods: [Metta::load_module_direct], [Metta::load_module_at_path], or [RunContext::load_module].  Loaded modules are referred to with a [ModId].</p> <p>Fundamentally, all modules are loaded via a loader object that implements the [ModuleLoader] trait.  Irrespective of the module's original format or host language, a loader object's [ModuleLoader::load] function ultimately loads the module into the runner.</p>"},{"location":"modules_dev/#module-names-name-paths","title":"Module Names &amp; Name Paths","text":"<p>Each loaded module must have a name.  A legal module name is an ascii string, containing only alpha-numeric characters plus <code>_</code> and <code>-</code>.</p> <p>If module loading is initiated through the MeTTa <code>import!</code> operation or the corresponding [RunContext::load_module] API call, then the module name will be used to identify the module to load, following the logic in the Module Name Resolution section.</p> <p>Direct module-loading API calls such as [Metta::load_module_direct], [Metta::load_module_at_path], or [Metta::load_module_alias] all take an explicit module name or name path.</p> <p>Upon loading, the module is subsequently placed into the module name path hierarchy, where <code>top</code> is always the name for the top-module in the runner and the <code>':'</code> character acts as the separator.  An example module name path looks like <code>top:mod1:sub_a</code>, and an example hierarchy is illustrated below.</p> <pre><code>top = 0\n \u251c\u2500corelib = 1\n \u251c\u2500stdlib = 2\n \u251c\u2500mod1 = 3\n \u2502  \u2514\u2500sub_a = 4\n \u2514\u2500mod2 = 5\n    \u2514\u2500sub_b = 6\n</code></pre> <p>In addition, the <code>self</code> token may be used at the beginning of a module name path to refer to the currently running module context.  In the context of the top module, <code>top</code> and <code>self</code> should have an identical meaning.</p> <p>Step-by-step, the MeTTa code: <pre><code>!(import! &amp;self some_module)\n</code></pre> will cause the name <code>some_module</code> to be resolved into a specific module instance; if that module is not yet loaded then it will be, and finally the module will be imported, in totality, into the currently executing module (context).</p> <p></p> <p>NOTE: The same loaded module (with the same ModId) may appear multiple times in the hierarchy, sometimes with different names.  This could be the effect of an \"import as\" operation or making a module alias.</p> <p>NOTE: The same module name may occur in multiple places in the hierarchy, and there is no guaranteed a name will always refer to the same module. However, within a given node of the module name hierarchy, a module name will always be unique.</p>"},{"location":"modules_dev/#importing-a-module","title":"Importing a Module","text":"<p>A module is imported into another module using one of the import methods:  - [MettaMod::import_dependency_as], corresponding to <code>import module as name</code>  - [MettaMod::import_all_from_dependency], corresponding to <code>import * from module</code>  - [MettaMod::import_item_from_dependency_as], corresponding to <code>import item from module as name</code></p> <p>Once imported, a sub-module is accessed via an embedded [Space] atom in the destination module's space, [Tokenizer] entries for accessing the source module's space, tokens, or a combination of the two.</p>"},{"location":"modules_dev/#behavior-wip","title":"Behavior WIP","text":"<p>TODO: The precise semantics of importing (in other words, linking) are still under discussion and development.  Specifically we may wish to provide a mechanism to explicitly declare what is exported from a module (and thus available for import).  This would be similar to the <code>export</code> key words in some languages, or the <code>pub</code> visibility qualifiers in Rust.</p> <p>In addition, some changes will be needed so that [Tokenizer] entries can be imported and accessed between modules.  Currently Tokenizer entries are only imported using the [MettaMod::import_all_from_dependency] method, and the mechanism at work may lead to unreachable Tokenizer entries.</p> <p>Some issues regarding this are: https://github.com/trueagi-io/hyperon-experimental/issues/509 [https://github.com/trueagi-io/hyperon-experimental/issues/510]</p> <p>More discussion on these topics is in the section: \"Importing / Linking\" of the <code>modules_internal_discussion.md</code> file.</p>"},{"location":"modules_dev/#package-management","title":"Package Management","text":"<p>Package Management is the set of features that allow for: - searching for modules across multiple locations (Catalogs) - expressing version requirements and selecting compatible versions - loading modules from files or other locations</p> <p>Modularity is a fundamental and inseparable aspect of the MeTTa runner, but Package Management features could be optional.</p>"},{"location":"modules_dev/#module-file-formats","title":"Module File Formats","text":"<p>Modules may be loaded from files and other file-system-like resources (for example, a github repo) using the objects that implement the [FsModuleFormat] trait.  This trait contains the interface to interpret a file or a directory and instantiate a [ModuleLoader] to load the module(s) contained within.</p> <p>The objects [SingleFileModuleFmt] and [DirModuleFmt] are part of the default environment and are capable of loading MeTTa modules from single <code>.metta</code> files and directories containing a <code>module.metta</code> file respectively.  Additionally, the <code>hyperon</code> Python module contains a [FsModuleFormat] for loading MeTTa modules from Python modules - both stand-alone <code>.py</code> files as well as directories containing an <code>__init__.py</code> file.</p> <p>More information on the individual module file formats is available in the MeTTa usage documentation and MeTTa Python documentation respectively.</p>"},{"location":"modules_dev/#the-pkginfo-structure","title":"The PkgInfo Structure","text":"<p>Each module has an associated [PkgInfo] structure, which provides the module author a place to specify meta-data about the module and express requirements for the module's dependencies.  Additionally a [PkgInfo] can provide explicit loading instructions such as file system paths or github URLs for dependent modules.  The [PkgInfo] structure is the same concept as the Cargo.toml file used in Cargo/Rust.</p> <p>The [PkgInfo] should be initialized inside the module's loader function.  If it is not initialized then default values will be used.</p> <p>The fields of the [PkgInfo] struct are documented in the Rust MeTTa documentation here.</p> <p>TODO: PkgInfo documentation also belongs in user-facing docs. In that section, cover how to specify the pkginfo as a MeTTa structure and/or in a <code>_pkg-info.metta</code> or <code>_pkg-info.json</code> file as opposed to as a Rust struct.</p>"},{"location":"modules_dev/#module-name-resolution","title":"Module Name Resolution","text":"<p>When MeTTa code executes the <code>!(import! &amp;space some_module)</code> operation, the module name needs to be mapped to a loaded or loadable module.  This process occurs according to the logic described by the flowchart below.</p> <p></p> <ol> <li> <p>First the module name is checked against the modules which are already    loaded within the context of the running module.  This ensures the same    instance of a shared dependency will be loaded everywhere.</p> </li> <li> <p>If a loaded module is not available, the [PkgInfo] will be checked for a    corresponding entry.  If an entry specifies a specific location in the file    system or a remote repository, then the module will be loaded from that    location.  Additionally, the [PkgInfo] may specify version requirements for    use by the catalog in locating and selecting an accaptable module.</p> </li> <li> <p>Finally, the Catalogs from the Environment will be queried in priority    order. (See the Catalogs section below)</p> </li> </ol> <p>By default, the built-in search paths / catalogs are:</p> <ol> <li>The module's own <code>resource</code> directory, if it has one</li> <li>The <code>hyperon/exts/</code> directory, if the Hyperon Python module is running</li> <li>The MeTTa config <code>modules</code> directory, at an OS-specific location.</li> </ol> <p>Depending on the host OS, the config directory locations will be: * Linux: ~/.config/metta/ * Windows: ~\\AppData\\Roaming\\TrueAGI\\metta\\config\\ * Mac: ~/Library/Application Support/io.TrueAGI.metta/</p> <p>In the future we may create a centralized module catalog along the lines of <code>PyPI</code> or <code>crates.io</code>.</p>"},{"location":"modules_dev/#catalogs","title":"Catalogs","text":"<p>An object that implements the [ModuleCatalog] trait exposes an interface to locate modules based on name and version constraints, and create [ModuleLoader] objects to retrieve and load those modules.</p> <p>One built-in [ModuleCatalog] object type is the [DirCatalog].  As described in the \"Module File Formats\" section, a [DirCatalog] uses a collection of [FsModuleFormat] objects to export a catalog of modules contained within its associated directory.</p> <p>Additional catalogs may be implemented for other module repository formats or protocols - for example a central package service similar to <code>PyPI</code> or <code>crates.io</code>, as mentioned earlier.</p>"},{"location":"modules_dev/#implementing-a-moduleloader","title":"Implementing a [ModuleLoader]","text":"<p>All modules are ultimately loaded programmatically through the MeTTa API, and it's the role of a [ModuleLoader] to make the necessary API calls.</p> <p>The [ModuleLoader::load] method ultimately sets up the module.  Each module has its own [Space] so the space needs to be created first.  Then the module must be initialized using the [RunContext::init_self_module] method.</p> <p>After <code>init_self_module</code> has run, it is now legal to access the module data stricture using [RunContext::module] or [RunContext::module_mut], as well as enqueuing MeTTa code or additional operations to run.</p> <p>An example <code>load</code> method implementation is here: <pre><code>fn load(&amp;self, context: &amp;mut RunContext, descriptor: ModuleDescriptor) -&gt; Result&lt;(), String&gt; {\n\n    let space = DynSpace::new(GroundingSpace::new());\n    let resource_dir = std::path::PathBuf::from(\"/tmp/test_module_resources\")\n    context.init_self_module(descriptor, space, Some(resource_dir.into()));\n\n    let parser = SExprParser::new(METTA_PROGRAM_TEXT);\n    context.push_parser(Box::new(parser));\n\n    Ok(())\n}\n</code></pre></p>"},{"location":"modules_internal_discussion/","title":"Module Design Discussion - Open Questions","text":""},{"location":"modules_internal_discussion/#overview-what-does-module-mean","title":"Overview: What does Module mean?","text":"<p>When I began this task, I conflated the design-space of modularity with package management, however the two are separate and distinct.  I began the task by designing and implementing a package manager, but the current MeTTa semantics lack the fundamental modularity constructs that are a prerequisite for robust package management.</p> <p>It may seem like a tautology, but I feel it bears repeating that the purpose of modules is modularity.  In other words, isolating the implementation and incidental behaviors of some \"module\" code from other \"client\" code.</p> <p>Definition: A module is unit of functionality that can be loaded into a MeTTa runner and used by other MeTTa code without requiring modification of the module, regardless of the location or the format from which the module was loaded.</p>"},{"location":"modules_internal_discussion/#desiderata","title":"Desiderata","text":"<ul> <li>A module should be able to be loaded and tested independently of client code that might load it</li> <li>A module should express its own sub-module dependencies</li> <li>A module should not rely on the client to import sub-dependencies or configure the environment for the module (\"environment\" used here in a loose sense, not the Environment object)</li> <li>A corollary to the above is that a module should not be affected by things the client does aside from the interactions through the module's interface.  For example, a client shouldn't be able to accidentally break a module's implementation by defining atoms or tokens in the client code. </li> </ul> <p>By analogy, Rust <code>mod</code>s meet these criteria, and C header files do not.  Shared libraries, on the other hand, are modules according to the criteria above.</p>"},{"location":"modules_internal_discussion/#mettamod-struct","title":"MettaMod struct","text":"<p>The [MettaMod] struct essentially takes the place of a \"Loading Runner\" in the prior code base.  The major difference being that the MettaMod continues to exist even after the module loader code has evaluated.  More discussion can be found in the \"What is a Module?\" section of the main module docs.</p>"},{"location":"modules_internal_discussion/#question-topic-1-importing-linking","title":"Question Topic 1: Importing &amp; Linking","text":"<p>To discuss import behavior, we need to discuss 3 distinct cases separately.  The cases are:</p> <ul> <li>Import As <code>import module as name</code></li> <li>Import All (aka import *) <code>import * from module</code></li> <li>Import Item <code>import item from module as name</code></li> </ul> <p>In parallel, a discussion on this topic exists here: https://github.com/trueagi-io/hyperon-experimental/issues/509 although this document presently represents a more thorough treatment of the topic.</p>"},{"location":"modules_internal_discussion/#import-as","title":"Import As","text":"<p>This is probably the most straightforward of the three import behaviors.  Currently the code registers a new Tokenizer entry in the destination module's Tokenizer with the space of sub-module.  This behavior is adequate and does the right thing for allowing the sub-module's space to be accessed within the context of the client module.</p> <p>This is implemented by the [MettaMod::import_dependency_as] method.</p> <p>Outstanding Issue: This implementation doesn't provide any way to access tokenizer entries that are part of the sub-module.</p>"},{"location":"modules_internal_discussion/#import-all","title":"Import All","text":"<p>Conceptually this operation imports the entire contents of a sub-module into the target module.  Another way to think about this is overlaying the space and tokens of the sub-module onto the client module.  In practice, given the behavior of the interpreter, the current implementation is a bit convoluted.</p> <p>Currently the implementation leverages the behavior that a nested Space Grounded Atom will behave as an extension of the Space containing it.</p> <p>The import code makes a deep-copy of the sub-module's space, then strips away space atoms that are associated with dependency's own sub-modules (2<sup>nd</sup> order sub-modules), before finally adding the cloned sub-space as a grounded atom into the client's space.</p> <p>After that, the implementation imports the all of the new secondary transitive dependencies into the client, and finally it merges all tokenizer entries from the sub-module into the client.</p> <p>This \"import all\" behavior is implemented by the [MettaMod::import_all_from_dependency] method.</p>"},{"location":"modules_internal_discussion/#this-current-implementation-some-issues","title":"This current implementation some issues","text":"<ul> <li> <p>Inefficient Space Clone: Deep-cloning the sub-modules's space on every import is costly, considering it should be possible to import functionality by reference.  This potentially leads to many copies of the same sub-modules in memory and defeats one of the benefits of modularity.  One potential way to fix this it to create a [Space] implementation that I'll call <code>ModuleSpace</code>, which wraps the module's <code>&amp;self</code> space regardless of its underlying type.  <code>ModuleSpace</code> holds references to the sub-modules' individual spaces and controls which how the sub-module spaces will be combined.  I have not yet tried to implement this so I don't know what other problems may come up.</p> </li> <li> <p>Private Sub-Modules shouldn't be lifted: All transitive dependency sub-modules are lifted into the client scope, including private sub-modules.  Assuming we have a fix for the above, addressing this point may be as simple as not stripping and lifting private sub-modules, so that may be an easy fix.</p> </li> <li> <p>Redundant Tokenizer Entries: Currently Tokenizer entries imported from sub-modules may be inaccessible because they are superseded by existing entries in the module's Tokenizer.  A partial solution here might be to implement something like a \"Layered Tokenizer\" as described here: https://github.com/trueagi-io/hyperon-experimental/issues/408#issuecomment-1839196513</p> </li> </ul>"},{"location":"modules_internal_discussion/#explicit-exports-or-visibility-qualifiers","title":"Explicit exports or visibility qualifiers","text":"<p>Most languages that support modularity allow a module to declare a subset of the objects as available for export.  Sometimes this is done with visibility qualifiers, (for example <code>pub</code> in Rust), or in other situations this is accomplished via the ABI and header files, as with shared libraries imported in C &amp; C++.</p> <p>Explicit control over exports would solve the problem of duplicated or conflicting transitive imports of sub-modules, because private sub-modules would not be exported.</p>"},{"location":"modules_internal_discussion/#import-item","title":"Import Item","text":"<p>The <code>import item from module [as name]</code> is implemented with the [MettaMod::import_item_from_dependency_as] method.  However there is no <code>stdlib</code> operation that calls it, so it's currently inaccessible from MeTTa code.</p>"},{"location":"modules_internal_discussion/#tokenizer-entries-dont-always-have-names-to-import","title":"Tokenizer entries don't always have names to import","text":"<p>When we want to import a tokenizer entry from a sub-module, we need a name to refer to it.  But currently Tokenizer entries don't have names.  By itself, this problem is easy to address, but we should consider our choice of solution in light of the other choices we need to make for the MeTTa language.</p> <p>This issue is discussed in more detail here: https://github.com/trueagi-io/hyperon-experimental/issues/510</p> <p>One solution, as described on github, is to require Tokenizer entries to have corresponding items in the module's Space.</p>"},{"location":"modules_internal_discussion/#question-topic-2-sub-module-version-resolution-discussion","title":"Question Topic 2: Sub-Module Version Resolution Discussion","text":""},{"location":"modules_internal_discussion/#background","title":"Background","text":"<p>There are two desiderata which are at odds with each other and must be balanced:</p> <ul> <li> <p>Implementation sub-modules: We want sub-module dependencies not to interfere with each other as much as is possible.  For example, ModA should be able to import ModC, and ModB should be able to import a different version of ModC.  This should be allowed as long as both ModA and ModB use ModC within their internal implementation.  Within this document I will call this pattern an \"Implementation\" sub-module.</p> </li> <li> <p>Interface sub-modules If ModA imports ModC and uses functionality from ModC in its interface, then ClientMod will transitively import ModC when it imports ModA.  In effect this means the dependent sub-module's version becomes part of the module's interface.  Therefore, within this document, I will call this an \"Interface\" sub-module.  If ClientMod imports ModA and ModB, which both import ModC as an Interface sub-module, then the version (instance) of ModC must be the same between ModA and ModB.</p> </li> </ul>"},{"location":"modules_internal_discussion/#sub-module-set-satisfiability","title":"Sub-Module set satisfiability","text":"<p>The versions of transitive Interface sub-modules must be reconciled such that a given client imports exactly one version of each dependent sub-module, even when that sub-module is shared between two or more other dependents.  Finding the compatible module versions is a flavor of the Satisfiability Problem.</p> <p>Reasonably sophisticated package managers such as Cargo include a Satisfiability Solver, which will attempt to find a set of sub-module versions that satisfy the requirements for each client that imports each dependency.  I believe we will ultimately want to add a solver to MeTTa too, someday.  However this doesn't currently exist.  MeTTa as a language is well-suited to implementing a solver.</p> <p>Until we add a solver to the MeTTa Package Manager, the module resolution logic will progress sequentially with no ability to backtrack.  This means that we will need to rely on each module's author to manually determine a workable set of sub-module versions for themselves.  Then the specific (or narrower) version requirements can be added to the module's [PkgInfo].</p> <p>Current State of the Code: Version requirements for sub-modules are not yet implemented so this is a non-issue in the present implementation.</p>"},{"location":"modules_internal_discussion/#module-namespace-scope","title":"Module Namespace Scope","text":"<p>When a module is loaded, the module's name may be registered in the runner's module namespace, so that subsequent attempts to resolve the same module name elsewhere in the runner will return the already-loaded module as opposed to causing a new instance of the module to be loaded.</p> <p>The question here is which behavior we want for the module namespace:</p> <ul> <li> <p>Proposal A: Global Scope:  This means every module is effectively an Interface Module, and only one version of a given module can be loaded in the same runner.  This is the approach taken by both Cargo and Python (but for different reasons in each case), and a number of other package managers.  However, the reasons that have driven other package managers towards this design don't necessarily apply to MeTTa, and I believe we can support private Implementation sub-modules.  Therefore I do not advocate for this design.</p> </li> <li> <p>Proposal B: Conservative Hierarchical Scope:  Within this design, each module name only propagates upwards to its client if it needs to, or is explicitly re-exported.  This means that Interface modules must be exported or marked some other way.  It also complicates the Sat Solver (see above) as it would need to operate over multiple sets with some partial intersections between them.  I believe this is probably the \"right\" design, but also the most work to implement.</p> </li> <li> <p>Proposal C: 2-Layer \"Public vs. Private\" Scope:  This is the way the code currently works.  Each imported module may be \"Public\", in which case it is available by name to all other modules in the runner, or it may be \"Private\", in which case it is loaded only for the client module that resolves it.  This is a \"poor man's\" version of Proposal B.  However, it has many problematic edge cases so I would prefer to implement Proposal B.</p> </li> </ul> <p>For either Proposal B or C, we probably want to add some form of linting / checking, so users don't accidentally shoot themselves in the foot by exporting items that depend on private (Implementation) sub-modules.  In other words, public interfaces must not include non-public objects.</p> <p>UPDATE: A version of B is now implemented in the code, with the caveat that nothing is private (visibility constructs don't exist for MeTTa modules at all) but sub-modules can be contained within the namespace of their respective parents.</p>"},{"location":"modules_internal_discussion/#remaining-implementation-work","title":"Remaining implementation work","text":"<p>LP-TODO, search code for remaining TODO comments and collect them here so I can prioritize remaining work</p>"},{"location":"modules_internal_discussion/#moduledescriptor-should-be-part-of-pkg_management-features","title":"ModuleDescriptor should be part of pkg_management features","text":"<p>However, we still need a way to globally (within a runner) disambiguate a module.  Currently that's done with a ModuleDescriptor.  My proposal is to implement the hierarchical module name-space.  It's pretty clear that's the direction we want to go, as several open-issues are pointing that way.</p> <p>Then the loaded module table will use full module path instead of ModuleDescriptor, and ModuleDescriptor will be only for modules in a catalog that are not yet loaded.</p>"},{"location":"modules_internal_discussion/#try-stripping-but-not-lifting-private-transitive-imports-in-import_all","title":"Try stripping but not lifting private transitive imports in <code>import_all</code>","text":"<p>In response to the \"Private Sub-Modules shouldn't be lifted\" section, in a discussino with Vitaly I realized perhaps all of the necessary interfaces to transitive sub-modules might be acomplished within the sub-module's space.  So therefore we may be able to get away with stripping but not lifting the private dependencies.</p>"},{"location":"modules_internal_discussion/#catalog-for-all-python-modules","title":"Catalog for All Python modules","text":"<p>Need to implement a ModuleCatalog that publishes all Python modules as MeTTa modules.  This will achieve parity with the current implementation and re-enable the practice of using <code>pip</code> to install MeTTa modules.  Additionally, we may want to support hierarchical module path imports, so that the MeTTa import operation is able to traverse the python module hierarchy to load and import nested Python modules.</p>"},{"location":"modules_internal_discussion/#atom-serde-serde-format-to-encode-any-structured-data-into-atoms","title":"\"atom-serde\", serde format to encode any structured data into atoms","text":"<p>This relates to package management because we want to represent a PkgInfo structure as atoms within MeTTa code.  One reusable appraoch to this is to make a serde format that targets atoms.  This can then be leveraged for many API structures such as the parse tree, etc.</p> <p>There is a discussion on the topic here: https://github.com/trueagi-io/hyperon-experimental/issues/455</p> <p>Nil's work here https://github.com/trueagi-io/protobuf-metta and more generally this thread https://chat.singularitynet.io/chat/pl/u8u9jzrnmp85d8ounmpbmjukyc has raised the idea that we pursue a format that relies on a structure definition that uses the MeTTa type-system, rather than trying to create a self-describing format.</p>"},{"location":"modules_internal_discussion/#circular-import-testing-guard-rails","title":"Circular-import testing &amp; guard-rails","text":"<p>I need to make sure the right things happen when circular loading / imports are attempted.  More dicussion here: https://github.com/trueagi-io/hyperon-experimental/pull/580#discussion_r1491178245</p>"},{"location":"generated/catalog/","title":"Module catalog","text":""},{"location":"generated/catalog/#catalog-clear","title":"catalog-clear!","text":"<p>Type <code>(-&gt; Symbol (-&gt;))</code> Description Clears the contents of all managed catalogs Parameters <code>Symbol</code> - Name of the catalog to clear or \"all\" to clear all Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/catalog/#catalog-list","title":"catalog-list!","text":"<p>Type <code>(-&gt; Symbol (-&gt;))</code> Description Lists contents of all module catalogs that support the \"list\" method Parameters <code>Symbol</code> - Name of the catalog to list or \"all\" to list all available Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/catalog/#catalog-update","title":"catalog-update!","text":"<p>Type <code>(-&gt; Symbol (-&gt;))</code> Description Update all contents of all managed catalogs to the latest version of all modules Parameters <code>Symbol</code> - Name of the catalog to update or \"all\" to update all Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/","title":"Standard library","text":""},{"location":"generated/corelib/#_1","title":"%","text":"<p>Type <code>(-&gt; Number Number Number)</code> Description Modulo operator. It returns remainder of dividing first argument by second argument Parameters <code>Number</code> - Dividend <code>Number</code> - Divisor Returns <code>Number</code> Remainder</p>"},{"location":"generated/corelib/#kind-atom","title":"(@kind atom)","text":"<p>Type <code>DocKindAtom</code> Description Used for documentation purposes. Shows type of entity to be documented. (@kind atom) in this case## (@kind function) Type <code>DocKindFunction</code> Description Used for documentation purposes. Shows type of entity to be documented. (@kind function) in this case## * Type <code>(-&gt; Number Number Number)</code> Description Multiplies two numbers Parameters <code>Number</code> - Multiplier <code>Number</code> - Multiplicand Returns <code>Number</code> Product</p>"},{"location":"generated/corelib/#_2","title":"+","text":"<p>Type <code>(-&gt; Number Number Number)</code> Description Sums two numbers Parameters <code>Number</code> - Addend <code>Number</code> - Augend Returns <code>Number</code> Sum</p>"},{"location":"generated/corelib/#-","title":"-","text":"<p>Type <code>(-&gt; Number Number Number)</code> Description Subtracts second argument from first one Parameters <code>Number</code> - Minuend <code>Number</code> - Deductible Returns <code>Number</code> Difference</p>"},{"location":"generated/corelib/#_3","title":"/","text":"<p>Type <code>(-&gt; Number Number Number)</code> Description Divides first argument by second one Parameters <code>Number</code> - Dividend <code>Number</code> - Divisor Returns <code>Number</code> Fraction</p>"},{"location":"generated/corelib/#_4","title":"&lt;","text":"<p>Type <code>(-&gt; Number Number Bool)</code> Description Less than. Checks if first argument is less than second one Parameters <code>Number</code> - First number <code>Number</code> - Second number Returns <code>Bool</code> True if first argument is less than second, False - otherwise</p>"},{"location":"generated/corelib/#_5","title":"&lt;=","text":"<p>Type <code>(-&gt; Number Number Bool)</code> Description Less than or equal. Checks if first argument is less than or equal to second one Parameters <code>Number</code> - First number <code>Number</code> - Second number Returns <code>Bool</code> True if first argument is less than or equal to second, False - otherwise</p>"},{"location":"generated/corelib/#_6","title":"=","text":"<p>Type <code>(-&gt; $t#850654 $t#850654 %Undefined%)</code> Description A symbol used to define reduction rules for expressions. Parameters <code>$type#855013</code> - Pattern to be matched against expression to be reduced <code>$type#855781</code> - Result of reduction or transformation of the first pattern Returns <code>%Undefined%</code> Not reduced itself unless custom equalities over equalities are added</p>"},{"location":"generated/corelib/#_7","title":"==","text":"<p>Type <code>(-&gt; $t#36001 $t#36001 Bool)</code> Description Checks equality for two arguments of the same type Parameters <code>$type#40355</code> - First argument <code>$t#36001</code> - Second argument Returns <code>Bool</code> Returns True if two arguments are equal, False - otherwise. If arguments are of different type function returns Error currently</p>"},{"location":"generated/corelib/#alpha","title":"=alpha","text":"<p>Type <code>(-&gt; Atom Atom Bool)</code> Description Checks alpha equality of two expressions Parameters <code>Atom</code> - First expression <code>Atom</code> - Second expression Returns <code>Bool</code> True if both expressions are alpha equal, False - otherwise</p>"},{"location":"generated/corelib/#_8","title":"&gt;","text":"<p>Type <code>(-&gt; Number Number Bool)</code> Description Greater than. Checks if first argument is greater than second one Parameters <code>Number</code> - First number <code>Number</code> - Second number Returns <code>Bool</code> True if first argument is greater than second, False - otherwise</p>"},{"location":"generated/corelib/#_9","title":"&gt;=","text":"<p>Type <code>(-&gt; Number Number Bool)</code> Description Greater than or equal. Checks if first argument is greater than or equal to second one Parameters <code>Number</code> - First number <code>Number</code> - Second number Returns <code>Bool</code> True if first argument is greater than or equal to second, False - otherwise</p>"},{"location":"generated/corelib/#desc","title":"@desc","text":"<p>Type <code>(-&gt; String DocDescription)</code> Description Used for documentation purposes. Description of function starts with @desc as a part of @doc Parameters <code>String</code> - String containing function description Returns <code>DocDescription</code> Function description</p>"},{"location":"generated/corelib/#doc","title":"@doc","text":"<p>Type <code>(-&gt; Atom DocDescription DocParameters DocReturnInformal DocInformal)</code> Description Used for documentation purposes. Function documentation starts with @doc Parameters <code>Atom</code> - Function name <code>DocDescription</code> - Function description. Starts with @desc <code>DocParameters</code> - (Optional) parameters description starting with @params which should contain one or more @param symbols <code>DocReturnInformal</code> - (Optional) description of what function will return. Starts with @return Returns <code>DocInformal</code> Function documentation using @doc-formal</p>"},{"location":"generated/corelib/#doc-formal","title":"@doc-formal","text":"<p>Type <code>(-&gt; DocItem DocKindFunction DocType DocDescription DocParameters DocReturn DocFormal)</code> Description Used for documentation purposes. get-doc returns documentation starting with @doc-formal symbol. @doc-formal contains 6 or 4 parameters depending on the entity being described (functions being described using 6 parameters, atoms - 4 parameters) Parameters <code>DocItem</code> - Function/Atom name for which documentation is to be displayed. Format (@item name) <code>DocKindFunction</code> - Contains (@kind function) or (@kind atom) depends on entity which documentation is displayed <code>DocType</code> - Contains type notation of function/atom <code>DocDescription</code> - Function/atom description <code>DocParameters</code> - (Functions only). Description of function parameters <code>DocReturn</code> - (Functions only). Description of function's return value Returns <code>DocFormal</code> Expression containing full documentation on function</p>"},{"location":"generated/corelib/#item","title":"@item","text":"<p>Type <code>(-&gt; Atom DocItem)</code> Description Used for documentation purposes. Converts atom/function's name to DocItem Parameters <code>Atom</code> - Atom/Function name to be documented Returns <code>DocItem</code> (@item Atom) entity</p>"},{"location":"generated/corelib/#param","title":"@param","text":"<p>Type <code>(-&gt; DocType DocDescription DocParameter)</code> Description Used for documentation purposes. Description of function parameter starts with @param as a part of @params which is a part of @doc Parameters <code>DocType</code> - String containing parameter description Returns <code>DocDescription</code> Parameter description</p>"},{"location":"generated/corelib/#param_1","title":"@param","text":"<p>Type <code>(-&gt; String DocParameterInformal)</code> Description Used for documentation purposes. Description of function parameter starts with @param as a part of @params which is a part of @doc Parameters <code>String</code> - String containing parameter description Returns <code>DocParameterInformal</code> Parameter description</p>"},{"location":"generated/corelib/#params","title":"@params","text":"<p>Type <code>(-&gt; Expression DocParameters)</code> Description Used for function documentation purposes. Contains several @param entities with description of each @param Parameters <code>Expression</code> - Several (@param ...) entities Returns <code>DocParameters</code> DocParameters containing description of all parameters of function in form of (@params ((@param ...) (@param ...) ...))</p>"},{"location":"generated/corelib/#return","title":"@return","text":"<p>Type <code>(-&gt; DocType DocDescription DocReturn)</code> Description Used for documentation purposes. Description of function return value starts with @return as a part of @doc Parameters <code>DocType</code> - String containing return value description Returns <code>DocDescription</code> Return value description</p>"},{"location":"generated/corelib/#return_1","title":"@return","text":"<p>Type <code>(-&gt; String DocReturnInformal)</code> Description Used for documentation purposes. Description of function return value starts with @return as a part of @doc Parameters <code>String</code> - String containing return value description Returns <code>DocReturnInformal</code> Return value description</p>"},{"location":"generated/corelib/#type","title":"@type","text":"<p>Type <code>(-&gt; Type DocType)</code> Description Used for documentation purposes. Converts atom/function's type to DocType Parameters <code>Type</code> - Atom/Function type to be documented Returns <code>DocType</code> (@type Type) entity</p>"},{"location":"generated/corelib/#badargtype","title":"BadArgType","text":"<p>Type <code>(-&gt; Number Type Type ErrorDescription)</code> Description BadArgType error constructor Parameters <code>Number</code> - Index of atom in expression which produced this error <code>Type</code> - Expected type <code>Type</code> - Actual type Returns <code>ErrorDescription</code> Instance of the BadArgType error atom</p>"},{"location":"generated/corelib/#badtype","title":"BadType","text":"<p>Type <code>(-&gt; Type Type ErrorDescription)</code> Description BadType error constructor Parameters <code>Type</code> - Expected type <code>Type</code> - Actual type Returns <code>ErrorDescription</code> Instance of the BadType error atom</p>"},{"location":"generated/corelib/#error","title":"Error","text":"<p>Type <code>(-&gt; Atom Atom ErrorType)</code> Description Error constructor Parameters <code>Atom</code> - Atom which contains error <code>Atom</code> - Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments Returns <code>ErrorType</code> Instance of the error atom</p>"},{"location":"generated/corelib/#errortype","title":"ErrorType","text":"<p>Type <code>Type</code> Description Type of the atom which contains error## SpaceType Type <code>Type</code> Description Type of the atom which contains space## _collapse-add-next-atom-from-collapse-bind-result Type <code>(-&gt; Expression Expression Atom)</code> Description Adds atom from collapse-bind result to the passed list Parameters <code>Expression</code> - List to add an atom into <code>Expression</code> - collapse-bind result to extract atom from, should be a pair of atom and bindings Returns <code>Atom</code> List with new atom as a head</p>"},{"location":"generated/corelib/#abs-math","title":"abs-math","text":"<p>Type <code>(-&gt; Number Number)</code> Description Returns absolute value of input number (first argument) Parameters <code>Number</code> - Input number Returns <code>Number</code> Absolute value</p>"},{"location":"generated/corelib/#acos-math","title":"acos-math","text":"<p>Type <code>(-&gt; Number Number)</code> Description Returns result of the arccosine function for an input value (first argument) Parameters <code>Number</code> - Float number Returns <code>Number</code> Result of the arccosine function</p>"},{"location":"generated/corelib/#add-atom","title":"add-atom","text":"<p>Type <code>(-&gt; SpaceType Atom (-&gt;))</code> Description Adds atom into the atomspace without reducing it Parameters <code>SpaceType</code> - Atomspace to add atom into <code>Atom</code> - Atom to add Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#add-atoms","title":"add-atoms","text":"<p>Type <code>(-&gt; SpaceType Expression (-&gt;))</code> Description Function takes space and expression and adds atoms in Expression into given space without reducing them Parameters <code>SpaceType</code> - Space <code>Expression</code> - Expression Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#add-reduct","title":"add-reduct","text":"<p>Type <code>(-&gt; SpaceType %Undefined% (-&gt;))</code> Description Reduces atom (second argument) and adds it into the atomspace (first argument) Parameters <code>SpaceType</code> - Atomspace to add atom into <code>%Undefined%</code> - Atom to add Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#add-reducts","title":"add-reducts","text":"<p>Type <code>(-&gt; SpaceType %Undefined% (-&gt;))</code> Description Function takes space and expression, evaluates atoms in it and adds them into given space Parameters <code>SpaceType</code> - Space <code>%Undefined%</code> - Expression Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#and","title":"and","text":"<p>Type <code>(-&gt; Bool Bool Bool)</code> Description Logical conjunction of two arguments Parameters <code>Bool</code> - First argument <code>Bool</code> - Second argument Returns <code>Bool</code> Returns True if both arguments are True, False - otherwise</p>"},{"location":"generated/corelib/#asin-math","title":"asin-math","text":"<p>Type <code>(-&gt; Number Number)</code> Description Returns result of the arcsine function for an input value (first argument) Parameters <code>Number</code> - Float number Returns <code>Number</code> Result of the arcsine function</p>"},{"location":"generated/corelib/#assertalphaequal","title":"assertAlphaEqual","text":"<p>Type <code>(-&gt; Atom Atom (-&gt;))</code> Description Compares (sets of) results of evaluation of two expressions using alpha equality Parameters <code>Atom</code> - First expression <code>Atom</code> - Second expression Returns <code>(-&gt;)</code> Unit atom if both expressions after evaluation are alpha equal, error - otherwise</p>"},{"location":"generated/corelib/#assertalphaequalmsg","title":"assertAlphaEqualMsg","text":"<p>Type <code>(-&gt; Atom Atom Atom (-&gt;))</code> Description Compares (sets of) results of evaluation of two expressions using alpha equality Parameters <code>Atom</code> - First expression <code>Atom</code> - Second expression <code>Atom</code> - Message to return on assert failure Returns <code>(-&gt;)</code> Unit atom if both expressions after evaluation are alpha equal, input message - otherwise</p>"},{"location":"generated/corelib/#assertalphaequaltoresult","title":"assertAlphaEqualToResult","text":"<p>Type <code>(-&gt; Atom Atom (-&gt;))</code> Description Same as assertAlphaEqual but it doesn't evaluate second argument. Second argument is considered as a set of values of the first argument's evaluation Parameters <code>Atom</code> - First expression (it will be evaluated) <code>Atom</code> - Second expression (it won't be evaluated) Returns <code>(-&gt;)</code> Unit atom if both expressions after evaluation of the first argument are alpha equal, error - otherwise</p>"},{"location":"generated/corelib/#assertalphaequaltoresultmsg","title":"assertAlphaEqualToResultMsg","text":"<p>Type <code>(-&gt; Atom Atom Atom (-&gt;))</code> Description Same as assertAlphaEqualMsg but it doesn't evaluate second argument. Second argument is considered as a set of values of the first argument's evaluation Parameters <code>Atom</code> - First expression (it will be evaluated) <code>Atom</code> - Second expression (it won't be evaluated) <code>Atom</code> - Message to return on assert failure Returns <code>(-&gt;)</code> Unit atom if both expressions after evaluation of the first argument are alpha equal, input message - otherwise</p>"},{"location":"generated/corelib/#assertequal","title":"assertEqual","text":"<p>Type <code>(-&gt; Atom Atom (-&gt;))</code> Description Compares (sets of) results of evaluation of two expressions Parameters <code>Atom</code> - First expression <code>Atom</code> - Second expression Returns <code>(-&gt;)</code> Unit atom if both expressions after evaluation are equal, error - otherwise</p>"},{"location":"generated/corelib/#assertequalmsg","title":"assertEqualMsg","text":"<p>Type <code>(-&gt; Atom Atom Atom (-&gt;))</code> Description Compares (sets of) results of evaluation of two expressions Parameters <code>Atom</code> - First expression <code>Atom</code> - Second expression <code>Atom</code> - Message to return on assert failure Returns <code>(-&gt;)</code> Unit atom if both expressions after evaluation are equal, input message - otherwise</p>"},{"location":"generated/corelib/#assertequaltoresult","title":"assertEqualToResult","text":"<p>Type <code>(-&gt; Atom Atom (-&gt;))</code> Description Same as assertEqual but it doesn't evaluate second argument. Second argument is considered as a set of values of the first argument's evaluation Parameters <code>Atom</code> - First expression (it will be evaluated) <code>Atom</code> - Second expression containing the expected evaluation results (it won't be evaluated) Returns <code>(-&gt;)</code> Unit atom if both expressions after evaluation of the first argument are equal, error - otherwise</p>"},{"location":"generated/corelib/#assertequaltoresultmsg","title":"assertEqualToResultMsg","text":"<p>Type <code>(-&gt; Atom Atom Atom (-&gt;))</code> Description Same as assertEqualMsg but it doesn't evaluate second argument. Second argument is considered as a set of values of the first argument's evaluation Parameters <code>Atom</code> - First expression (it will be evaluated) <code>Atom</code> - Second expression containing the expected evaluation results (it won't be evaluated) <code>Atom</code> - Message to return on assert failure Returns <code>(-&gt;)</code> Unit atom if both expressions after evaluation of the first argument are equal, input message - otherwise</p>"},{"location":"generated/corelib/#assertincludes","title":"assertIncludes","text":"<p>Type <code>(-&gt; Atom Expression (-&gt;))</code> Description Checks if the content in the second argument is included in the results of the first argument's evaluation Parameters <code>Atom</code> - First expression <code>Expression</code> - Second expression Returns <code>(-&gt;)</code> Unit atom if the second argument is included in the results of the first argument's evaluation, error - otherwise</p>"},{"location":"generated/corelib/#atan-math","title":"atan-math","text":"<p>Type <code>(-&gt; Number Number)</code> Description Returns result of the arctangent function for an input value (first argument) Parameters <code>Number</code> - Float number Returns <code>Number</code> Result of the tangent function</p>"},{"location":"generated/corelib/#atom-subst","title":"atom-subst","text":"<p>Type <code>(-&gt; Atom Variable Atom Atom)</code> Description Substitutes variable passed as a second argument in the third argument by the first argument Parameters <code>Atom</code> - Value to use for replacement <code>Variable</code> - Variable to replace <code>Atom</code> - Template to replace variable by the value Returns <code>Atom</code> Template with substituted variable</p>"},{"location":"generated/corelib/#bind","title":"bind!","text":"<p>Type <code>(-&gt; Symbol %Undefined% (-&gt;))</code> Description Registers a new token which is replaced with an atom during the parsing of the rest of the program Parameters <code>Symbol</code> - Token name <code>%Undefined%</code> - Atom, which is associated with the token after reduction Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#capture","title":"capture","text":"<p>Type <code>(-&gt; Atom Atom)</code> Description Wraps an atom and capture the current space Parameters <code>Atom</code> - Function name which space need to be captured Returns <code>Atom</code> Function</p>"},{"location":"generated/corelib/#car-atom","title":"car-atom","text":"<p>Type <code>(-&gt; Expression %Undefined%)</code> Description Extracts the first atom of an expression as a tuple Parameters <code>Expression</code> - Expression Returns <code>%Undefined%</code> First atom of an expression</p>"},{"location":"generated/corelib/#case","title":"case","text":"<p>Type <code>(-&gt; Atom Expression %Undefined%)</code> Description Subsequently tests multiple pattern-matching conditions (second argument) for the given value (first argument) Parameters <code>Atom</code> - Atom (it will be evaluated) <code>Expression</code> - Tuple of pairs mapping condition patterns to results Returns <code>%Undefined%</code> Result of evaluating of Atom bound to met condition</p>"},{"location":"generated/corelib/#cdr-atom","title":"cdr-atom","text":"<p>Type <code>(-&gt; Expression Expression)</code> Description Extracts the tail of an expression (all except first atom) Parameters <code>Expression</code> - Expression Returns <code>Expression</code> Tail of an expression</p>"},{"location":"generated/corelib/#ceil-math","title":"ceil-math","text":"<p>Type <code>(-&gt; Number Number)</code> Description Returns the smallest integer greater than or equal to the input value (first argument) Parameters <code>Number</code> - Float value Returns <code>Number</code> Integer value greater than or equal to the input</p>"},{"location":"generated/corelib/#chain","title":"chain","text":"<p>Type <code>(-&gt; Atom Variable Atom %Undefined%)</code> Description Evaluates first argument, binds it to the variable (second argument) and then evaluates third argument which contains (or not) mentioned variable Parameters <code>Atom</code> - Atom to be evaluated <code>Variable</code> - Variable <code>Atom</code> - Atom which will be evaluated at the end Returns <code>%Undefined%</code> Result of evaluating third input argument</p>"},{"location":"generated/corelib/#change-state","title":"change-state!","text":"<p>Type <code>(-&gt; (StateMonad $tcso#259338) $tcso#259338 (StateMonad $tcso#259338))</code> Description Changes input state's wrapped atom to another value (second argument). E.g. (change-state! (State 5) 6) -&gt; (State 6) Parameters <code>(StateMonad $tcso#259338)</code> - State created by new-state function <code>$tcso#259338</code> - Atom which will replace wrapped atom in the input state Returns <code>(StateMonad $tcso#259338)</code> State with replaced wrapped atom</p>"},{"location":"generated/corelib/#collapse","title":"collapse","text":"<p>Type <code>(-&gt; Atom Atom)</code> Description Converts a nondeterministic result into a tuple Parameters <code>Atom</code> - Atom which will be evaluated Returns <code>Atom</code> Tuple</p>"},{"location":"generated/corelib/#collapse-bind","title":"collapse-bind","text":"<p>Type <code>(-&gt; Atom Expression)</code> Description Evaluates minimal MeTTa operation (first argument) and returns an expression which contains all alternative evaluations in a form (Atom Bindings). Bindings are represented in a form of a grounded atom. Parameters <code>Atom</code> - Minimal MeTTa operation to be evaluated Returns <code>Expression</code> All alternative evaluations</p>"},{"location":"generated/corelib/#cons-atom","title":"cons-atom","text":"<p>Type <code>(-&gt; Atom Expression Atom)</code> Description Constructs an expression using two arguments Parameters <code>Atom</code> - Head of an expression <code>Expression</code> - Tail of an expression Returns <code>Atom</code> New expression consists of two input arguments</p>"},{"location":"generated/corelib/#context-space","title":"context-space","text":"<p>Type <code>(-&gt; SpaceType)</code> Description Returns the space which is used as a context space in atom evaluation Parameters Returns <code>SpaceType</code> Context space</p>"},{"location":"generated/corelib/#cos-math","title":"cos-math","text":"<p>Type <code>(-&gt; Number Number)</code> Description Returns result of the cosine function for an input value in radians (first argument) Parameters <code>Number</code> - Angle in radians Returns <code>Number</code> Result of the cosine function</p>"},{"location":"generated/corelib/#decons-atom","title":"decons-atom","text":"<p>Type <code>(-&gt; Expression Atom)</code> Description Works as a reverse to cons-atom function. It gets Expression as an input and returns it splitted to head and tail, e.g. (decons-atom (Cons X Nil)) -&gt; (Cons (X Nil)) Parameters <code>Expression</code> - Expression Returns <code>Atom</code> Deconsed expression</p>"},{"location":"generated/corelib/#empty","title":"empty","text":"<p>Type <code>%Undefined%</code> Description Cuts evaluation of the non-deterministic branch and removes it from the result Parameters Returns <code>%Undefined%</code> Nothing</p>"},{"location":"generated/corelib/#eval","title":"eval","text":"<p>Type <code>(-&gt; Atom Atom)</code> Description Evaluates input atom, makes one step of the evaluation Parameters <code>Atom</code> - Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function Returns <code>Atom</code> Result of evaluation</p>"},{"location":"generated/corelib/#evalc","title":"evalc","text":"<p>Type <code>(-&gt; Atom SpaceType Atom)</code> Description Evaluates input atom, makes one step of the evaluation Parameters <code>Atom</code> - Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function <code>SpaceType</code> - Space to evaluate atom in its context Returns <code>Atom</code> Result of evaluation</p>"},{"location":"generated/corelib/#filter-atom","title":"filter-atom","text":"<p>Type <code>(-&gt; Expression Variable Atom Expression)</code> Description Function takes list of atoms (first argument), variable (second argument) and filter predicate (third argument) and returns list with items which passed filter. E.g. (filter-atom (1 2 3 4) $v (eval (&gt; $v 2))) will give (3 4) Parameters <code>Expression</code> - List of atoms <code>Variable</code> - Variable <code>Atom</code> - Filter predicate Returns <code>Expression</code> Filtered list</p>"},{"location":"generated/corelib/#first-from-pair","title":"first-from-pair","text":"<p>Type <code>%Undefined%</code> Description Gets a pair as a first argument and returns first atom from pair Parameters <code>%Undefined%</code> - Pair Returns <code>%Undefined%</code> First atom from a pair</p>"},{"location":"generated/corelib/#floor-math","title":"floor-math","text":"<p>Type <code>(-&gt; Number Number)</code> Description Returns the smallest integer less than or equal to the input value (first argument) Parameters <code>Number</code> - Float value Returns <code>Number</code> Integer value less than or equal to the input</p>"},{"location":"generated/corelib/#foldl-atom","title":"foldl-atom","text":"<p>Type <code>(-&gt; Expression Atom Variable Variable Atom %Undefined%)</code> Description Function takes list of values (first argument), initial value (second argument) and operation (fifth argument) and applies it consequently to the list of values, using init value as a start. It also takes two variables (third and fourth argument) to use them inside Parameters <code>Expression</code> - List of values <code>Atom</code> - Init value <code>Variable</code> - Variable <code>Variable</code> - Variable <code>Atom</code> - Operation Returns <code>%Undefined%</code> Result of applying operation to the list of values</p>"},{"location":"generated/corelib/#for-each-in-atom","title":"for-each-in-atom","text":"<p>Type <code>(-&gt; Expression Atom (-&gt;))</code> Description Applies function passed as a second argument to each atom inside first argument Parameters <code>Expression</code> - Expression to each atom in which function will be applied <code>Atom</code> - Function to apply Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#format-args","title":"format-args","text":"<p>Type <code>(-&gt; String Expression String)</code> Description Fills {} symbols in the input expression with atoms from the second expression. E.g. (format-args (Probability of {} is {}%) (head 50)) gives [(Probability of head is 50%)]. Atoms in the second input value could be variables Parameters <code>String</code> - Expression with {} symbols to be replaced <code>Expression</code> - Atoms to be placed inside expression instead of {} Returns <code>String</code> Expression with replaced {} with atoms</p>"},{"location":"generated/corelib/#function","title":"function","text":"<p>Type <code>(-&gt; Atom Atom)</code> Description Evaluates the argument until it becomes (return ). Then (function (return )) is reduced to the . Parameters <code>Atom</code> - Atom to be evaluated Returns <code>Atom</code> Result of atom's evaluation"},{"location":"generated/corelib/#get-atoms","title":"get-atoms","text":"<p>Type <code>(-&gt; SpaceType Atom)</code> Description Shows all atoms in the input Atomspace Parameters <code>SpaceType</code> - Reference to the space Returns <code>Atom</code> List of all atoms in the input space</p>"},{"location":"generated/corelib/#get-doc","title":"get-doc","text":"<p>Type <code>(-&gt; SpaceType Atom %Undefined%)</code> Description Returns documentation for the given Atom/Function Parameters <code>SpaceType</code> - Atomspace where documentation should be searched <code>Atom</code> - Atom/Function name for which documentation is needed Returns <code>%Undefined%</code> Documentation for the given atom/function</p>"},{"location":"generated/corelib/#get-doc-atom","title":"get-doc-atom","text":"<p>Type <code>(-&gt; SpaceType Atom %Undefined%)</code> Description Function used by get-doc (in case of input type Expression) and get-doc-single-atom (in case input value is not a function) to get documentation on input value Parameters <code>SpaceType</code> - Atomspace where documentation should be searched <code>Atom</code> - Atom's name to get documentation for Returns <code>%Undefined%</code> Documentation on input Atom</p>"},{"location":"generated/corelib/#get-doc-function","title":"get-doc-function","text":"<p>Type <code>(-&gt; SpaceType Atom Type %Undefined%)</code> Description Function used by get-doc-single-atom to get documentation on a function. It returns documentation on a function if it exists or default documentation with no description otherwise Parameters <code>SpaceType</code> - Atomspace where documentation should be searched <code>Atom</code> - Function name for which documentation is needed <code>Type</code> - Type notation for this function Returns <code>%Undefined%</code> Documentation for the given function</p>"},{"location":"generated/corelib/#get-doc-params","title":"get-doc-params","text":"<p>Type <code>(-&gt; Expression Atom Expression (Expression Atom))</code> Description Function used by get-doc-function to get function's parameters documentation (including return value) Parameters <code>Expression</code> - List of parameters in form of ((@param Description) (@param Description)...) <code>Atom</code> - Return value's description in form of (@return Description) <code>Expression</code> - Type notation without -&gt; starting symbol e.g. (Atom Atom %Undefined%) Returns <code>(Expression Atom)</code> United list of params and return value each augmented with its type. E.g. (((@param (@type Atom) (@desc Description)) (@param (@type Atom) (@desc Description2))) (@return (@type Atom) (@desc Description)))</p>"},{"location":"generated/corelib/#get-doc-single-atom","title":"get-doc-single-atom","text":"<p>Type <code>(-&gt; SpaceType Atom %Undefined%)</code> Description Function used by get-doc to get documentation on either function or atom. It checks if input name is the name of function or atom and calls correspondent function Parameters <code>SpaceType</code> - Atomspace where documentation should be searched <code>Atom</code> - Atom/Function name for which documentation is needed Returns <code>%Undefined%</code> Documentation for the given atom/function</p>"},{"location":"generated/corelib/#get-metatype","title":"get-metatype","text":"<p>Type <code>(-&gt; Atom Atom)</code> Description Returns metatype of the input atom Parameters <code>Atom</code> - Atom to get metatype for Returns <code>Atom</code> Metatype of input atom</p>"},{"location":"generated/corelib/#get-state","title":"get-state","text":"<p>Type <code>(-&gt; (StateMonad $ret-type#254899) $ret-type#254899)</code> Description Gets a state as an argument and returns its wrapped atom. E.g. (get-state (State 5)) -&gt; 5 Parameters <code>(StateMonad $ret-type#254899)</code> - State Returns <code>$ret-type#254899</code> Atom wrapped by state</p>"},{"location":"generated/corelib/#get-type","title":"get-type","text":"<p>Type <code>(-&gt; Atom %Undefined%)</code> Description Returns type notation of input atom Parameters <code>Atom</code> - Atom to get type for Returns <code>%Undefined%</code> Type notation or %Undefined% if there is no type for input Atom</p>"},{"location":"generated/corelib/#get-type-space","title":"get-type-space","text":"<p>Type <code>(-&gt; SpaceType Atom Atom)</code> Description Returns type notation of input Atom (second argument) relative to a specified atomspace (first argument) Parameters <code>SpaceType</code> - Atomspace where type notation for input atom will be searched <code>Atom</code> - Atom to get type for Returns <code>Atom</code> Type notation or %Undefined% if there is no type for input Atom in provided atomspace</p>"},{"location":"generated/corelib/#git-module","title":"git-module!","text":"<p>Type <code>(-&gt; Atom (-&gt;))</code> Description Provides access to module in a remote git repo, from within MeTTa code. Similar to <code>register-module!</code>, this op will bypass the catalog search Parameters <code>Atom</code> - URL to github repo Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#help","title":"help!","text":"<p>Type <code>(-&gt; Atom (-&gt;))</code> Description Function prints documentation for the input atom or module. Without parameters prints the list of the corelib functions. Parameters <code>Atom</code> - Input to get documentation for atom or module Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#help-param","title":"help-param!","text":"<p>Type <code>(-&gt; Atom (-&gt;))</code> Description Function used by function help! to output parameters using println! Parameters <code>Atom</code> - Parameters list Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#help-space","title":"help-space!","text":"<p>Type <code>(-&gt; SpaceType (-&gt;))</code> Description Function prints documentation for all of the atoms from the given space. Parameters <code>SpaceType</code> - Space to print documentation for Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#id","title":"id","text":"<p>Type <code>(-&gt; $ret-type#673022 $ret-type#673022)</code> Description Returns its argument Parameters <code>$ret-type#673022</code> - Input argument Returns <code>$ret-type#673022</code> Input argument</p>"},{"location":"generated/corelib/#if","title":"if","text":"<p>Type <code>(-&gt; Bool Atom Atom $ret-type#547082)</code> Description Replace itself by one of the arguments depending on condition. Parameters <code>Bool</code> - Boolean condition <code>Atom</code> - Result when condition is True <code>Atom</code> - Result when condition is False Returns <code>$ret-type#547082</code> Second or third argument</p>"},{"location":"generated/corelib/#if-decons-expr","title":"if-decons-expr","text":"<p>Type <code>(-&gt; Expression Variable Variable Atom Atom %Undefined%)</code> Description Checks if first argument is non empty expression. If so gets tail and head from the first argument and returns forth argument using head and tail values. Returns fifth argument otherwise. Parameters <code>Expression</code> - Expression to be deconstructed <code>Variable</code> - Head variable <code>Variable</code> - Tail variable <code>Atom</code> - Template to return if first argument is a non-empty expression <code>Atom</code> - Default value to return otherwise Returns <code>%Undefined%</code> Either template with head and tail replaced by values or default value</p>"},{"location":"generated/corelib/#if-equal","title":"if-equal","text":"<p>Type <code>(-&gt; Atom Atom Atom Atom %Undefined%)</code> Description Checks if first two arguments are equal and evaluates third argument if equal, fourth argument - otherwise Parameters <code>Atom</code> - First argument <code>Atom</code> - Second argument <code>Atom</code> - Atom to be evaluated if arguments are equal <code>Atom</code> - Atom to be evaluated if arguments are not equal Returns <code>%Undefined%</code> Evaluated third or fourth argument</p>"},{"location":"generated/corelib/#if-error","title":"if-error","text":"<p>Type <code>(-&gt; Atom Atom Atom %Undefined%)</code> Description Checks if first argument is an error atom. Returns second argument if so or third argument otherwise. Parameters <code>Atom</code> - Atom to be checked for the error <code>Atom</code> - Value to return if first argument is an error <code>Atom</code> - Value to return otherwise Returns <code>%Undefined%</code> Second or third argument</p>"},{"location":"generated/corelib/#import","title":"import!","text":"<p>Type <code>(-&gt; Atom Atom (-&gt;))</code> Description Imports module using its relative path (second argument), which could contain ':' as a path separation (e.g. !(import &amp;module relative:path:to:module)) and binds it to the token (first argument) which will represent imported atomspace. If first argument is &amp;self then everything will be imported to current atomspace) Parameters <code>Atom</code> - Symbol, which is turned into the token for accessing the imported module <code>Atom</code> - Module name/relative path to module Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#include","title":"include","text":"<p>Type <code>(-&gt; Atom %Undefined%)</code> Description Works just like import! but with &amp;self as a first argument. So everything from input file will be included in the current atomspace and evaluated Parameters <code>Atom</code> - Name of metta script to import Returns <code>%Undefined%</code> Unit atom</p>"},{"location":"generated/corelib/#index-atom","title":"index-atom","text":"<p>Type <code>(-&gt; Expression Number Atom)</code> Description Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds Parameters <code>Expression</code> - Expression <code>Number</code> - Index Returns <code>Atom</code> Atom from an expression in the place defined by index. Error if index is out of bounds</p>"},{"location":"generated/corelib/#intersection","title":"intersection","text":"<p>Type <code>(-&gt; Atom Atom %Undefined%)</code> Description Function takes two non-deterministic inputs (first and second argument) and returns their intersection. E.g. (intersection (superpose (a b c c)) (superpose (b c c c d))) -&gt; [b, c, c] Parameters <code>Atom</code> - Non-deterministic set of values <code>Atom</code> - Another non-deterministic set of values Returns <code>%Undefined%</code> Intersection of sets</p>"},{"location":"generated/corelib/#intersection-atom","title":"intersection-atom","text":"<p>Type <code>(-&gt; Expression Expression Atom)</code> Description Function takes two tuples and returns their intersection. E.g. (intersection-atom (a b c c) (b c c c d)) -&gt; (b c c) Parameters <code>Expression</code> - List of values <code>Expression</code> - List of values Returns <code>Atom</code> Intersection of sets</p>"},{"location":"generated/corelib/#is-function","title":"is-function","text":"<p>Type <code>(-&gt; Type Bool)</code> Description Function checks if input type is a function type Parameters <code>Type</code> - Type atom Returns <code>Bool</code> True if type is a function type, False - otherwise</p>"},{"location":"generated/corelib/#isinf-math","title":"isinf-math","text":"<p>Type <code>(-&gt; Number Bool)</code> Description Returns True if input value is positive or negative infinity. False - otherwise Parameters <code>Number</code> - Number Returns <code>Bool</code> True/False</p>"},{"location":"generated/corelib/#isnan-math","title":"isnan-math","text":"<p>Type <code>(-&gt; Number Bool)</code> Description Returns True if input value is NaN. False - otherwise Parameters <code>Number</code> - Number Returns <code>Bool</code> True/False</p>"},{"location":"generated/corelib/#let","title":"let","text":"<p>Type <code>(-&gt; Atom %Undefined% Atom %Undefined%)</code> Description Unify two first argument and apply result of the unification on third argument. Second argument is evaluated before unification. Parameters <code>Atom</code> - First atom to be unified <code>%Undefined%</code> - Second atom to be unified <code>Atom</code> - Expression which will be evaluated if two first arguments can be unified Returns <code>%Undefined%</code> Third argument or Empty</p>"},{"location":"generated/corelib/#let_1","title":"let*","text":"<p>Type <code>(-&gt; Expression Atom %Undefined%)</code> Description Same as let but inputs list of pairs of atoms to be unified. For example (let* ((\\(v1 (+ 1 2)) (\\)v2 (* 5 6))) (+ $v1 $v2)) Parameters <code>Expression</code> - List of pairs, atoms in each pair to be unified <code>Atom</code> - Expression which will be evaluated if each pair can be unified Returns <code>%Undefined%</code> Second argument or Empty</p>"},{"location":"generated/corelib/#log-math","title":"log-math","text":"<p>Type <code>(-&gt; Number Number Number)</code> Description Returns result of a logarithm function given base (first argument) and input number (second argument) Parameters <code>Number</code> - Base <code>Number</code> - Input number Returns <code>Number</code> Result of log function</p>"},{"location":"generated/corelib/#map-atom","title":"map-atom","text":"<p>Type <code>(-&gt; Expression Variable Atom Expression)</code> Description Function takes list of atoms (first argument), variable to be used inside (second variable) and an expression which will be evaluated for each atom in list (third argument). Expression should contain variable. So e.g. (map-atom (1 2 3 4) $v (eval (+ $v 1))) will give (2 3 4 5) Parameters <code>Expression</code> - List of atoms <code>Variable</code> - Variable name <code>Atom</code> - Template using variable Returns <code>Expression</code> Result of evaluating template for each atom in a list</p>"},{"location":"generated/corelib/#match","title":"match","text":"<p>Type <code>(-&gt; SpaceType Atom Atom %Undefined%)</code> Description Searches for all declared atoms corresponding to the given pattern (second argument) inside space (first argument) and returns the output template (third argument) Parameters <code>SpaceType</code> - Atomspace to search pattern <code>Atom</code> - Pattern atom to be searched <code>Atom</code> - Output template typically containing variables from the input pattern Returns <code>%Undefined%</code> If match was successfull it outputs template (third argument) with filled variables (if any were present in pattern) using matched pattern (second argument). Empty - otherwise</p>"},{"location":"generated/corelib/#match-type-or","title":"match-type-or","text":"<p>Type <code>%Undefined%</code> Description Checks if two types (second and third arguments) can be unified and returns result of OR operation between first argument and type checking result Parameters <code>%Undefined%</code> - Boolean value <code>%Undefined%</code> - First type <code>%Undefined%</code> - Second type Returns <code>%Undefined%</code> True or False</p>"},{"location":"generated/corelib/#match-types","title":"match-types","text":"<p>Type <code>%Undefined%</code> Description Checks if two types can be unified and returns third argument if so, fourth - otherwise Parameters <code>%Undefined%</code> - First type <code>%Undefined%</code> - Second type <code>%Undefined%</code> - Atom to be returned if types can be unified <code>%Undefined%</code> - Atom to be returned if types cannot be unified Returns <code>%Undefined%</code> Third or fourth argument</p>"},{"location":"generated/corelib/#max-atom","title":"max-atom","text":"<p>Type <code>(-&gt; %Undefined% Number)</code> Description Returns atom with max value in the expression (first argument). Only numbers allowed Parameters <code>%Undefined%</code> - Expression which contains atoms of Number type Returns <code>Number</code> Max value in the expression. Error if expression contains non-numeric value or is empty</p>"},{"location":"generated/corelib/#metta","title":"metta","text":"<p>Type <code>(-&gt; Atom Type SpaceType Atom)</code> Description Run MeTTa interpreter on atom. Parameters <code>Atom</code> - Atom to be interpreted <code>Type</code> - Type of input atom <code>SpaceType</code> - Atomspace where intepretation should take place Returns <code>Atom</code> Result of interpretation</p>"},{"location":"generated/corelib/#min-atom","title":"min-atom","text":"<p>Type <code>(-&gt; %Undefined% Number)</code> Description Returns atom with min value in the expression (first argument). Only numbers allowed Parameters <code>%Undefined%</code> - Expression which contains atoms of Number type Returns <code>Number</code> Min value in the expression. Error if expression contains non-numeric value or is empty</p>"},{"location":"generated/corelib/#mod-space","title":"mod-space!","text":"<p>Type <code>(-&gt; Atom SpaceType)</code> Description Returns the space of the module (first argument) and tries to load the module if it is not loaded into the module system Parameters <code>Atom</code> - Module name Returns <code>SpaceType</code> Space name</p>"},{"location":"generated/corelib/#module-space-no-deps","title":"module-space-no-deps","text":"<p>Type <code>(-&gt; SpaceType SpaceType)</code> Description Gets module space and returns the space without dependencies. It is useful when one need to search the module space itself not including imported modules. Parameters <code>SpaceType</code> - Module space Returns <code>SpaceType</code> Space without dependencies included</p>"},{"location":"generated/corelib/#new-space","title":"new-space","text":"<p>Type <code>(-&gt; SpaceType)</code> Description Creates new Atomspace which could be used further in the program as a separate from &amp;self Atomspace Parameters Returns <code>SpaceType</code> Reference to a new space</p>"},{"location":"generated/corelib/#new-state","title":"new-state","text":"<p>Type <code>(-&gt; $t#265543 (StateMonad $t#265543))</code> Description Creates a new state atom wrapping its argument Parameters <code>$t#265543</code> - Atom to be wrapped Returns <code>(StateMonad $t#265543)</code> Returns (State $value) where $value is an argument to a new-state</p>"},{"location":"generated/corelib/#noeval","title":"noeval","text":"<p>Type <code>(-&gt; Atom Atom)</code> Description Returns its argument Parameters <code>Atom</code> - Input argument Returns <code>Atom</code> Input argument</p>"},{"location":"generated/corelib/#nop","title":"nop","text":"<p>Type <code>%Undefined%</code> Description Outputs unit atom Parameters Returns <code>%Undefined%</code> Unit atom</p>"},{"location":"generated/corelib/#noreduce-eq","title":"noreduce-eq","text":"<p>Type <code>(-&gt; Atom Atom Bool)</code> Description Checks equality of two atoms without reducing them Parameters <code>Atom</code> - First atom <code>Atom</code> - Second atom Returns <code>Bool</code> True if not reduced atoms are equal, False - otherwise</p>"},{"location":"generated/corelib/#not","title":"not","text":"<p>Type <code>(-&gt; Bool Bool)</code> Description Logical negation Parameters <code>Bool</code> - Argument Returns <code>Bool</code> Negates boolean input argument (False -&gt; True, True -&gt; False)</p>"},{"location":"generated/corelib/#or","title":"or","text":"<p>Type <code>(-&gt; Bool Bool Bool)</code> Description Logical disjunction of two arguments Parameters <code>Bool</code> - First argument <code>Bool</code> - Second argument Returns <code>Bool</code> True if any of input arguments is True, False - otherwise</p>"},{"location":"generated/corelib/#pow-math","title":"pow-math","text":"<p>Type <code>(-&gt; Number Number Number)</code> Description Takes base (first argument) and power (second argument) and returns result of a power function (base ^ power) Parameters <code>Number</code> - Base <code>Number</code> - Power Returns <code>Number</code> Result of a power function</p>"},{"location":"generated/corelib/#pragma","title":"pragma!","text":"<p>Type <code>%Undefined%</code> Description Changes global key's (first argument) value to a new one (second argument). Possible pragmas:   (pragma! type-check auto) - check type of the atom before evaluation   (pragma! interpreter bare-minimal) - use minimal MeTTa semantics when evaluating atom   (pragma! max-stack-depth ) - limit depth of the interpreter's stack, 0 - no limit (default behavior) Parameters <code>%Undefined%</code> - Key's name <code>%Undefined%</code> - New value Returns <code>%Undefined%</code> Unit atom"},{"location":"generated/corelib/#print-mods","title":"print-mods!","text":"<p>Type <code>(-&gt; (-&gt;))</code> Description Prints all modules with their correspondent spaces Parameters Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#println","title":"println!","text":"<p>Type <code>(-&gt; %Undefined% (-&gt;))</code> Description Prints a line of text to the console Parameters <code>%Undefined%</code> - Expression/atom to be printed out Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#quote","title":"quote","text":"<p>Type <code>(-&gt; Atom Atom)</code> Description Prevents atom from being reduced Parameters <code>Atom</code> - Atom Returns <code>Atom</code> Quoted atom</p>"},{"location":"generated/corelib/#register-module","title":"register-module!","text":"<p>Type <code>(-&gt; Atom (-&gt;))</code> Description Takes a file system path (first argument) and loads the module into the runner Parameters <code>Atom</code> - File system path Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#remove-atom","title":"remove-atom","text":"<p>Type <code>(-&gt; SpaceType Atom (-&gt;))</code> Description Removes atom from the input Atomspace Parameters <code>SpaceType</code> - Reference to the space from which the Atom needs to be removed <code>Atom</code> - Atom to be removed Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/corelib/#return_2","title":"return","text":"<p>Type <code>(-&gt; $ret-type#826118 $ret-type#826118)</code> Description Returns value from the (function ...) expression Parameters <code>$ret-type#826118</code> - Value to be returned Returns <code>$ret-type#826118</code> Passed argument</p>"},{"location":"generated/corelib/#return-on-error","title":"return-on-error","text":"<p>Type <code>(-&gt; Atom Atom %Undefined%)</code> Description Returns first argument if it is Empty or an error. Returns second argument otherwise. Parameters <code>Atom</code> - Previous evaluation result <code>Atom</code> - Atom for further evaluation Returns <code>%Undefined%</code> Return previous result if it is an error or Empty or continue evaluation</p>"},{"location":"generated/corelib/#round-math","title":"round-math","text":"<p>Type <code>(-&gt; Number Number)</code> Description Returns the nearest integer to the input float value (first argument) Parameters <code>Number</code> - Float value Returns <code>Number</code> Nearest integer to the input</p>"},{"location":"generated/corelib/#sealed","title":"sealed","text":"<p>Type <code>(-&gt; Expression Atom Atom)</code> Description Replaces all occurrences of any var inside atom (second argument) by unique variable, except list of variables to ignore (first argument). Can be used to create a locally scoped variables Parameters <code>Expression</code> - Variable list to ignore e.g. ($x $y) <code>Atom</code> - Atom which uses those variables Returns <code>Atom</code> Second argument but with variables being replaced with unique variables</p>"},{"location":"generated/corelib/#sin-math","title":"sin-math","text":"<p>Type <code>(-&gt; Number Number)</code> Description Returns result of the sine function for an input value in radians (first argument) Parameters <code>Number</code> - Angle in radians Returns <code>Number</code> Result of the sine function</p>"},{"location":"generated/corelib/#size-atom","title":"size-atom","text":"<p>Type <code>(-&gt; Expression Number)</code> Description Returns size of an expression (first argument) Parameters <code>Expression</code> - Expression Returns <code>Number</code> Size of an expression</p>"},{"location":"generated/corelib/#sort-strings","title":"sort-strings","text":"<p>Type <code>(-&gt; Expression Expression)</code> Description Sorts expression which contains strings in alphabet order Parameters <code>Expression</code> - List of strings Returns <code>Expression</code> Sorted list of strings</p>"},{"location":"generated/corelib/#sqrt-math","title":"sqrt-math","text":"<p>Type <code>(-&gt; Number Number)</code> Description Returns square root for input number (first argument) which should be &gt;= 0 Parameters <code>Number</code> - Input number Returns <code>Number</code> Result of a square root function</p>"},{"location":"generated/corelib/#subtraction","title":"subtraction","text":"<p>Type <code>(-&gt; Atom Atom %Undefined%)</code> Description Function takes two non-deterministic inputs (first and second argument) and returns their subtraction. E.g. !(subtraction (superpose (a b b c)) (superpose (b c c d))) -&gt; [a, b] Parameters <code>Atom</code> - Non-deterministic set of values <code>Atom</code> - Another non-deterministic set of values Returns <code>%Undefined%</code> Subtraction of sets</p>"},{"location":"generated/corelib/#subtraction-atom","title":"subtraction-atom","text":"<p>Type <code>(-&gt; Expression Expression Atom)</code> Description Function takes two tuples and returns their subtraction. E.g. !(subtraction-atom (a b b c) (b c c d)) -&gt; (a b) Parameters <code>Expression</code> - List of values <code>Expression</code> - List of values Returns <code>Atom</code> Subtraction of sets</p>"},{"location":"generated/corelib/#superpose","title":"superpose","text":"<p>Type <code>(-&gt; Expression %Undefined%)</code> Description Turns a tuple (first argument) into a nondeterministic result Parameters <code>Expression</code> - Tuple to be converted Returns <code>%Undefined%</code> Argument converted to nondeterministic result</p>"},{"location":"generated/corelib/#superpose-bind","title":"superpose-bind","text":"<p>Type <code>(-&gt; Expression Atom)</code> Description Complement to the collapse-bind. It takes result of collapse-bind (first argument) and returns only result atoms without bindings Parameters <code>Expression</code> - Expression in form (Atom Binding) Returns <code>Atom</code> Non-deterministic list of Atoms</p>"},{"location":"generated/corelib/#switch","title":"switch","text":"<p>Type <code>(-&gt; %Undefined% Expression %Undefined%)</code> Description Subsequently tests multiple pattern-matching conditions (second argument) for the given value (first argument) Parameters <code>%Undefined%</code> - Atom to be matched with patterns <code>Expression</code> - Tuple of pairs mapping condition patterns to results Returns <code>%Undefined%</code> Result which corresponds to the pattern which is matched with the passed atom first</p>"},{"location":"generated/corelib/#switch-internal","title":"switch-internal","text":"<p>Type <code>(-&gt; Atom Expression Atom)</code> Description This function is being called inside switch function to test one of the cases and it calls switch once again if current condition is not met Parameters <code>Atom</code> - Atom (it will be evaluated) <code>Expression</code> - Deconsed tuple of pairs mapping condition patterns to results Returns <code>Atom</code> Result of evaluating of Atom bound to met condition</p>"},{"location":"generated/corelib/#tan-math","title":"tan-math","text":"<p>Type <code>(-&gt; Number Number)</code> Description Returns result of the tangent function for an input value in radians (first argument) Parameters <code>Number</code> - Angle in radians Returns <code>Number</code> Result of the tangent function</p>"},{"location":"generated/corelib/#trace","title":"trace!","text":"<p>Type <code>(-&gt; %Undefined% Atom %Undefined%)</code> Description Prints its first argument and returns second. Both arguments will be evaluated before processing Parameters <code>%Undefined%</code> - Atom to print <code>Atom</code> - Atom to return Returns <code>%Undefined%</code> Evaluated second input</p>"},{"location":"generated/corelib/#trunc-math","title":"trunc-math","text":"<p>Type <code>(-&gt; Number Number)</code> Description Returns integer part of the input value (first argument) Parameters <code>Number</code> - Float value Returns <code>Number</code> Integer part of float</p>"},{"location":"generated/corelib/#type-cast","title":"type-cast","text":"<p>Type <code>%Undefined%</code> Description Casts atom passed as a first argument to the type passed as a second argument using space as a context Parameters <code>%Undefined%</code> - Atom to be casted <code>%Undefined%</code> - Type to cast atom to <code>%Undefined%</code> - Context atomspace Returns <code>%Undefined%</code> Atom if casting is successful, (Error ... BadType) otherwise</p>"},{"location":"generated/corelib/#undefined-doc-function-type","title":"undefined-doc-function-type","text":"<p>Type <code>(-&gt; Expression Type)</code> Description Function used by get-doc-single-atom in case of absence of function's type notation Parameters <code>Expression</code> - List of parameters for the function we want to get documentation for Returns <code>Type</code> List of %Undefined% number of which depends on input list size. So for two parameters function will return (%Undefined% %Undefined% %Undefined%)</p>"},{"location":"generated/corelib/#unify","title":"unify","text":"<p>Type <code>(-&gt; Atom Atom Atom Atom %Undefined%)</code> Description Matches two first arguments and returns third argument if they are matched and forth argument otherwise Parameters <code>Atom</code> - First atom to unify with <code>Atom</code> - Second atom to unify with <code>Atom</code> - Result if two atoms unified successfully <code>Atom</code> - Result otherwise Returns <code>%Undefined%</code> Third argument when first two atoms are matched of forth one otherwise</p>"},{"location":"generated/corelib/#union","title":"union","text":"<p>Type <code>(-&gt; Atom Atom %Undefined%)</code> Description Function takes two non-deterministic inputs (first and second argument) and returns their union. E.g. (union (superpose (a b b c)) (superpose (b c c d))) -&gt; [a, b, b, c, b, c, c, d] Parameters <code>Atom</code> - Non-deterministic set of values <code>Atom</code> - Another non-deterministic set of values Returns <code>%Undefined%</code> Union of sets</p>"},{"location":"generated/corelib/#union-atom","title":"union-atom","text":"<p>Type <code>(-&gt; Expression Expression Atom)</code> Description Function takes two tuples and returns their union. E.g. (union-atom (a b b c) (b c c d)) -&gt; (a b b c b c c d) Parameters <code>Expression</code> - List of values <code>Expression</code> - List of values Returns <code>Atom</code> Union of sets</p>"},{"location":"generated/corelib/#unique","title":"unique","text":"<p>Type <code>(-&gt; Atom %Undefined%)</code> Description Function takes non-deterministic input (first argument) and returns only unique entities. E.g. (unique (superpose (a b c d d))) -&gt; [a, b, c, d] Parameters <code>Atom</code> - Non-deterministic set of values Returns <code>%Undefined%</code> Unique values from input set</p>"},{"location":"generated/corelib/#unique-atom","title":"unique-atom","text":"<p>Type <code>(-&gt; Expression Atom)</code> Description Function takes tuple and returns only unique entities. E.g. (unique-atom (a b c d d)) -&gt; (a b c d) Parameters <code>Expression</code> - List of values Returns <code>Atom</code> Unique values from input set</p>"},{"location":"generated/corelib/#unquote","title":"unquote","text":"<p>Type <code>(-&gt; %Undefined% %Undefined%)</code> Description Unquotes quoted atom, e.g. (unquote (quote $x)) returns $x Parameters <code>%Undefined%</code> - Quoted atom Returns <code>%Undefined%</code> Unquoted atom</p>"},{"location":"generated/corelib/#xor","title":"xor","text":"<p>Type <code>(-&gt; Bool Bool Bool)</code> Description Logical exclusive or Parameters <code>Bool</code> - First argument <code>Bool</code> - Second argument Returns <code>Bool</code> Returns True if one and only one of the inputs is True</p>"},{"location":"generated/das/","title":"DAS","text":""},{"location":"generated/das/#das-create-context","title":"das-create-context!","text":"<p>Type <code>(-&gt; String Atom %Undefined%)</code> Description Creates a context in the DAS with specified query, determiner schema, and stimulus schema Parameters <code>String</code> - Context name (string) <code>Atom</code> - ExpressionAtom containing schemas: ( (query) (determiner_schema) (stimulus_schema) ) Returns <code>%Undefined%</code> Result atom from context creation</p>"},{"location":"generated/das/#das-evolution","title":"das-evolution!","text":"<p>Type <code>(-&gt; Atom Atom %Undefined%)</code> Description Performs DAS evolution operation with query, fitness function, correlation queries, replacements, and mappings Parameters <code>Atom</code> - ExpressionAtom containing evolution configuration: ( (query) (fitness-function) (correlation-queries) (correlation-replacements) (correlation-mappings) ) <code>Atom</code> - Template atom to be filled with evolution results Returns <code>%Undefined%</code> Non-deterministic result: template with bindings from evolution</p>"},{"location":"generated/das/#das-get-params","title":"das-get-params!","text":"<p>Type <code>(-&gt; (-&gt;))</code> Description Prints all current DAS parameters Parameters Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/das/#das-helpers","title":"das-helpers!","text":"<p>Type <code>(-&gt; Atom Atom (-&gt;))</code> Description Executes helper functions for DAS operations. Currently supports 'sleep' helper Parameters <code>Atom</code> - Helper function name (string), e.g., 'sleep' <code>Atom</code> - Argument for the helper function (string), e.g., '5' for sleep duration in seconds Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/das/#das-join-network","title":"das-join-network!","text":"<p>Type <code>(-&gt; (-&gt;))</code> Description (re)Joins the DAS network using the configured parameters Parameters Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/das/#das-link-creation","title":"das-link-creation!","text":"<p>Type <code>%Undefined%</code> Description Creates links in the DAS based on a query pattern and one or more templates Parameters <code>%Undefined%</code> - Query atom to match against <code>%Undefined%</code> - Template atoms (one or more) for link creation Returns <code>%Undefined%</code> Result atom from link creation</p>"},{"location":"generated/das/#das-service-status","title":"das-service-status!","text":"<p>Type <code>(-&gt; ServiceName (-&gt;))</code> Description Checks the status of a specific DAS service by name Parameters <code>ServiceName</code> - Service name (string) Returns <code>(-&gt;)</code> String: 'ServiceAvailable: ' if available, or error if not available or not registered"},{"location":"generated/das/#das-services","title":"das-services!","text":"<p>Type <code>(-&gt; (-&gt;))</code> Description Prints information about available DAS services Parameters Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"generated/das/#das-set-param","title":"das-set-param!","text":"<p>Type <code>(-&gt; Atom (-&gt;))</code> Description Sets a DAS parameter value. The parameter must exist in the DAS configuration Parameters <code>Atom</code> - Expression containing key-value pair, e.g., (max_answers 100) Returns <code>(-&gt;)</code> String: 'DAS Param Updated: ' or error"},{"location":"generated/das/#new-das","title":"new-das!","text":"<p>Type <code>(-&gt; Symbol Symbol SpaceType)</code> Description Creates a new Distributed AtomSpace (DAS) instance with specified server and known peer endpoints Parameters <code>Symbol</code> - Server endpoint with port range (e.g., 0.0.0.0:42000-42999 or localhost:52000-52099) <code>Symbol</code> - Known peer endpoint (e.g., 0.0.0.0:40002 or localhost:40002) Returns <code>SpaceType</code> A Space instance representing the DAS</p>"},{"location":"generated/fileio/","title":"File Input/Output","text":""},{"location":"generated/fileio/#file-get-size","title":"file-get-size!","text":"<p>Type <code>(-&gt; FileHandle Number)</code> Description Function takes filehandle provided by file-open! and returns size of file Parameters <code>FileHandle</code> - Filehandle Returns <code>Number</code> Size of file</p>"},{"location":"generated/fileio/#file-open","title":"file-open!","text":"<p>Type <code>(-&gt; String String FileHandle)</code> Description Function takes path to the file and open options (r, w, c, a, t) both in form of string, creates filehandle and     returns it Parameters <code>String</code> - Filepath (string atom) <code>String</code> - Open options (string atom), r - read, w - write, c - create if file doesn't exist, a - append to file,         t - truncate file Returns <code>FileHandle</code> Filehandle or error if combination of path and open options is wrong (e.g. file doesn't exist and no 'c'     in options; or 'rc' option provided, since 'c' demands for 'w')</p>"},{"location":"generated/fileio/#file-read-exact","title":"file-read-exact!","text":"<p>Type <code>(-&gt; FileHandle Number String)</code> Description Function takes filehandle provided by file-open! and desired number of bytes to read (number), reads content   of file from current cursor position (number of read bytes &lt;= input number of bytes to read) and returns it in form of   string Parameters <code>FileHandle</code> - Filehandle <code>Number</code> - Number of bytes to read Returns <code>String</code> File's content</p>"},{"location":"generated/fileio/#file-read-to-string","title":"file-read-to-string!","text":"<p>Type <code>(-&gt; FileHandle String)</code> Description Function takes filehandle provided by file-open! reads its content from current cursor place till the end of     file and returns content in form of string. Parameters <code>FileHandle</code> - Filehandle Returns <code>String</code> File's content</p>"},{"location":"generated/fileio/#file-seek","title":"file-seek!","text":"<p>Type <code>(-&gt; FileHandle Number ())</code> Description Function takes filehandle provided by file-open! and desired cursor position (number) and sets cursor to     provided position Parameters <code>FileHandle</code> - Filehandle <code>Number</code> - Desired cursor position (number) Returns <code>()</code> Unit atom</p>"},{"location":"generated/fileio/#file-write","title":"file-write!","text":"<p>Type <code>(-&gt; FileHandle String ())</code> Description Function takes filehandle provided by file-open!, content to be written (string atom) and puts content into     file associated with filehandle Parameters <code>FileHandle</code> - Filehandle <code>String</code> - Content (string atom) Returns <code>()</code> Unit atom</p>"},{"location":"generated/json/","title":"JSON","text":""},{"location":"generated/json/#dict-space","title":"dict-space","text":"<p>Type <code>(-&gt; Expression Grounded)</code> Description Function takes key-value pairs in form of expression as input, creates space and adds key-value pairs into it Parameters <code>Expression</code> - Expression Returns <code>Grounded</code> Space</p>"},{"location":"generated/json/#get-keys","title":"get-keys","text":"<p>Type <code>(-&gt; Grounded Atom)</code> Description Function takes space and returns all keys from ( ) tuples in space Parameters <code>Grounded</code> - Space Returns <code>Atom</code> All keys in the input space"},{"location":"generated/json/#get-value","title":"get-value","text":"<p>Type <code>(-&gt; Grounded Atom %Undefined%)</code> Description Function takes space and key as input, checks if space contains key-value pairs in form of (key value) and returns value tied to the input key Parameters <code>Grounded</code> - Space <code>Atom</code> - Key Returns <code>%Undefined%</code> Value which tied to input key, empty if no such key in space</p>"},{"location":"generated/json/#json-decode","title":"json-decode","text":"<p>Type <code>(-&gt; String Atom)</code> Description Function takes json string as an input and decodes it to the metta objects (list to expression, dictionary to space which will contain key-value pairs in form of (key value), string to string, number to number) Parameters <code>String</code> - Json string Returns <code>Atom</code> Metta object</p>"},{"location":"generated/json/#json-encode","title":"json-encode","text":"<p>Type <code>(-&gt; Atom String)</code> Description Function takes atom as an input and encodes it to json-string. Atom could be a string, number, expression, space and combination of those Parameters <code>Atom</code> - Input atom Returns <code>String</code> Json string</p>"},{"location":"generated/random/","title":"Random","text":""},{"location":"generated/random/#flip","title":"flip","text":"<p>Type <code>(-&gt; Bool)</code> Description Random boolean value Parameters Returns <code>Bool</code> Returns uniformly distributed random boolean value</p>"},{"location":"generated/random/#new-random-generator","title":"new-random-generator","text":"<p>Type <code>(-&gt; Number RandomGenerator)</code> Description Creates new random number generator instance using seed as input (first argument) Parameters <code>Number</code> - Seed Returns <code>RandomGenerator</code> Instance of random number generator</p>"},{"location":"generated/random/#random-float","title":"random-float","text":"<p>Type <code>(-&gt; RandomGenerator Number Number Number)</code> Description Returns random float number from range defined by two numbers (second and third argument) Parameters <code>RandomGenerator</code> - Random number generator instance <code>Number</code> - Range start <code>Number</code> - Range end Returns <code>Number</code> Random float number from defined range</p>"},{"location":"generated/random/#random-int","title":"random-int","text":"<p>Type <code>(-&gt; RandomGenerator Number Number Number)</code> Description Returns random int number from range defined by two numbers (second and third argument) Parameters <code>RandomGenerator</code> - Random number generator instance <code>Number</code> - Range start <code>Number</code> - Range end Returns <code>Number</code> Random int number from defined range</p>"},{"location":"generated/random/#reset-random-generator","title":"reset-random-generator","text":"<p>Type <code>(-&gt; RandomGenerator ())</code> Description Resets instance of random number generator (first argument) to its default behavior (StdRng::from_os_rng()) Parameters <code>RandomGenerator</code> - Random number generator instance Returns <code>()</code> Random number generator instance with default behavior</p>"},{"location":"generated/random/#set-random-seed","title":"set-random-seed","text":"<p>Type <code>(-&gt; RandomGenerator Number (-&gt;))</code> Description Sets a new seed (second argument) for random number generator (first argument) Parameters <code>RandomGenerator</code> - Random number generator instance <code>Number</code> - Seed Returns <code>(-&gt;)</code> Unit atom</p>"},{"location":"reference/atoms/","title":"Atoms","text":""},{"location":"reference/atoms/#hyperon.atoms","title":"atoms","text":"<p>The Python wrapper for Hyperon Atom Rust types</p>"},{"location":"reference/atoms/#hyperon.atoms.Atom","title":"Atom","text":"<pre><code>Atom(catom)\n</code></pre> <p>Represents an Atom of any type</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize an Atom\"\"\"\n    self.catom = catom\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.get_metatype","title":"get_metatype","text":"<pre><code>get_metatype()\n</code></pre> <p>Gets the metatype (kind) of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_metatype(self):\n    \"\"\"Gets the metatype (kind) of the current Atom instance\"\"\"\n    return hp.atom_get_metatype(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.AtomType","title":"AtomType","text":"<p>Defines all Atom types</p>"},{"location":"reference/atoms/#hyperon.atoms.Bindings","title":"Bindings","text":"<pre><code>Bindings(bindings: Union[CBindings, None] = None)\n</code></pre> <p>Interface for working with atom matching and variable-to-atom binding.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, bindings: Union[hp.CBindings, None] = None):\n    \"\"\"Initializes with or without pre-existing bindings.\"\"\"\n    if bindings is None:\n        self.cbindings = hp.bindings_new()\n    else:\n        self.cbindings = bindings\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memodict={})\n</code></pre> <p>Makes a \"deep copy\" of the bindings.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __deepcopy__(self, memodict={}):\n    \"\"\"Makes a \"deep copy\" of the bindings.\"\"\"\n    return self.clone()\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees the binding resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees the binding resources.\"\"\"\n    if self.cbindings is not None:\n        hp.bindings_free(self.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>For context management.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __enter__(self):\n    \"\"\"For context management.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two bindings objects contain identical associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two bindings objects contain identical associations.\"\"\"\n    return (isinstance(other, Bindings) and\n            hp.bindings_eq(self.cbindings, other.cbindings))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Frees resources on exit.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Frees resources on exit.\"\"\"\n    if self.cbindings is not None:\n        hp.bindings_free(self.cbindings)\n        self.cbindings = None\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a text description of the bindings</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a text description of the bindings\"\"\"\n    return hp.bindings_to_str(self.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.add_var_binding","title":"add_var_binding","text":"<pre><code>add_var_binding(var: VariableAtom, atom: Atom) -&gt; bool\n</code></pre> <p>Adds a binding between a variable and an Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def add_var_binding(self, var: VariableAtom, atom: Atom) -&gt; bool:\n    \"\"\"Adds a binding between a variable and an Atom.\"\"\"\n    return hp.bindings_add_var_binding(self.cbindings, var.catom, atom.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.clone","title":"clone","text":"<pre><code>clone()\n</code></pre> <p>Makes a \"deep copy\" of the bindings</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def clone(self):\n    \"\"\"Makes a \"deep copy\" of the bindings\"\"\"\n    return Bindings(hp.bindings_clone(self.cbindings))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Checks if a bindings contains no associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Checks if a bindings contains no associations.\"\"\"\n    return hp.bindings_is_empty(self.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.iterator","title":"iterator","text":"<pre><code>iterator()\n</code></pre> <p>Returns an iterator over the variable-atom pairs in the bindings</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterator(self):\n    \"\"\"Returns an iterator over the variable-atom pairs in the bindings\"\"\"\n    res = hp.bindings_list(self.cbindings)\n    result = [(Atom._from_catom(r[0]), Atom._from_catom(r[1])) for r in res]\n    return iter(result)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.merge","title":"merge","text":"<pre><code>merge(other: Bindings) -&gt; BindingsSet\n</code></pre> <p>Merges with another Bindings instance, into a Bindings Set.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def merge(self, other: 'Bindings') -&gt; 'BindingsSet':\n    \"\"\"Merges with another Bindings instance, into a Bindings Set.\"\"\"\n    return BindingsSet(hp.bindings_merge(self.cbindings, other.cbindings))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.narrow_vars","title":"narrow_vars","text":"<pre><code>narrow_vars(vars)\n</code></pre> <p>Keeps only specific variable associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def narrow_vars(self, vars ):\n    \"\"\"Keeps only specific variable associations.\"\"\"\n    cvars = hp.CVecAtom = hp.atom_vec_new()\n    for var in vars:\n        hp.atom_vec_push(cvars, var.catom)\n    hp.bindings_narrow_vars(self.cbindings, cvars)\n    hp.atom_vec_free(cvars)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.resolve","title":"resolve","text":"<pre><code>resolve(var: VariableAtom) -&gt; Union[Atom, None]\n</code></pre> <p>Finds the atom for a given variable</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def resolve(self, var: VariableAtom) -&gt; Union[Atom, None]:\n    \"\"\"Finds the atom for a given variable\"\"\"\n    raw_atom = hp.bindings_resolve(self.cbindings, var.catom)\n    return None if raw_atom is None else Atom._from_catom(raw_atom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet","title":"BindingsSet","text":"<pre><code>BindingsSet(input: Union[CBindingsSet, Bindings, None] = None)\n</code></pre> <p>Represents a set of Bindings frames, potentially expressing all possible matches produced by a match operation.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, input: Union[hp.CBindingsSet, Bindings, None] = None):\n    \"\"\"Initializes with optional input.\"\"\"\n    self.shadow_list = None # A lazily initialized list that shadows the BindingsSet values for indexed access\n    if input is None:\n        self.c_set = hp.bindings_set_single()\n    elif isinstance(input, Bindings):\n        self.c_set = hp.bindings_set_from_bindings(input.cbindings)\n    else:\n        self.c_set = input\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memodict={})\n</code></pre> <p>Makes a \"deep copy\" of a BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __deepcopy__(self, memodict={}):\n    \"\"\"Makes a \"deep copy\" of a BindingsSet\"\"\"\n    return self.clone()\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees the BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees the BindingsSet\"\"\"\n    if self.c_set is not None:\n        hp.bindings_set_free(self.c_set)\n        self.c_set = None\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>For context management.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __enter__(self):\n    \"\"\"For context management.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if other BindingsSet contains identical associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if other BindingsSet contains identical associations.\"\"\"\n    return (isinstance(other, BindingsSet) and\n            hp.bindings_set_eq(self.c_set, other.c_set))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Frees resources on exit.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Frees resources on exit.\"\"\"\n    if self.c_set is not None:\n        hp.bindings_set_free(self.c_set)\n        self.c_set = None\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Gets a Bindings frame by index</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Gets a Bindings frame by index\"\"\"\n    if self.shadow_list is None:\n        result = hp.bindings_set_unpack(self.c_set)\n        self.shadow_list = [{k: Atom._from_catom(v) for k, v in bindings.items()} for bindings in result]\n    return self.shadow_list[key]\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a text description of a BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a text description of a BindingsSet\"\"\"\n    return hp.bindings_set_to_str(self.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.add_var_binding","title":"add_var_binding","text":"<pre><code>add_var_binding(var: VariableAtom, value: Atom) -&gt; bool\n</code></pre> <p>Adds a new variable to atom association to every Bindings frame in a BindingsSet.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def add_var_binding(self, var: VariableAtom, value: Atom) -&gt; bool:\n    \"\"\"Adds a new variable to atom association to every Bindings frame in a\n    BindingsSet.\n    \"\"\"\n    self.shadow_list = None\n    return hp.bindings_set_add_var_binding(self.c_set, var.catom, value.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.add_var_equality","title":"add_var_equality","text":"<pre><code>add_var_equality(a: Atom, b: Atom) -&gt; bool\n</code></pre> <p>Asserts equality between two Variable atoms in a BindingsSet.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def add_var_equality(self, a: Atom, b: Atom) -&gt; bool:\n    \"\"\"Asserts equality between two Variable atoms in a BindingsSet.\"\"\"\n    self.shadow_list = None\n    return hp.bindings_set_add_var_equality(self.c_set, a.catom, b.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.clone","title":"clone","text":"<pre><code>clone()\n</code></pre> <p>Makes a \"deep copy\" of a BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def clone(self):\n    \"\"\"Makes a \"deep copy\" of a BindingsSet\"\"\"\n    return BindingsSet(hp.bindings_set_clone(self.c_set))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.empty","title":"empty","text":"<pre><code>empty()\n</code></pre> <p>Creates a new BindingsSet without any Bindings frames. Conceptually, this means no valid matches exist.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def empty():\n    \"\"\"Creates a new BindingsSet without any Bindings frames.\n    Conceptually, this means no valid matches exist.\n    \"\"\"\n    return BindingsSet(hp.bindings_set_empty())\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Checks if a BindingsSet contains no Bindings frames, and thus indicates no match.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Checks if a BindingsSet contains no Bindings frames, and thus indicates\n    no match.\"\"\"\n    return hp.bindings_set_is_empty(self.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.is_single","title":"is_single","text":"<pre><code>is_single() -&gt; bool\n</code></pre> <p>Checks if a Bindings set contains a frame with no associations, and thus allows variables to take any value.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def is_single(self) -&gt; bool:\n    \"\"\"Checks if a Bindings set contains a frame with no associations, and\n    thus allows variables to take any value.\n    \"\"\"\n    return hp.bindings_set_is_single(self.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.iterator","title":"iterator","text":"<pre><code>iterator()\n</code></pre> <p>Returns an iterator over all Bindings frames</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterator(self):\n    \"\"\"Returns an iterator over all Bindings frames\"\"\"\n    res = hp.bindings_set_list(self.c_set)\n    result = [Bindings(r) for r in res]\n    return iter(result)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.merge_into","title":"merge_into","text":"<pre><code>merge_into(input: Union[BindingsSet, Bindings])\n</code></pre> <p>Merges the contents of another BindingsSet or Bindings frame.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def merge_into(self, input: Union['BindingsSet', Bindings]):\n    \"\"\"Merges the contents of another BindingsSet or Bindings frame.\"\"\"\n    self.shadow_list = None\n    if isinstance(input, BindingsSet):\n        hp.bindings_set_merge_into(self.c_set, input.c_set)\n    else:\n        new_set = BindingsSet(input)\n        hp.bindings_set_merge_into(self.c_set, new_set.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.push","title":"push","text":"<pre><code>push(bindings: Bindings)\n</code></pre> <p>Adds a Bindings frame to an existing BindingsSet</p>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.push--parameters","title":"Parameters","text":"<p>bindings:     The Bindings set to incorporate into set. Ownership of this argument is     taken by this function.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def push(self, bindings: Bindings):\n    \"\"\"Adds a Bindings frame to an existing BindingsSet\n\n    Parameters\n    ----------\n    bindings:\n        The Bindings set to incorporate into set. Ownership of this argument is\n        taken by this function.\n    \"\"\"\n    self.shadow_list = None\n    hp.bindings_set_push(self.c_set, bindings.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom","title":"ExpressionAtom","text":"<pre><code>ExpressionAtom(catom)\n</code></pre> <p>               Bases: <code>Atom</code></p> <p>An ExpressionAtom combines different kinds of Atoms, including expressions.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize an expression atom\"\"\"\n    super().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.get_children","title":"get_children","text":"<pre><code>get_children()\n</code></pre> <p>Returns all children Atoms of an expression</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_children(self):\n    \"\"\"Returns all children Atoms of an expression\"\"\"\n    return [Atom._from_catom(catom) for catom in hp.atom_get_children(self.catom)]\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.get_metatype","title":"get_metatype","text":"<pre><code>get_metatype()\n</code></pre> <p>Gets the metatype (kind) of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_metatype(self):\n    \"\"\"Gets the metatype (kind) of the current Atom instance\"\"\"\n    return hp.atom_get_metatype(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom","title":"GroundedAtom","text":"<pre><code>GroundedAtom(catom)\n</code></pre> <p>               Bases: <code>Atom</code></p> <p>A GroundedAtom represents sub-symbolic knowledge. At the API level, it allows keeping data and behaviour inside an Atom. There are three aspects of a GroundedAtom which can be customized:</p> <pre><code>- the type of GroundedAtom is provided by the Atom itself;\n- the matching algorithm used by the Atom;\n- an Atom can be made executable, and used to apply sub-symbolic\n  operations to other Atoms as arguments.\n</code></pre> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize a GroundedAtom\"\"\"\n    super().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.get_grounded_type","title":"get_grounded_type","text":"<pre><code>get_grounded_type()\n</code></pre> <p>Retrieve the grounded type of the GroundedAtom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_grounded_type(self):\n    \"\"\"Retrieve the grounded type of the GroundedAtom.\"\"\"\n    return Atom._from_catom(hp.atom_get_grounded_type(self.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.get_metatype","title":"get_metatype","text":"<pre><code>get_metatype()\n</code></pre> <p>Gets the metatype (kind) of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_metatype(self):\n    \"\"\"Gets the metatype (kind) of the current Atom instance\"\"\"\n    return hp.atom_get_metatype(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.get_object","title":"get_object","text":"<pre><code>get_object()\n</code></pre> <p>Returns the GroundedAtom object, or the Space wrapped inside a GroundedAtom, or convert supported Rust grounded objects into corresponding ValueObjects. Function raises TypeError when grounded atom cannot be converted to Python object. Uncatched Python exception can lead to Rust panic in some contexts, for example when exception is thrown from atomspace query unification procedure. It is highly recommended to call get_object method inside try-except block to catch TypeError.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_object(self):\n    \"\"\"Returns the GroundedAtom object, or the Space wrapped inside a GroundedAtom,\n       or convert supported Rust grounded objects into corresponding ValueObjects.\n       Function raises TypeError when grounded atom cannot be converted to Python object. Uncatched\n       Python exception can lead to Rust panic in some contexts, for example when exception is thrown\n       from atomspace query unification procedure. It is highly recommended to call get_object method\n       inside try-except block to catch TypeError.\n    \"\"\"\n    # TODO: Here code assumes CGrounded object is always Python object.\n    # This is not true in general case. To make code universal we need to\n    # keep kind of the original runtime in CGrounded structure.\n    if hp.atom_is_cgrounded(self.catom):\n        return hp.atom_get_object(self.catom)\n    else:\n        return _priv_gnd_get_object(self)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedObject","title":"GroundedObject","text":"<pre><code>GroundedObject(content, id=None)\n</code></pre> <p>A GroundedObject holds some content and, optionally, an identifier.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, content, id=None):\n    \"\"\"Initializes a new GroundedObject with the given content and identifier.\"\"\"\n    self.content = content\n    self.id = id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        newstr = repr(self.content)[1:-1].translate(str.maketrans({'\"' : r'\\\"'}))\n        return f'\"{newstr}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.IncorrectArgumentError","title":"IncorrectArgumentError","text":"<p>               Bases: <code>Exception</code></p> <p>Argument is not recognized by function implementation. It can be argument of incorrect type or in incorrect format. Interpreter handles this error similarly to the situation when pure function definition is not matched.</p>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject","title":"MatchableObject","text":"<pre><code>MatchableObject(content, id=None)\n</code></pre> <p>               Bases: <code>ValueObject</code></p> <p>Represents an object that can be involved in a matching operation with an Atom.</p> <p>This class is meant to be subclassed by objects that define specific matching behavior with an Atom. It provides a stub method for the matching operation that raises a RuntimeError when called, which must be overridden by subclasses.</p> Inherits <p>ValueObject: The parent class that provides basic value-based equality and representation.</p> <p>Methods:</p> <ul> <li> <code>match_</code>             \u2013              <p>A stub method for matching the object with an Atom.</p> </li> </ul> Example <p>class MyMatchableObject(MatchableObject):     def match_(self, atom):         # Implement the matching logic here         pass</p> <p>my_obj = MyMatchableObject(\"some_value\") my_obj.match_(some_atom)  # Should not raise RuntimeError</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>Raised when the match_ method is called without being overridden by a subclass.</p> </li> </ul> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, content, id=None):\n    \"\"\"Initializes a new GroundedObject with the given content and identifier.\"\"\"\n    self.content = content\n    self.id = id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Gets the value of the object, which is its content.</p>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this ValueObject with another based on their content.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compares the equality of this ValueObject with another based on their content.\"\"\"\n    # TODO: We need to hook this up the the Value-Bridging mechanism when it's designed and built\n    # https://github.com/trueagi-io/hyperon-experimental/issues/351\n\n    # TODO: ?typecheck for the contents\n    return isinstance(other, ValueObject) and self.content == other.content\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        newstr = repr(self.content)[1:-1].translate(str.maketrans({'\"' : r'\\\"'}))\n        return f'\"{newstr}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.match_","title":"match_","text":"<pre><code>match_(atom)\n</code></pre> <p>A stub method for matching the object with an Atom.</p> <p>This method is intended to be overridden by subclasses to provide specific matching behavior with an Atom.</p> <p>Parameters:</p> <ul> <li> <code>atom</code>               (<code>Atom</code>)           \u2013            <p>An Atom object to match against.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>Raised when this method is called without being overridden in a subclass.</p> </li> </ul> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_(self, atom):\n    \"\"\"\n    A stub method for matching the object with an Atom.\n\n    This method is intended to be overridden by subclasses to provide specific\n    matching behavior with an Atom.\n\n    Parameters:\n        atom (Atom): An Atom object to match against.\n\n    Raises:\n        RuntimeError: Raised when this method is called without being overridden in a subclass.\n    \"\"\"\n    raise RuntimeError(\"MatchableObject::match_() is not implemented\")\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.serialize","title":"serialize","text":"<pre><code>serialize(serializer)\n</code></pre> <p>Serialize standard Python values. This implementation is used to pass Python values into the foreign runtime.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def serialize(self, serializer):\n    \"\"\"\n    Serialize standard Python values. This implementation is used to\n    pass Python values into the foreign runtime.\n    \"\"\"\n    if isinstance(self.content, bool):\n        return serializer.serialize_bool(self.content)\n    elif isinstance(self.content, int):\n        return serializer.serialize_int(self.content)\n    elif isinstance(self.content, float):\n        return serializer.serialize_float(self.content)\n    elif isinstance(self.content, str):\n        return serializer.serialize_str(self.content)\n    else:\n        return SerialResult.NOT_SUPPORTED\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MettaError","title":"MettaError","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception; raised when a error should be returned from OperationAtom, , but we don't want to output Python error stack.</p>"},{"location":"reference/atoms/#hyperon.atoms.NoReduceError","title":"NoReduceError","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception; raised when a reduction operation cannot be performed.</p>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject","title":"OperationObject","text":"<pre><code>OperationObject(name, op, unwrap=True)\n</code></pre> <p>               Bases: <code>GroundedObject</code></p> <p>An OperationObject represents an operation as a grounded object, allowing for more advanced logic like lazy evaluation, type-checking, and more.</p> Inherits <p>GroundedObject: The parent class that provides the basic wrapper around content.</p> <p>Attributes:</p> <ul> <li> <code>unwrap</code>               (<code>bool</code>)           \u2013            <p>Determines whether to unwrap the content of GroundedAtoms            when passed as arguments to the operation.</p> </li> </ul> Properties <p>op: Returns the operation function. name: Returns the identifier name for this operation object.</p> <p>Methods:</p> <ul> <li> <code>execute</code>             \u2013              <p>Executes the operation with the provided arguments.</p> </li> <li> <code>__eq__</code>             \u2013              <p>Compares the equality of this OperationObject instance with another.</p> </li> </ul> Example <p>def add(a, b):     return a + b</p> <p>op_obj = OperationObject(\"addition\", add) result = op_obj.execute(3, 4)</p> <p>Parameters:     name (str): The identifier for this operation.     op (function): The function representing the operation.     unwrap (bool, optional): Whether to unwrap GroundedAtom content when applying                              the operation. Defaults to True.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, name, op, unwrap=True):\n    \"\"\"\n    Initializes a new OperationObject with a name identifier, operation function,\n    and an optional unwrap flag.\n    Parameters:\n        name (str): The identifier for this operation.\n        op (function): The function representing the operation.\n        unwrap (bool, optional): Whether to unwrap GroundedAtom content when applying\n                                 the operation. Defaults to True.\n\n    \"\"\"\n    super().__init__(op, name)\n    self.unwrap = unwrap\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Returns the identifier name for this operation object.</p>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.op","title":"op  <code>property</code>","text":"<pre><code>op\n</code></pre> <p>Returns the operation function.</p>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this OperationObject with another based on their names.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OperationObject</code>)           \u2013            <p>Another OperationObject instance to compare.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>True if both OperationObjects have the same name; False otherwise.</p> </li> </ul> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Compares the equality of this OperationObject with another based on their names.\n\n    Parameters:\n        other (OperationObject): Another OperationObject instance to compare.\n\n    Returns:\n        True if both OperationObjects have the same name; False otherwise.\n    \"\"\"\n    return isinstance(other, OperationObject) and self.name == other.name\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        newstr = repr(self.content)[1:-1].translate(str.maketrans({'\"' : r'\\\"'}))\n        return f'\"{newstr}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.execute","title":"execute","text":"<pre><code>execute(*atoms, res_typ=AtomType.UNDEFINED)\n</code></pre> <p>Executes the operation with the provided arguments.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>           \u2013            <p>Arguments to pass to the operation function.</p> </li> <li> <code>res_typ</code>               (<code>AtomType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The expected result type. Defaults to AtomType.UNDEFINED.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>The result of the operation.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NoReduceError</code>             \u2013            <p>Raised when <code>unwrap=True</code> and a non-GroundedAtom argument is provided.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>Raised when the result of the operation is not a list.</p> </li> </ul> Note <p>Depending on the <code>unwrap</code> attribute, this method will either unwrap GroundedAtoms before passing them to the operation or pass them as is.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def execute(self, *atoms, res_typ=AtomType.UNDEFINED):\n    \"\"\"\n    Executes the operation with the provided arguments.\n\n    Parameters:\n        *args: Arguments to pass to the operation function.\n        res_typ (AtomType, optional): The expected result type. Defaults to AtomType.UNDEFINED.\n\n    Returns:\n        The result of the operation.\n\n    Raises:\n        NoReduceError: Raised when `unwrap=True` and a non-GroundedAtom argument is provided.\n        RuntimeError: Raised when the result of the operation is not a list.\n\n    Note:\n        Depending on the `unwrap` attribute, this method will either unwrap GroundedAtoms\n        before passing them to the operation or pass them as is.\n    \"\"\"\n    # type-check?\n    if self.unwrap:\n        args, kwargs = unwrap_args(atoms)\n        try:\n            result = self.op(*args, **kwargs)\n        except MettaError as e:\n            return [E(S('Error'), *e.args)]\n        if result is None:\n            return [Atoms.UNIT]\n        if callable(result):\n            return [OperationAtom(repr(result), result, unwrap=True)]\n        return [ValueAtom(result, res_typ)]\n    else:\n        result = self.op(*atoms)\n        try:\n            iter(result)\n        except TypeError:\n            raise RuntimeError(\"Grounded operation `\" + self.name + \"` should return list\")\n        return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom","title":"SymbolAtom","text":"<pre><code>SymbolAtom(catom)\n</code></pre> <p>               Bases: <code>Atom</code></p> <p>A SymbolAtom represents a single concept, identified by name. If two symbols have the same name, they reference the same concept.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize a SymbolAtom\"\"\"\n    super().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.get_metatype","title":"get_metatype","text":"<pre><code>get_metatype()\n</code></pre> <p>Gets the metatype (kind) of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_metatype(self):\n    \"\"\"Gets the metatype (kind) of the current Atom instance\"\"\"\n    return hp.atom_get_metatype(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.get_name","title":"get_name","text":"<pre><code>get_name()\n</code></pre> <p>Returns the name of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_name(self):\n    \"\"\"Returns the name of the Atom.\"\"\"\n    return hp.atom_get_name(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject","title":"ValueObject","text":"<pre><code>ValueObject(content, id=None)\n</code></pre> <p>               Bases: <code>GroundedObject</code></p> <p>A ValueObject is a specialized form of GroundedObject, which treats its content as a value. It allows for equality comparison between the content of two ValueObjects.</p> Example <p>obj1 = ValueObject(5) obj2 = ValueObject(5) obj3 = ValueObject(6)</p> <p>print(obj1 == obj2)  # True print(obj1 == obj3)  # False</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, content, id=None):\n    \"\"\"Initializes a new GroundedObject with the given content and identifier.\"\"\"\n    self.content = content\n    self.id = id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Gets the value of the object, which is its content.</p>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this ValueObject with another based on their content.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compares the equality of this ValueObject with another based on their content.\"\"\"\n    # TODO: We need to hook this up the the Value-Bridging mechanism when it's designed and built\n    # https://github.com/trueagi-io/hyperon-experimental/issues/351\n\n    # TODO: ?typecheck for the contents\n    return isinstance(other, ValueObject) and self.content == other.content\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        newstr = repr(self.content)[1:-1].translate(str.maketrans({'\"' : r'\\\"'}))\n        return f'\"{newstr}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.serialize","title":"serialize","text":"<pre><code>serialize(serializer)\n</code></pre> <p>Serialize standard Python values. This implementation is used to pass Python values into the foreign runtime.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def serialize(self, serializer):\n    \"\"\"\n    Serialize standard Python values. This implementation is used to\n    pass Python values into the foreign runtime.\n    \"\"\"\n    if isinstance(self.content, bool):\n        return serializer.serialize_bool(self.content)\n    elif isinstance(self.content, int):\n        return serializer.serialize_int(self.content)\n    elif isinstance(self.content, float):\n        return serializer.serialize_float(self.content)\n    elif isinstance(self.content, str):\n        return serializer.serialize_str(self.content)\n    else:\n        return SerialResult.NOT_SUPPORTED\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom","title":"VariableAtom","text":"<pre><code>VariableAtom(catom)\n</code></pre> <p>               Bases: <code>Atom</code></p> <p>A VariableAtom represents a variable in an expression. It serves as a placeholder that can be matched with, or bound to other Atoms.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize a VariableAtom\"\"\"\n    super().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.get_metatype","title":"get_metatype","text":"<pre><code>get_metatype()\n</code></pre> <p>Gets the metatype (kind) of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_metatype(self):\n    \"\"\"Gets the metatype (kind) of the current Atom instance\"\"\"\n    return hp.atom_get_metatype(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.get_name","title":"get_name","text":"<pre><code>get_name()\n</code></pre> <p>Returns the name of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_name(self):\n    \"\"\"Returns the name of the Atom.\"\"\"\n    return hp.atom_get_name(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.parse_name","title":"parse_name  <code>staticmethod</code>","text":"<pre><code>parse_name(name)\n</code></pre> <p>Construct new VariableAtom instance from VariableAtom.get_name() method results.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>@staticmethod\ndef parse_name(name):\n    \"\"\"Construct new VariableAtom instance from VariableAtom.get_name()\n    method results.\"\"\"\n    return VariableAtom(hp.atom_var_parse_name(name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.E","title":"E","text":"<pre><code>E(*args)\n</code></pre> <p>A convenient method to construct an ExpressionAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def E(*args):\n    \"\"\"A convenient method to construct an ExpressionAtom\"\"\"\n    return ExpressionAtom(hp.atom_expr([atom.catom for atom in args]))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.G","title":"G","text":"<pre><code>G(object, type=AtomType.UNDEFINED)\n</code></pre> <p>A convenient method to construct a GroundedAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def G(object, type=AtomType.UNDEFINED):\n    \"\"\"A convenient method to construct a GroundedAtom\"\"\"\n    return GroundedAtom(_priv_atom_gnd(object, type))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableAtom","title":"MatchableAtom","text":"<pre><code>MatchableAtom(value, type_name=None, atom_id=None)\n</code></pre> <p>Creates a Grounded Atom that wraps a matchable value, optionally specifying its type and identifier.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def MatchableAtom(value, type_name=None, atom_id=None):\n    \"\"\"\n    Creates a Grounded Atom that wraps a matchable value, optionally specifying its type and identifier.\n    \"\"\"\n    return G(MatchableObject(value, atom_id), _type_sugar(type_name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationAtom","title":"OperationAtom","text":"<pre><code>OperationAtom(name, op, type_names=None, unwrap=True)\n</code></pre> <p>An OperationAtom wraps an operation with optional type information into a GroundedAtom and associates a name with it. Useful for registering custom operations that can be executed in an Atom-based computational environment.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def OperationAtom(name, op, type_names=None, unwrap=True):\n    \"\"\"\n    An OperationAtom wraps an operation with optional type information into a GroundedAtom\n    and associates a name with it. Useful for registering custom operations\n    that can be executed in an Atom-based computational environment.\n    \"\"\"\n    return G(OperationObject(name, op, unwrap), _type_sugar(type_names))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.PrimitiveAtom","title":"PrimitiveAtom","text":"<pre><code>PrimitiveAtom(value, type_name=None, atom_id=None)\n</code></pre> <p>Creates a GroundedAtom that wraps a given Python primitive value without converting it into the MeTTa primitive. By default ValueAtom function converts Python primitives into MeTTa ones. This function is added to override this rule if needed.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def PrimitiveAtom(value, type_name=None, atom_id=None):\n    \"\"\"\n    Creates a GroundedAtom that wraps a given Python primitive value without\n    converting it into the MeTTa primitive. By default ValueAtom function\n    converts Python primitives into MeTTa ones. This function is added to\n    override this rule if needed.\n    \"\"\"\n    PRIMITIVE_TYPES = (int, float, bool)\n    assert isinstance(value, PRIMITIVE_TYPES), f\"Primitive value {PRIMITIVE_TYPES} is expected\"\n    type = _type_sugar(type_name)\n    return GroundedAtom(hp.atom_py(ValueObject(value, atom_id), type.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.S","title":"S","text":"<pre><code>S(name)\n</code></pre> <p>A convenient method to construct a SymbolAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def S(name):\n    \"\"\"A convenient method to construct a SymbolAtom\"\"\"\n    return SymbolAtom(hp.atom_sym(name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.V","title":"V","text":"<pre><code>V(name)\n</code></pre> <p>A convenient method to construct a VariableAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def V(name):\n    \"\"\"A convenient method to construct a VariableAtom\"\"\"\n    return VariableAtom(hp.atom_var(name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueAtom","title":"ValueAtom","text":"<pre><code>ValueAtom(value, type_name=None, atom_id=None)\n</code></pre> <p>Creates a GroundedAtom that wraps a given value, optionally specifying its type and identifier. It has special processing for the objects which have cspace attribute and for ValueObject instances of primitive types. Spaces usually should be treated by a special way. Primitive atoms are converted into the MeTTa primitives.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def ValueAtom(value, type_name=None, atom_id=None):\n    \"\"\"\n    Creates a GroundedAtom that wraps a given value, optionally specifying its\n    type and identifier. It has special processing for the objects which have\n    cspace attribute and for ValueObject instances of primitive types. Spaces\n    usually should be treated by a special way. Primitive atoms are converted\n    into the MeTTa primitives.\n    \"\"\"\n    return G(ValueObject(value, atom_id), _type_sugar(type_name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.atoms_are_equivalent","title":"atoms_are_equivalent","text":"<pre><code>atoms_are_equivalent(first, second)\n</code></pre> <p>Check if two atoms are equivalent</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def atoms_are_equivalent(first, second):\n    \"\"\"Check if two atoms are equivalent\"\"\"\n    return hp.atoms_are_equivalent(first.catom, second.catom)\n</code></pre>"},{"location":"reference/base/","title":"Base","text":""},{"location":"reference/base/#hyperon.base","title":"base","text":""},{"location":"reference/base/#hyperon.base.AbstractSpace","title":"AbstractSpace","text":"<pre><code>AbstractSpace()\n</code></pre> <p>A virtual base class upon which Spaces can be implemented in Python</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialiize the AbstractSpace. Does nothing in the base class\"\"\"\n    return\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.add","title":"add","text":"<pre><code>add(atom)\n</code></pre> <p>Adds an Atom to the atom space. Must be implemented in derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add(self, atom):\n    \"\"\"\n    Adds an Atom to the atom space. Must be implemented in derived classes.\n    \"\"\"\n    raise RuntimeError(\"Space::add() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Counts the number of atoms in the atom space. Optional for derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n    \"\"\"\n    Counts the number of atoms in the atom space. Optional for derived classes.\n    \"\"\"\n    None\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.atoms_iter","title":"atoms_iter","text":"<pre><code>atoms_iter()\n</code></pre> <p>Returns an iterator over atoms in the Space. Optional for derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atoms_iter(self):\n    \"\"\"\n    Returns an iterator over atoms in the Space. Optional for derived classes.\n    \"\"\"\n    None\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.query","title":"query","text":"<pre><code>query(query_atom)\n</code></pre> <p>Performs the specified query on the Space. Should be overridden to return a BindingsSet as the result of the query.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, query_atom):\n    \"\"\"\n    Performs the specified query on the Space.\n    Should be overridden to return a BindingsSet as the result of the query.\n    \"\"\"\n    raise RuntimeError(\"Space::query() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.remove","title":"remove","text":"<pre><code>remove(atom)\n</code></pre> <p>Removes an Atom from the atom space. Must be implemented in derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove(self, atom):\n    \"\"\"\n    Removes an Atom from the atom space. Must be implemented in derived classes.\n    \"\"\"\n    raise RuntimeError(\"Space::remove() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.replace","title":"replace","text":"<pre><code>replace(atom, replacement)\n</code></pre> <p>Replaces an Atom from the atom space. Must be implemented in derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace(self, atom, replacement):\n    \"\"\"\n    Replaces an Atom from the atom space. Must be implemented in derived classes.\n    \"\"\"\n    raise RuntimeError(\"Space::replace() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace","title":"GroundingSpace","text":"<pre><code>GroundingSpace()\n</code></pre> <p>               Bases: <code>AbstractSpace</code></p> <p>A wrapper over the native GroundingSpace implementation, which can be subclassed and extended within Python</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize GroundingSpace and its underlying native implementation.\"\"\"\n    super().__init__()\n    # self.cspace = hp.space_new_grounding()\n    self.gspace = GroundingSpaceRef()\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.add","title":"add","text":"<pre><code>add(atom)\n</code></pre> <p>Adds an Atom to the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add(self, atom):\n    \"\"\"\n    Adds an Atom to the atom space.\n    \"\"\"\n    self.gspace.add_atom(atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Counts the number of Atoms in the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n    \"\"\"\n    Counts the number of Atoms in the atom space.\n    \"\"\"\n    return self.gspace.atom_count()\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.atoms_iter","title":"atoms_iter","text":"<pre><code>atoms_iter()\n</code></pre> <p>Returns an iterator over atoms in the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atoms_iter(self):\n    \"\"\"\n    Returns an iterator over atoms in the atom space.\n    \"\"\"\n    return iter(self.gspace.get_atoms())\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.query","title":"query","text":"<pre><code>query(query_atom)\n</code></pre> <p>Delegates the query to the underlying native GroundingSpace and returns the result BindingsSet</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, query_atom):\n    \"\"\"\n    Delegates the query to the underlying native GroundingSpace\n    and returns the result BindingsSet\n    \"\"\"\n    return self.gspace.query(query_atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.remove","title":"remove","text":"<pre><code>remove(atom)\n</code></pre> <p>Removes an Atom from the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove(self, atom):\n    \"\"\"\n    Removes an Atom from the atom space.\n    \"\"\"\n    return self.gspace.remove_atom(atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.replace","title":"replace","text":"<pre><code>replace(from_atom, to_atom)\n</code></pre> <p>Replaces an Atom in the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace(self, from_atom, to_atom):\n    \"\"\"\n    Replaces an Atom in the atom space.\n    \"\"\"\n    return self.gspace.replace_atom(from_atom, to_atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef","title":"GroundingSpaceRef","text":"<pre><code>GroundingSpaceRef(cspace=None)\n</code></pre> <p>               Bases: <code>SpaceRef</code></p> <p>A reference to a native GroundingSpace, implemented by the MeTTa core library.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, cspace = None):\n    \"\"\"\n    Initialize a new GroundingSpaceRef.\n    If a CSpace object is provided, use it; otherwise create a new GroundingSpace.\n    \"\"\"\n    if cspace is None:\n        self.cspace = hp.space_new_grounding()\n    else:\n        self.cspace = cspace\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Free the underlying CSpace object</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n    \"\"\"Free the underlying CSpace object \"\"\"\n    hp.space_free(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compare two SpaceRef objects for equality, based on their underlying spaces.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compare two SpaceRef objects for equality, based on their underlying spaces.\"\"\"\n    return hp.space_eq(self.cspace, other.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.add_atom","title":"add_atom","text":"<pre><code>add_atom(atom)\n</code></pre> <p>Add an Atom to the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add_atom(self, atom):\n    \"\"\"\n    Add an Atom to the Space.\n    \"\"\"\n    hp.space_add(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n    \"\"\"\n    Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.\n    \"\"\"\n    return hp.space_atom_count(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a new copy of the SpaceRef, referencing the same underlying Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a new copy of the SpaceRef, referencing the same underlying Space.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.get_atoms","title":"get_atoms","text":"<pre><code>get_atoms()\n</code></pre> <p>Returns a list of all Atoms in the Space, or None if that is impossible.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_atoms(self):\n    \"\"\"\n    Returns a list of all Atoms in the Space, or None if that is impossible.\n    \"\"\"\n    res = hp.space_list(self.cspace)\n    if res == None:\n        return None\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Returns the Space object referenced by the SpaceRef, or None if the object does not have a direct Python interface.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_payload(self):\n    \"\"\"\n    Returns the Space object referenced by the SpaceRef, or None if the object does not have a\n    direct Python interface.\n    \"\"\"\n    return hp.space_get_payload(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.query","title":"query","text":"<pre><code>query(pattern)\n</code></pre> <p>Performs the specified query on the Space, and returns the result as a BindingsSet.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, pattern):\n    \"\"\"\n    Performs the specified query on the Space, and returns the result as a BindingsSet.\n    \"\"\"\n    result = hp.space_query(self.cspace, pattern.catom)\n    return BindingsSet(result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.remove_atom","title":"remove_atom","text":"<pre><code>remove_atom(atom)\n</code></pre> <p>Delete the specified Atom from the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove_atom(self, atom):\n    \"\"\"\n    Delete the specified Atom from the Space.\n    \"\"\"\n    return hp.space_remove(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.replace_atom","title":"replace_atom","text":"<pre><code>replace_atom(atom, replacement)\n</code></pre> <p>Replaces the specified Atom, if it exists in the Space, with the supplied replacement.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace_atom(self, atom, replacement):\n    \"\"\"\n    Replaces the specified Atom, if it exists in the Space, with the supplied replacement.\n    \"\"\"\n    return hp.space_replace(self.cspace, atom.catom, replacement.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.subst","title":"subst","text":"<pre><code>subst(pattern, templ)\n</code></pre> <p>Performs a substitution within the Space, based on a pattern and a template.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def subst(self, pattern, templ):\n    \"\"\"\n    Performs a substitution within the Space, based on a pattern and a template.\n    \"\"\"\n    return [Atom._from_catom(catom) for catom in\n            hp.space_subst(self.cspace, pattern.catom,\n                                     templ.catom)]\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter","title":"Interpreter","text":"<pre><code>Interpreter(gnd_space, expr)\n</code></pre> <p>A wrapper class for the MeTTa interpreter that handles the interpretation of expressions in a given grounding space.</p> <p>NOTE: This is a low-level API, and most applications would be better served by a <code>MeTTa</code> runner object</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, gnd_space, expr):\n    \"\"\"\n    Initializes the interpreter with the given grounding space and expression.\n    \"\"\"\n    self.step_result = hp.interpret_init(gnd_space.cspace, expr.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.get_result","title":"get_result","text":"<pre><code>get_result()\n</code></pre> <p>Retrieves the final outcome of the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_result(self):\n    \"\"\"\n    Retrieves the final outcome of the interpretation plan.\n    \"\"\"\n    if self.has_next():\n        raise RuntimeError(\"Plan execution is not finished\")\n    return hp.step_get_result(self.step_result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.get_step_result","title":"get_step_result","text":"<pre><code>get_step_result()\n</code></pre> <p>Gets the current result of the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_step_result(self):\n    \"\"\"\n    Gets the current result of the interpretation plan.\n    \"\"\"\n    return self.step_result\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.has_next","title":"has_next","text":"<pre><code>has_next()\n</code></pre> <p>Checks if there are more steps to execute in the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def has_next(self):\n    \"\"\"\n    Checks if there are more steps to execute in the interpretation plan.\n    \"\"\"\n    return hp.step_has_next(self.step_result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.next","title":"next","text":"<pre><code>next()\n</code></pre> <p>Executes the next step in the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def next(self):\n    \"\"\"\n    Executes the next step in the interpretation plan.\n    \"\"\"\n    if not self.has_next():\n        raise StopIteration()\n    self.step_result = hp.interpret_step(self.step_result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SExprParser","title":"SExprParser","text":"<pre><code>SExprParser(text)\n</code></pre> <p>A class responsible for parsing S-expressions (Symbolic Expressions). This class wraps around a SExprParser object from the core library.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, text):\n    \"\"\"Initialize a new SExprParser object.\"\"\"\n    self.cparser = hp.CSExprParser(text)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SExprParser.parse","title":"parse","text":"<pre><code>parse(tokenizer)\n</code></pre> <p>Parses the S-expression using the provided Tokenizer.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def parse(self, tokenizer):\n    \"\"\"\n    Parses the S-expression using the provided Tokenizer.\n    \"\"\"\n    catom = self.cparser.parse(tokenizer.ctokenizer)\n    if (catom is None):\n        err_str = self.cparser.sexpr_parser_err_str()\n        if (err_str is None):\n            return None\n        else:\n            raise SyntaxError(err_str)\n    else:\n        return Atom._from_catom(catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SExprParser.parse_to_syntax_tree","title":"parse_to_syntax_tree","text":"<pre><code>parse_to_syntax_tree()\n</code></pre> <p>Parses the S-expression into a SyntaxNode representing the top-level of a syntax tree.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def parse_to_syntax_tree(self):\n    \"\"\"\n    Parses the S-expression into a SyntaxNode representing the top-level of a syntax tree.\n    \"\"\"\n    cnode = self.cparser.parse_to_syntax_tree()\n    return SyntaxNode(cnode) if cnode is not None else None\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef","title":"SpaceRef","text":"<pre><code>SpaceRef(space_obj)\n</code></pre> <p>A reference to a Space, which may be accessed directly, wrapped in a grounded atom, or passed to a MeTTa interpreter.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, space_obj):\n    \"\"\"\n    Initialize a new SpaceRef based on the given space object, either a CSpace \n    or a custom Python object.\n    \"\"\"\n    if type(space_obj) is hp.CSpace:\n        self.cspace = space_obj\n    else:\n        self.cspace = hp.space_new_custom(space_obj)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Free the underlying CSpace object</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n    \"\"\"Free the underlying CSpace object \"\"\"\n    hp.space_free(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compare two SpaceRef objects for equality, based on their underlying spaces.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compare two SpaceRef objects for equality, based on their underlying spaces.\"\"\"\n    return hp.space_eq(self.cspace, other.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.add_atom","title":"add_atom","text":"<pre><code>add_atom(atom)\n</code></pre> <p>Add an Atom to the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add_atom(self, atom):\n    \"\"\"\n    Add an Atom to the Space.\n    \"\"\"\n    hp.space_add(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n    \"\"\"\n    Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.\n    \"\"\"\n    return hp.space_atom_count(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a new copy of the SpaceRef, referencing the same underlying Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a new copy of the SpaceRef, referencing the same underlying Space.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.get_atoms","title":"get_atoms","text":"<pre><code>get_atoms()\n</code></pre> <p>Returns a list of all Atoms in the Space, or None if that is impossible.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_atoms(self):\n    \"\"\"\n    Returns a list of all Atoms in the Space, or None if that is impossible.\n    \"\"\"\n    res = hp.space_list(self.cspace)\n    if res == None:\n        return None\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Returns the Space object referenced by the SpaceRef, or None if the object does not have a direct Python interface.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_payload(self):\n    \"\"\"\n    Returns the Space object referenced by the SpaceRef, or None if the object does not have a\n    direct Python interface.\n    \"\"\"\n    return hp.space_get_payload(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.query","title":"query","text":"<pre><code>query(pattern)\n</code></pre> <p>Performs the specified query on the Space, and returns the result as a BindingsSet.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, pattern):\n    \"\"\"\n    Performs the specified query on the Space, and returns the result as a BindingsSet.\n    \"\"\"\n    result = hp.space_query(self.cspace, pattern.catom)\n    return BindingsSet(result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.remove_atom","title":"remove_atom","text":"<pre><code>remove_atom(atom)\n</code></pre> <p>Delete the specified Atom from the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove_atom(self, atom):\n    \"\"\"\n    Delete the specified Atom from the Space.\n    \"\"\"\n    return hp.space_remove(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.replace_atom","title":"replace_atom","text":"<pre><code>replace_atom(atom, replacement)\n</code></pre> <p>Replaces the specified Atom, if it exists in the Space, with the supplied replacement.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace_atom(self, atom, replacement):\n    \"\"\"\n    Replaces the specified Atom, if it exists in the Space, with the supplied replacement.\n    \"\"\"\n    return hp.space_replace(self.cspace, atom.catom, replacement.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.subst","title":"subst","text":"<pre><code>subst(pattern, templ)\n</code></pre> <p>Performs a substitution within the Space, based on a pattern and a template.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def subst(self, pattern, templ):\n    \"\"\"\n    Performs a substitution within the Space, based on a pattern and a template.\n    \"\"\"\n    return [Atom._from_catom(catom) for catom in\n            hp.space_subst(self.cspace, pattern.catom,\n                                     templ.catom)]\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode","title":"SyntaxNode","text":"<pre><code>SyntaxNode(cnode)\n</code></pre> <p>A class representing a node in a parsed syntax tree</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, cnode):\n    \"\"\"\n    Initialize a new Tokenizer.\n    \"\"\"\n    self.cnode = cnode\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Destructor for the SyntaxNode</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n    \"\"\"\n    Destructor for the SyntaxNode\n    \"\"\"\n    hp.syntax_node_free(self.cnode)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Returns the type of a SyntaxNode</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_type(self):\n    \"\"\"\n    Returns the type of a SyntaxNode\n    \"\"\"\n    return hp.syntax_node_type(self.cnode)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode.src_range","title":"src_range","text":"<pre><code>src_range()\n</code></pre> <p>Returns the range of offsets into the source code of the text represented by the SyntaxNode</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def src_range(self):\n    \"\"\"\n    Returns the range of offsets into the source code of the text represented by the SyntaxNode\n    \"\"\"\n    range_tuple = hp.syntax_node_src_range(self.cnode)\n    return range(range_tuple[0], range_tuple[1])\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode.unroll","title":"unroll","text":"<pre><code>unroll()\n</code></pre> <p>Returns a list of all leaf nodes recursively contained within a SyntaxNode</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def unroll(self):\n    \"\"\"\n    Returns a list of all leaf nodes recursively contained within a SyntaxNode\n    \"\"\"\n    syntax_nodes = []\n    for cnode in hp.syntax_node_unroll(self.cnode):\n        syntax_nodes.append(SyntaxNode(cnode))\n    return syntax_nodes\n</code></pre>"},{"location":"reference/base/#hyperon.base.Tokenizer","title":"Tokenizer","text":"<pre><code>Tokenizer(ctokenizer=None)\n</code></pre> <p>A class responsible for text tokenization in the context of Hyperon. This class wraps around a Tokenizer object from the core library.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, ctokenizer = None):\n    \"\"\"\n    Initialize a new Tokenizer.\n    \"\"\"\n    if ctokenizer is None:\n        self.ctokenizer = hp.tokenizer_new()\n    else:\n        self.ctokenizer = ctokenizer\n</code></pre>"},{"location":"reference/base/#hyperon.base.Tokenizer.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Destructor that frees the underlying resources when the Tokenizer instance is destroyed.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n    \"\"\"\n    Destructor that frees the underlying resources when the Tokenizer instance is destroyed.\n    \"\"\"\n    hp.tokenizer_free(self.ctokenizer)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Tokenizer.register_token","title":"register_token","text":"<pre><code>register_token(regex, constr)\n</code></pre> <p>Registers a new custom Token in the Tokenizer based on a regular expression.</p> <p>Parameters:</p> <p>regex:     A string representing the regular expression to match incoming text.     Hyperon uses the Rust RegEx engine and syntax. constr:     A constructor function for generating a new atom when the regex is triggered.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def register_token(self, regex, constr):\n    \"\"\"\n    Registers a new custom Token in the Tokenizer based on a regular expression.\n\n    Parameters:\n    ----------\n    regex:\n       A string representing the regular expression to match incoming text.\n       Hyperon uses the Rust RegEx engine and syntax.\n   constr:\n       A constructor function for generating a new atom when the regex is triggered.\n   \"\"\"\n    hp.tokenizer_register_token(self.ctokenizer, regex, constr)\n</code></pre>"},{"location":"reference/base/#hyperon.base.atom_is_error","title":"atom_is_error","text":"<pre><code>atom_is_error(atom)\n</code></pre> <p>Checks whether an Atom is an error expression</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_is_error(atom):\n    \"\"\"Checks whether an Atom is an error expression\"\"\"\n    return hp.atom_is_error(atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.check_type","title":"check_type","text":"<pre><code>check_type(gnd_space, atom, type)\n</code></pre> <p>Checks whether the given Atom has the specified type in the given space context.</p>"},{"location":"reference/base/#hyperon.base.check_type--parameters","title":"Parameters","text":"<p>gnd_space:     A pointer to the space_t representing the space context in which to perform     the check atom:     A pointer to the atom_t or atom_ref_t representing the atom whose Type the     function will check type:     A pointer to the atom_t or atom_ref_t representing the type to check against</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def check_type(gnd_space, atom, type):\n    \"\"\"\n    Checks whether the given Atom has the specified type in the given space context.\n\n    Parameters\n    ----------\n    gnd_space:\n        A pointer to the space_t representing the space context in which to perform\n        the check\n    atom:\n        A pointer to the atom_t or atom_ref_t representing the atom whose Type the\n        function will check\n    type:\n        A pointer to the atom_t or atom_ref_t representing the type to check against\n    \"\"\"\n\n    return hp.check_type(gnd_space.cspace, atom.catom, type.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.get_atom_types","title":"get_atom_types","text":"<pre><code>get_atom_types(gnd_space, atom)\n</code></pre> <p>Provides all types for the given Atom in the context of the given Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_atom_types(gnd_space, atom):\n    \"\"\"Provides all types for the given Atom in the context of the given Space.\"\"\"\n    result = hp.get_atom_types(gnd_space.cspace, atom.catom)\n    return [Atom._from_catom(catom) for catom in result]\n</code></pre>"},{"location":"reference/base/#hyperon.base.interpret","title":"interpret","text":"<pre><code>interpret(gnd_space, expr)\n</code></pre> <p>Parses the given expression in the specified grounding space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def interpret(gnd_space, expr):\n    \"\"\"\n    Parses the given expression in the specified grounding space.\n    \"\"\"\n    interpreter = Interpreter(gnd_space, expr)\n    while interpreter.has_next():\n        interpreter.next()\n    return [Atom._from_catom(catom) for catom in interpreter.get_result()]\n</code></pre>"},{"location":"reference/base/#hyperon.base.validate_atom","title":"validate_atom","text":"<pre><code>validate_atom(gnd_space, atom)\n</code></pre> <p>Checks whether the given Atom is correctly typed.</p>"},{"location":"reference/base/#hyperon.base.validate_atom--parameters","title":"Parameters","text":"<p>gnd_space:     A pointer to the space_t representing the space context in which to perform     the check atom:     A pointer to the atom_t or atom_ref_t representing the atom whose Type the     function will check</p>"},{"location":"reference/base/#hyperon.base.validate_atom--returns","title":"Returns","text":"<p>True if the Atom is correctly typed, otherwise false</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def validate_atom(gnd_space, atom):\n    \"\"\"\n    Checks whether the given Atom is correctly typed.\n\n    Parameters\n    ----------\n    gnd_space:\n        A pointer to the space_t representing the space context in which to perform\n        the check\n    atom:\n        A pointer to the atom_t or atom_ref_t representing the atom whose Type the\n        function will check\n\n    Returns\n    -------\n    True if the Atom is correctly typed, otherwise false\n    \"\"\"\n    return hp.validate_atom(gnd_space.cspace, atom.catom)\n</code></pre>"},{"location":"reference/conversion/","title":"Conversion","text":""},{"location":"reference/conversion/#hyperon.conversion","title":"conversion","text":""},{"location":"reference/conversion/#hyperon.conversion.ConvertingSerializer","title":"ConvertingSerializer","text":"<pre><code>ConvertingSerializer()\n</code></pre> <p>               Bases: <code>Serializer</code></p> <p>A serializer to convert value from other runtime into a Python value</p> Source code in <code>python/hyperon/conversion.py</code> <pre><code>def __init__(self):\n    \"\"\"Construct new serializer\"\"\"\n    super().__init__()\n    self.value = None\n</code></pre>"},{"location":"reference/conversion/#hyperon.conversion.ConvertingSerializer.serialize_bool","title":"serialize_bool","text":"<pre><code>serialize_bool(v)\n</code></pre> <p>Accept bool value</p> Source code in <code>python/hyperon/conversion.py</code> <pre><code>def serialize_bool(self, v):\n    \"\"\"Accept bool value\"\"\"\n    self.value = v\n    return SerialResult.OK\n</code></pre>"},{"location":"reference/conversion/#hyperon.conversion.ConvertingSerializer.serialize_float","title":"serialize_float","text":"<pre><code>serialize_float(v)\n</code></pre> <p>Accept float value</p> Source code in <code>python/hyperon/conversion.py</code> <pre><code>def serialize_float(self, v):\n    \"\"\"Accept float value\"\"\"\n    self.value = v\n    return SerialResult.OK\n</code></pre>"},{"location":"reference/conversion/#hyperon.conversion.ConvertingSerializer.serialize_int","title":"serialize_int","text":"<pre><code>serialize_int(v)\n</code></pre> <p>Accept int value</p> Source code in <code>python/hyperon/conversion.py</code> <pre><code>def serialize_int(self, v):\n    \"\"\"Accept int value\"\"\"\n    self.value = v\n    return SerialResult.OK\n</code></pre>"},{"location":"reference/conversion/#hyperon.conversion.ConvertingSerializer.serialize_str","title":"serialize_str","text":"<pre><code>serialize_str(v)\n</code></pre> <p>Accept float value</p> Source code in <code>python/hyperon/conversion.py</code> <pre><code>def serialize_str(self, v):\n    \"\"\"Accept float value\"\"\"\n    self.value = v\n    return SerialResult.OK\n</code></pre>"},{"location":"reference/ext/","title":"Ext","text":""},{"location":"reference/ext/#hyperon.ext","title":"ext","text":""},{"location":"reference/ext/#hyperon.ext.grounded","title":"grounded","text":"<pre><code>grounded(arg)\n</code></pre> <p>Function decorator which registers a purely Python grounded function using its name as a token and unwrap=True. There are two ways of using this decorator:   - @grounded without arguments and parentheses in extensions   - @grounded(metta), where metta is a MeTTa instance, within Python scripts Note that MeTTa object is passed to the decorator - not to the grounded function, and @grounded creates an atom out of the function itself (which differs from register_atoms, which decorates a function returning mappings from tokens to atoms)</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def grounded(arg):\n    \"\"\"Function decorator which registers a purely Python grounded function\n    using its name as a token and unwrap=True.\n    There are two ways of using this decorator:\n      - @grounded without arguments and parentheses in extensions\n      - @grounded(metta), where metta is a MeTTa instance, within Python scripts\n    Note that MeTTa object is passed to the decorator - not to the grounded function,\n    and @grounded creates an atom out of the function itself (which differs from\n    register_atoms, which decorates a function returning mappings from tokens to atoms)\n    \"\"\"\n    if callable(arg):\n        return _register_grounded(None, arg)\n    else:\n        return lambda func: _register_grounded(arg, func)\n</code></pre>"},{"location":"reference/ext/#hyperon.ext.mark_register_function","title":"mark_register_function","text":"<pre><code>mark_register_function(type, args, kwargs)\n</code></pre> <p>Mark function as function which registers MeTTa atoms or tokens. The following attributes are added to the decorated function:   - metta_type - value of the 'type' parameter   - metta_pass_metta - value of <code>pass_metta</code> parameter</p>"},{"location":"reference/ext/#hyperon.ext.mark_register_function--parameters","title":"Parameters","text":"<p>type:     Kind of the register function:     RegisterType.TOKEN if function register tokens;     RegisterType.ATOM if it register atoms. args:     args passed to decorator. If no argument are used in decorator then     this list contains only function to be decorated. If decorator has     some arguments then this list doesn't contain function and keeps     decorator arguments instead. kwargs:     kwargs passed to decorator. If arguments are used in decorator then     it contains named arguments otherwise it is empty.</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def mark_register_function(type, args, kwargs):\n    \"\"\"Mark function as function which registers MeTTa atoms or tokens.\n    The following attributes are added to the decorated function:\n      - metta_type - value of the 'type' parameter\n      - metta_pass_metta - value of `pass_metta` parameter\n\n    Parameters\n    ----------\n    type:\n        Kind of the register function:\n        RegisterType.TOKEN if function register tokens;\n        RegisterType.ATOM if it register atoms.\n    args:\n        args passed to decorator. If no argument are used in decorator then\n        this list contains only function to be decorated. If decorator has\n        some arguments then this list doesn't contain function and keeps\n        decorator arguments instead.\n    kwargs:\n        kwargs passed to decorator. If arguments are used in decorator then\n        it contains named arguments otherwise it is empty.\n    \"\"\"\n    # Case 1: Decorator used without arguments (i.e., @decorator instead of @decorator(args))\n    if len(args) == 1 and len(kwargs) == 0 and callable(args[0]):\n        func = args[0]\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            return func(*args, **kwargs)\n\n        wrapper.__dict__['metta_type'] = type\n        wrapper.__dict__['metta_pass_metta'] = False\n\n        return wrapper\n    # Case 2: Decorator used with arguments (i.e., @decorator(args))\n    else:\n        pass_metta = kwargs.get('pass_metta', False)\n\n        def no_args_decorator(func):\n\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n                return func(*args, **kwargs)\n\n            wrapper.__dict__['metta_type'] = type\n            wrapper.__dict__['metta_pass_metta'] = pass_metta\n\n            return wrapper\n\n        return no_args_decorator\n</code></pre>"},{"location":"reference/ext/#hyperon.ext.register_atoms","title":"register_atoms","text":"<pre><code>register_atoms(*args, **kwargs)\n</code></pre> <p>Function decorator which registers returned pairs of regular expressions and atoms in a Tokenizer using the RunContext.register_atom() method.</p>"},{"location":"reference/ext/#hyperon.ext.register_atoms--parameters","title":"Parameters","text":"<p>pass_metta:     Pass instance of MeTTa class to the decorated function as an argument.     Default is False.</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def register_atoms(*args, **kwargs):\n    \"\"\"Function decorator which registers returned pairs of regular expressions\n    and atoms in a Tokenizer using the RunContext.register_atom() method.\n\n    Parameters\n    ----------\n    pass_metta:\n        Pass instance of MeTTa class to the decorated function as an argument.\n        Default is False.\n    \"\"\"\n    return mark_register_function(RegisterType.ATOM, args, kwargs)\n</code></pre>"},{"location":"reference/ext/#hyperon.ext.register_tokens","title":"register_tokens","text":"<pre><code>register_tokens(*args, **kwargs)\n</code></pre> <p>Function decorator which registers returned pairs of regular expressions and lambdas in a Tokenizer using the RunContext.register_token() method.</p>"},{"location":"reference/ext/#hyperon.ext.register_tokens--parameters","title":"Parameters","text":"<p>pass_metta : bool, optional     Pass instance of MeTTa class to the decorated function as an argument.     Default is False.</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def register_tokens(*args, **kwargs):\n    \"\"\"Function decorator which registers returned pairs of regular expressions\n    and lambdas in a Tokenizer using the RunContext.register_token() method.\n\n    Parameters\n    ----------\n    pass_metta : bool, optional\n        Pass instance of MeTTa class to the decorated function as an argument.\n        Default is False.\n    \"\"\"\n    return mark_register_function(RegisterType.TOKEN, args, kwargs)\n</code></pre>"},{"location":"reference/metta/","title":"Metta","text":""},{"location":"reference/metta/#hyperon.metta","title":"metta","text":"<p>This is the MeTTa entrypoint</p>"},{"location":"reference/metta/#hyperon.metta.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>usage: metta.py [-h] metta file</p> <p>Metta script interpreter</p> positional arguments <p>metta file  metta script</p> optional arguments <p>-h, --help  show this help message and exit</p> Source code in <code>python/hyperon/metta.py</code> <pre><code>def main():\n    \"\"\"\n\tusage: metta.py [-h] metta file\n\n\tMetta script interpreter\n\n\tpositional arguments:\n\t\tmetta file  metta script\n\n\toptional arguments:\n\t\t-h, --help  show this help message and exit\n\n    \"\"\"\n    parser = argparse.ArgumentParser(description='Metta script interpreter')\n    group = parser.add_mutually_exclusive_group()\n    group.add_argument(\n        '--version', action='store_true', help='prints the version')\n    group.add_argument(\n        'file', nargs='?', metavar=\"MeTTa script\", help='the MeTTa script')\n    args = parser.parse_args()\n    if args.version:\n        print(hyperon.__version__)\n    elif args.file:\n        parent_dir = os.path.dirname(args.file)\n        with open(args.file) as f: program = f.read()\n        metta = hyperon.MeTTa(env_builder=hyperon.Environment.custom_env(working_dir=parent_dir, config_dir=\"\"))\n        for result in metta.run(program):\n            print(result)\n    else:\n        parser.print_usage()\n</code></pre>"},{"location":"reference/module/","title":"Module","text":""},{"location":"reference/module/#hyperon.module","title":"module","text":""},{"location":"reference/module/#hyperon.module.MettaModRef","title":"MettaModRef","text":"<pre><code>MettaModRef(cmodref)\n</code></pre> <p>Class represents a reference to the MeTTa module structure. It is a wrapper of the reference to the corresponding Rust class.</p> Source code in <code>python/hyperon/module.py</code> <pre><code>def __init__(self, cmodref):\n    \"\"\"Initialize wrapper\"\"\"\n    self.cmodref = cmodref\n</code></pre>"},{"location":"reference/module/#hyperon.module.MettaModRef.tokenizer","title":"tokenizer","text":"<pre><code>tokenizer()\n</code></pre> <p>Returns module's tokenizer instance</p> Source code in <code>python/hyperon/module.py</code> <pre><code>def tokenizer(self):\n    \"\"\"Returns module's tokenizer instance\"\"\"\n    return Tokenizer._from_ctokenizer(self.cmodref.tokenizer())\n</code></pre>"},{"location":"reference/runner/","title":"Runner","text":""},{"location":"reference/runner/#hyperon.runner","title":"runner","text":""},{"location":"reference/runner/#hyperon.runner.Environment","title":"Environment","text":"<p>This class contains the API for configuring the host platform interface used by MeTTa</p>"},{"location":"reference/runner/#hyperon.runner.Environment.config_dir","title":"config_dir","text":"<pre><code>config_dir()\n</code></pre> <p>Returns the config dir in the common environment</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def config_dir():\n    \"\"\"Returns the config dir in the common environment\"\"\"\n    path = hp.environment_config_dir()\n    if (len(path) &gt; 0):\n        return path\n    else:\n        return None\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.Environment.custom_env","title":"custom_env","text":"<pre><code>custom_env(working_dir=None, config_dir=None, create_config=None, is_test=None, include_paths=[])\n</code></pre> <p>Returns an EnvBuilder object that can be used to init a MeTTa runner, if you need multiple environments to coexist in the same process</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def custom_env(working_dir = None, config_dir = None, create_config = None, is_test = None, include_paths = []):\n    \"\"\"Returns an EnvBuilder object that can be used to init a MeTTa runner, if you need multiple environments to coexist in the same process\n\n    Keyword arguments:\n        working_dir -- working directory for the environment (default None)\n        config_dir -- path to the configuration directory, None - no\n        configuration directory, \"\" - default configuration directory\n        (default None)\n        create_config -- create configuration directory if not found\n        (default None)\n        is_test -- is environment used in unit-test flag (default None)\n        include_paths -- additional search paths to search for MeTTa\n        modules in the file system (default [])\n    \"\"\"\n    builder = hp.env_builder_start()\n    if working_dir is not None:\n        hp.env_builder_set_working_dir(builder, working_dir)\n    if config_dir is not None:\n        if config_dir == \"\":\n            hp.env_builder_set_default_config_dir(builder)\n        else:\n            hp.env_builder_set_config_dir(builder, config_dir)\n    if create_config is not None:\n        hp.env_builder_create_config_dir(builder, create_config)\n    if is_test is not None:\n        hp.env_builder_set_is_test(builder, is_test)\n    for path in include_paths:\n        hp.env_builder_push_include_path(builder, path)\n    return builder\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.Environment.init_common_env","title":"init_common_env","text":"<pre><code>init_common_env(working_dir=None, config_dir=None, create_config=None, is_test=None, include_paths=[])\n</code></pre> <p>Initialize the common environment with the supplied args</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def init_common_env(working_dir = None, config_dir = None, create_config = None, is_test = None, include_paths = []):\n    \"\"\"Initialize the common environment with the supplied args\n\n    Keyword arguments:\n        working_dir -- working directory for the environment (default None)\n        config_dir -- path to the configuration directory, None - no\n        configuration directory, \"\" - default configuration directory\n        (default None)\n        create_config -- create configuration directory if it doesn't exist\n        (default None)\n        is_test -- is environment used in unit-test flag (default None)\n        include_paths -- additional search paths to search for MeTTa\n        modules in the file system (default [])\n    \"\"\"\n    builder = Environment.custom_env(working_dir, config_dir, create_config, is_test, include_paths)\n    return hp.env_builder_init_common_env(builder)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.Environment.test_env","title":"test_env","text":"<pre><code>test_env()\n</code></pre> <p>Returns an EnvBuilder object specifying a unit-test environment, that can be used to init a MeTTa runner</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def test_env():\n    \"\"\"Returns an EnvBuilder object specifying a unit-test environment, that can be used to init a MeTTa runner\"\"\"\n    return hp.env_builder_use_test_env()\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa","title":"MeTTa","text":"<pre><code>MeTTa(cmetta=None, space=None, env_builder=None)\n</code></pre> <p>This class represents the runner to execute MeTTa programs</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __init__(self, cmetta = None, space = None, env_builder = None):\n\n    if cmetta is not None:\n        self.cmetta = cmetta\n    else:\n        if space is None:\n            space = GroundingSpaceRef()\n        if env_builder is None:\n            env_builder = hp.env_builder_start()\n            hp.env_builder_set_default_config_dir(env_builder)\n        hp.env_builder_push_fs_module_format(env_builder, _PyFileMeTTaModFmt)\n        #LP-TODO-Next, add an fs_module_fmt arg to the standardized way to init environments, so that\n        # the Python user can define additional formats without tweaking any hyperon files.  To make\n        # this convenient it probably means making a virtual ModuleFormat base class\n\n        builtin_mods_path = os.path.join(os.path.dirname(__file__), 'exts')\n        hp.env_builder_push_include_path(env_builder, builtin_mods_path)\n\n        py_site_packages_paths = site.getsitepackages()\n        for path in py_site_packages_paths:\n            hp.env_builder_push_include_path(env_builder, path)\n\n        self.cmetta = hp.metta_new_with_stdlib_loader(_priv_load_module_stdlib, space.cspace, env_builder)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two MeTTa runner handles point to the same runner.</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two MeTTa runner handles point to the same runner.\"\"\"\n    return (hp.metta_eq(self.cmetta, other.cmetta))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.load_module_at_path","title":"load_module_at_path","text":"<pre><code>load_module_at_path(path, mod_name=None)\n</code></pre> <p>Loads a module into the runner directly from resource at a file system path, trying the formats from the runner's environment in succession</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def load_module_at_path(self, path, mod_name=None):\n    \"\"\"\n    Loads a module into the runner directly from resource at a file system path, trying the formats\n    from the runner's environment in succession\n    \"\"\"\n    mod_id = hp.metta_load_module_at_path(self.cmetta, path, mod_name)\n    err_str = hp.metta_err_str(self.cmetta)\n    if (err_str is not None):\n        raise RuntimeError(err_str)\n    return mod_id\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.load_module_direct_from_func","title":"load_module_direct_from_func","text":"<pre><code>load_module_direct_from_func(mod_name, loader_func)\n</code></pre> <p>Loads a module into the runner using a loader function, with the specified name and scope</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def load_module_direct_from_func(self, mod_name, loader_func):\n    \"\"\"Loads a module into the runner using a loader function, with the specified name and scope\"\"\"\n    mod_id = hp.metta_load_module_direct(self.cmetta, mod_name, loader_func)\n    err_str = hp.metta_err_str(self.cmetta)\n    if (err_str is not None):\n        raise RuntimeError(err_str)\n    return mod_id\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.load_module_direct_from_pymod","title":"load_module_direct_from_pymod","text":"<pre><code>load_module_direct_from_pymod(mod_name, pymod_name)\n</code></pre> <p>Loads a module into the runner directly from a Python module, with the specified name and scope</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def load_module_direct_from_pymod(self, mod_name, pymod_name):\n    \"\"\"Loads a module into the runner directly from a Python module, with the specified name and scope\"\"\"\n    if not isinstance(pymod_name, str):\n        pymod_name = repr(pymod_name)\n    def loader_func(tokenizer, metta):\n        _priv_register_module_tokens(pymod_name, tokenizer, metta)\n    return self.load_module_direct_from_func(mod_name, loader_func)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.parse_all","title":"parse_all","text":"<pre><code>parse_all(program)\n</code></pre> <p>Parse an entire program from text into atoms, using the Tokenizer of the runner's top module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def parse_all(self, program):\n    \"\"\"Parse an entire program from text into atoms, using the Tokenizer of the runner's top module\"\"\"\n    return list(self._parse_all(program))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.parse_single","title":"parse_single","text":"<pre><code>parse_single(program)\n</code></pre> <p>Parse the next single token from the text program</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def parse_single(self, program):\n    \"\"\"Parse the next single token from the text program\"\"\"\n    return next(self._parse_all(program))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.register_atom","title":"register_atom","text":"<pre><code>register_atom(name, symbol)\n</code></pre> <p>Registers an Atom</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def register_atom(self, name, symbol):\n    \"\"\"Registers an Atom\"\"\"\n    self.register_token(name, lambda _: symbol)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.register_token","title":"register_token","text":"<pre><code>register_token(regexp, constr)\n</code></pre> <p>Registers a token</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def register_token(self, regexp, constr):\n    \"\"\"Registers a token\"\"\"\n    self.tokenizer().register_token(regexp, constr)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.run","title":"run","text":"<pre><code>run(program, flat=False)\n</code></pre> <p>Runs the MeTTa code from the program string containing S-Expression MeTTa syntax</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def run(self, program, flat=False):\n    \"\"\"Runs the MeTTa code from the program string containing S-Expression MeTTa syntax\"\"\"\n    parser = SExprParser(program)\n    results = hp.metta_run(self.cmetta, parser.cparser)\n    self._run_check_for_error()\n    if flat:\n        return [Atom._from_catom(catom) for result in results for catom in result]\n    else:\n        return [[Atom._from_catom(catom) for catom in result] for result in results]\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.space","title":"space","text":"<pre><code>space()\n</code></pre> <p>Gets the space for the runner's top-level module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def space(self):\n    \"\"\"Gets the space for the runner's top-level module\"\"\"\n    return GroundingSpaceRef._from_cspace(hp.metta_space(self.cmetta))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.tokenizer","title":"tokenizer","text":"<pre><code>tokenizer()\n</code></pre> <p>Gets the tokenizer for the runner's top-level module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def tokenizer(self):\n    \"\"\"Gets the tokenizer for the runner's top-level module\"\"\"\n    return Tokenizer._from_ctokenizer(hp.metta_tokenizer(self.cmetta))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.working_dir","title":"working_dir","text":"<pre><code>working_dir()\n</code></pre> <p>Returns the working dir from the environment associated with the runner</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def working_dir(self):\n    \"\"\"Returns the working dir from the environment associated with the runner\"\"\"\n    return hp.metta_working_dir(self.cmetta)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.ModuleDescriptor","title":"ModuleDescriptor","text":"<pre><code>ModuleDescriptor(c_module_descriptor)\n</code></pre> <p>An object that uniquely describes a module, including the module's name, optionally a version</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __init__(self, c_module_descriptor):\n    \"\"\"Wraps the underlying ModuleDescriptor object from the core\"\"\"\n    self.c_module_descriptor = c_module_descriptor\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext","title":"RunContext","text":"<pre><code>RunContext(c_run_context)\n</code></pre> <p>An accessor object for the API used by the executable atoms inside a MeTTa program</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __init__(self, c_run_context):\n    \"\"\"Wraps the underlying RunContext object from the core\"\"\"\n    self.c_run_context = c_run_context\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.import_dependency","title":"import_dependency","text":"<pre><code>import_dependency(mod_id)\n</code></pre> <p>Imports a loaded module as a dependency of the running module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def import_dependency(self, mod_id):\n    \"\"\"Imports a loaded module as a dependency of the running module\"\"\"\n    if mod_id.is_valid():\n        hp.run_context_import_dependency(self.c_run_context, mod_id)\n    else:\n        raise RuntimeError(\"Invalid ModuleId\")\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.init_self_module","title":"init_self_module","text":"<pre><code>init_self_module(space, resource_dir)\n</code></pre> <p>Must be called exactly once from within a module loader to initialize the module being loaded</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def init_self_module(self, space, resource_dir):\n    \"\"\"Must be called exactly once from within a module loader to initialize the module being loaded\"\"\"\n    hp.run_context_init_self_module(self.c_run_context, space.cspace, resource_dir)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.load_module","title":"load_module","text":"<pre><code>load_module(mod_name)\n</code></pre> <p>Resolves a module by name in the context of the running module, and loads it into the runner</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def load_module(self, mod_name):\n    \"\"\"Resolves a module by name in the context of the running module, and loads it into the runner\"\"\"\n    return hp.run_context_load_module(self.c_run_context, mod_name)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.metta","title":"metta","text":"<pre><code>metta()\n</code></pre> <p>Access the MeTTa runner that the RunContext is running within</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def metta(self):\n    \"\"\"Access the MeTTa runner that the RunContext is running within\"\"\"\n    return MeTTa(cmetta = hp.run_context_get_metta(self.c_run_context))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.register_atom","title":"register_atom","text":"<pre><code>register_atom(name, symbol)\n</code></pre> <p>Registers an Atom with a name in the currently running module's Tokenizer</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def register_atom(self, name, symbol):\n    \"\"\"Registers an Atom with a name in the currently running module's Tokenizer\"\"\"\n    self.register_token(name, lambda _: symbol)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.register_token","title":"register_token","text":"<pre><code>register_token(regexp, constr)\n</code></pre> <p>Registers a token in the currently running module's Tokenizer</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def register_token(self, regexp, constr):\n    \"\"\"Registers a token in the currently running module's Tokenizer\"\"\"\n    self.tokenizer().register_token(regexp, constr)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.space","title":"space","text":"<pre><code>space()\n</code></pre> <p>Access the space for the currently running module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def space(self):\n    \"\"\"Access the space for the currently running module\"\"\"\n    return GroundingSpaceRef._from_cspace(hp.run_context_get_space(self.c_run_context))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.tokenizer","title":"tokenizer","text":"<pre><code>tokenizer()\n</code></pre> <p>Access the tokenizer for the currently running module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def tokenizer(self):\n    \"\"\"Access the tokenizer for the currently running module\"\"\"\n    return Tokenizer._from_ctokenizer(hp.run_context_get_tokenizer(self.c_run_context))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState","title":"RunnerState","text":"<pre><code>RunnerState(metta, program)\n</code></pre> <p>The state for an in-flight MeTTa interpreter handling the interpretation and evaluation of atoms in a given grounding space.</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __init__(self, metta, program):\n    \"\"\"Initialize a RunnerState with a MeTTa object and a program to run\"\"\"\n    parser = SExprParser(program)\n    #WARNING the C parser object has a reference to the text buffer, and hyperonpy's CSExprParser\n    #  copies the buffer into an owned string.  So we need to make sure this parser isn't freed\n    #  until the RunnerState is done with it.\n    self.parser = parser\n    self.cstate = hp.runner_state_new_with_parser(metta.cmetta, parser.cparser)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees a RunnerState and all associated resources.</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees a RunnerState and all associated resources.\"\"\"\n    hp.runner_state_free(self.cstate)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState.current_results","title":"current_results","text":"<pre><code>current_results(flat=False)\n</code></pre> <p>Returns the current in-progress results from an in-flight program evaluation</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def current_results(self, flat=False):\n    \"\"\"\n    Returns the current in-progress results from an in-flight program evaluation\n    \"\"\"\n    results = hp.runner_state_current_results(self.cstate)\n    if flat:\n        return [Atom._from_catom(catom) for result in results for catom in result]\n    else:\n        return [[Atom._from_catom(catom) for catom in result] for result in results]\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState.is_complete","title":"is_complete","text":"<pre><code>is_complete()\n</code></pre> <p>Returns True if the runner has concluded, or False if there are more steps remaining to execute</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def is_complete(self):\n    \"\"\"\n    Returns True if the runner has concluded, or False if there are more steps remaining to execute\n    \"\"\"\n    return hp.runner_state_is_complete(self.cstate)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState.run_step","title":"run_step","text":"<pre><code>run_step()\n</code></pre> <p>Executes the next step in the interpretation plan, or begins interpretation of the next atom in the stream of MeTTa code.</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def run_step(self):\n    \"\"\"\n    Executes the next step in the interpretation plan, or begins interpretation of the next atom in the stream of MeTTa code.\n    \"\"\"\n    hp.runner_state_step(self.cstate)\n    err_str = hp.runner_state_err_str(self.cstate)\n    if (err_str is not None):\n        raise RuntimeError(err_str)\n</code></pre>"},{"location":"reference/stdlib/","title":"Stdlib","text":""},{"location":"reference/stdlib/#hyperon.stdlib","title":"stdlib","text":""},{"location":"reference/stdlib/#hyperon.stdlib.Char","title":"Char","text":"<pre><code>Char(char)\n</code></pre> <p>Emulate Char type as in a traditional FPL</p> Source code in <code>python/hyperon/stdlib.py</code> <pre><code>def __init__(self, char):\n    if len(char) != 1:\n        raise ValueError(\"A Char object must be initialized with a single character.\")\n    self.char = char\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject","title":"RegexMatchableObject","text":"<pre><code>RegexMatchableObject(content, id=None)\n</code></pre> <p>               Bases: <code>MatchableObject</code></p> <p>To match atoms with regular expressions</p> Source code in <code>python/hyperon/stdlib.py</code> <pre><code>def __init__(self, content, id=None):\n    super().__init__(content, id)\n\n    self.content = self.content.replace(\"[[\", \"(\").replace(\"]]\", \")\").replace(\"~\", \" \")\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Gets the value of the object, which is its content.</p>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this ValueObject with another based on their content.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compares the equality of this ValueObject with another based on their content.\"\"\"\n    # TODO: We need to hook this up the the Value-Bridging mechanism when it's designed and built\n    # https://github.com/trueagi-io/hyperon-experimental/issues/351\n\n    # TODO: ?typecheck for the contents\n    return isinstance(other, ValueObject) and self.content == other.content\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        newstr = repr(self.content)[1:-1].translate(str.maketrans({'\"' : r'\\\"'}))\n        return f'\"{newstr}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.serialize","title":"serialize","text":"<pre><code>serialize(serializer)\n</code></pre> <p>Serialize standard Python values. This implementation is used to pass Python values into the foreign runtime.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def serialize(self, serializer):\n    \"\"\"\n    Serialize standard Python values. This implementation is used to\n    pass Python values into the foreign runtime.\n    \"\"\"\n    if isinstance(self.content, bool):\n        return serializer.serialize_bool(self.content)\n    elif isinstance(self.content, int):\n        return serializer.serialize_int(self.content)\n    elif isinstance(self.content, float):\n        return serializer.serialize_float(self.content)\n    elif isinstance(self.content, str):\n        return serializer.serialize_str(self.content)\n    else:\n        return SerialResult.NOT_SUPPORTED\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.text_ops","title":"text_ops","text":"<pre><code>text_ops(metta)\n</code></pre> <p>Add text operators</p> <p>repr: convert Atom to string. parse: convert String to Atom. stringToChars: convert String to tuple of Char. charsToString: convert tuple of Char to String.</p> <p>see test_stdlib.py for examples.</p> Source code in <code>python/hyperon/stdlib.py</code> <pre><code>@register_atoms(pass_metta=True)\ndef text_ops(metta):\n    \"\"\"Add text operators\n\n    repr: convert Atom to string.\n    parse: convert String to Atom.\n    stringToChars: convert String to tuple of Char.\n    charsToString: convert tuple of Char to String.\n\n    see test_stdlib.py for examples.\n\n    \"\"\"\n\n    reprAtom = OperationAtom('repr', lambda a: [ValueAtom(repr(a), 'String')],\n                             ['Atom', 'String'], unwrap=False)\n    parseAtom = OperationAtom('parse', lambda s: parseImpl(s, metta), ['String', 'Atom'], unwrap=False)\n    stringToCharsAtom = OperationAtom('stringToChars', lambda s: [E(*[ValueAtom(Char(c)) for c in str(s)[1:-1]])],\n                                      ['String', 'Atom'], unwrap=False)\n    charsToStringAtom = OperationAtom('charsToString', lambda a: [ValueAtom(\"\".join([str(c)[1:-1] for c in a.get_children()]))],\n                                      ['Atom', 'String'], unwrap=False)\n    return {\n        r\"repr\": reprAtom,\n        r\"parse\": parseAtom,\n        r\"stringToChars\": stringToCharsAtom,\n        r\"charsToString\": charsToStringAtom\n    }\n</code></pre>"}]}