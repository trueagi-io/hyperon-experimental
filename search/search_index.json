{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"CONTRIBUTING/","title":"How to contribute","text":""},{"location":"CONTRIBUTING/#making-changes","title":"Making changes","text":"<p>Before making changes create a personal fork of the repository. Sync fork and create new branch from the latest version of the <code>main</code> branch. Create separate branch for each change. Thus it is simpler to support consistent state of the <code>main</code> in your fork.</p> <p>Prefer incremental commits to one big commit which contains the whole change. Prefer commits which passes all of the tests. If it is not possible to satisfy both requirements at once you can make single commit which passes tests or mark tests as ignored until change is done.</p> <p>Each commit should have a message in the following format: <pre><code>Change summary in 50 characters (less than 73 characters)\n\nOptional detailed description of the change when required. Each line\nis less than 73 character long.\n</code></pre> Such commits looks better in GitHub history.</p> <p>Please avoid generic commit messages like <code>Update README.md</code>. Good commit message should describe the change, not a fact of the change. For example <code>Add troubleshooting section about No module named 'hyperonpy'</code>. By looking to the commit message history the reviewer should understand the order and brief description of changes.</p> <p>Please don't include number and description of the issue into a commit summary line. Use <code>Fixes #&lt;issue-number&gt;</code> in the pull request description instead to link the PR and the issue.</p> <p>PR should satisfy the following requirement before being merged: - contain latest changes from the repo; - pass tests; - be reviewed.</p> <p>Feel free to raise draft PR if you need an advice or help with your changes.</p>"},{"location":"CONTRIBUTING/#code-style","title":"Code style","text":"<p>We have small set of code style rules for now. The rule of thumb is to take a look at the existing code and stick to its style.</p>"},{"location":"CONTRIBUTING/#general","title":"General","text":"<p>If you want to leave some reminder in code, for example to fix something later, you can do it by two ways. Add a comment starting with <code>FIXME</code> to mark something which should be done before the PR is merged. Add a comment starting with <code>TODO</code> to mark the improvement which can be postponed and done later by a separate PR. The main purpose of a <code>TODO</code> comment is to trigger a developer who looks at the code after you and make him fix the issue if it is appropriate. If the change or question is big enough or it affects the API of the module it is better to raise an issue instead.</p>"},{"location":"CONTRIBUTING/#libraries","title":"Libraries","text":"<p>When adding new library into the project please ensure you specify the exact version instead of using ranges. The minor update of the library can break the build unexpectedly. The broken build is a real burden because most of the users build the project from the source.</p>"},{"location":"CONTRIBUTING/#rust","title":"Rust","text":"<p>When working on Rust C API prefer making <code>unsafe</code> blocks as small as possible. This makes it easier to find blocks that might be source of issues. Usually it is not required to mark C API functions <code>unsafe</code> because they are not intended to be used from the Rust safe code.</p>"},{"location":"CONTRIBUTING/#git","title":"Git","text":"<p><code>.gitignore</code> file is also used to exclued files going into Docker image building context. All ignored files should be put into the same <code>.gitignore</code> at the root of the repository by this reason.</p>"},{"location":"DEVELOPMENT/","title":"Instructions for developers","text":""},{"location":"DEVELOPMENT/#how-to-release-python-distribution-packages-locally","title":"How to release Python distribution packages locally","text":"<p>Python packages are released using cibuildwheel. First step is to setup it. Usually it means setup docker and install the package from PyPi (see setup instructions).</p> <p>There are additional preparations to be made. First of all it is needed to allow building and installing <code>libhyperonc</code> library on a build environment. <code>cibuildwheel</code> uses isolated docker container for each kind of platform it supports. Only code of the Python package is copied into container automatically. Code of the <code>libhyperonc</code> library should be downloaded from outside. It means one need to have the code in some repo accessible from the container before starting release. The simplest way is to push the changes in your GitHub repo fork.</p> <p>By default library downloads and installs version from the <code>main</code> branch of the <code>trueagi-io/hyperon-experimental</code> repository. Using a custom branch is done by passing custom parameters to the <code>install-hyperonc.sh</code> script through CIBW_BEFORE_ALL environment variable: <pre><code>export CIBW_BEFORE_ALL='sh -c \"./python/install-hyperonc.sh -u &lt;git-repo-url&gt; -r &lt;git-branch&gt;\"'\n</code></pre> One should replace <code>&lt;git-repo-url&gt;</code> and <code>&lt;git-branch&gt;</code> by the repo URL and branch which are used in release.</p> <p>Also it is possible to start from building the only platform to quickly check whether release works. This can be done using CIBW_BUILD variable: <pre><code>export CIBW_BUILD=cp310-manylinux_x86_64\n</code></pre></p> <p>After exporting the variables above one can start release by executing <code>cibuildwheel ./python</code> from the root directory of the repo. See cibuildwheel documentation for details.</p>"},{"location":"DEVELOPMENT/#how-to-update-the-version","title":"How to update the version","text":"<p>Usually it is needed before releasing the artifacts or before making a test release.</p> <p>There are three locations to update: - /Cargo.toml file:   - <code>workspace.package.version</code> property   - <code>workspace.dependencies.hyperon.version</code> property - /python/VERSION file</p> <p>All three locations should contain the same version.</p>"},{"location":"DEVELOPMENT/#how-to-release-binaries","title":"How to release binaries","text":"<p>Update the version How to update the version in the main branch of the repository, raise PR and merge it. Use Create a new release link on the main page of the GitHub repo. Press <code>Choose a tag</code> control and type new tag which should be in form of <code>v&lt;version&gt;</code> (for example if version is <code>0.1.7</code> then tag is <code>v0.1.7</code>). After typing the tag press <code>Create new tag on publish</code>. Now press <code>Generate release notes</code> button. It will automatically fill the <code>Release title</code> and <code>Release description</code> fields. Tick <code>Set as a pre-release</code> checkbox if needed and press <code>Publish release</code> button.  Now you have published new GitHub release and triggered a job to build release artifacts.</p> <p>After release job is finished one need to approve publishing artifacts to the PyPi repository. Before approving one can download and test Python wheels built. To check the job status go the <code>Actions/release-pyhon</code> page, and select last workflow run. Links to the archives with the artifacts are located at the bottom of the page.</p> <p>If distribution wheels are good then one can approve the publishing process. At the top of the workflow run page there are two blocks <code>Publish to Test PyPi</code> and <code>Publish to PyPi</code>. First press <code>Publish to Test PyPi</code> block approve it and wait for publishing. It is critical to start from Test PyPi because release cannot be removed from the PyPi after publishing.</p> <p>After release is published check it can be installed executing: <pre><code>python3 -m pip install --index-url https://test.pypi.org/simple/ hyperon\n</code></pre> Check that the latest published version was downloaded and installed. If you are making a test release then you should not publish it to the PyPi. If it is a production release then proceed with <code>Publish to PyPi</code> block.</p>"},{"location":"DEVELOPMENT/#how-to-check-release-job-in-fork","title":"How to check release job in fork","text":"<p>If you don't need to test publishing or Docker building procedures just run release workflow manually. Otherwise you need to trigger release as usual.</p> <p>First you need to select the test release version. It should contain an additional version digit after the latest officially released version. Let's say the latest released version is <code>0.1.7</code>. Then the test release version should be <code>0.1.7.x</code> for instance <code>0.1.7.1</code>. Start from 1 and increment it after each release you published successfully.</p> <p>Make a separate branch to release the code. It is not necessary but it is highly recommended to not pollute the main branch of the fork. In order to be able releasing from the branch one need to temporary make it default branch. It is done by using GitHub repo <code>Settings/General/Default branch</code> control.</p> <p>Update the version in the branch to the test release version you constructed. Commit and push this change in your test branch. Now you are ready to make a test release. See release binaries instruction.</p> <p>After testing the release procedure remove the commit with version update from your branch. And set default branch setting to the previous value.</p>"},{"location":"building_c_docs/","title":"Building c docs","text":""},{"location":"building_c_docs/#building-c-documentation","title":"Building C Documentation","text":"<ol> <li> <p><code>doxygen</code> must be installed.  Depending on your platform it may be easiest to use a package manager.</p> <ul> <li>using apt: <code>sudo apt-get install doxygen</code></li> <li>using homebrew (Mac): <code>brew install doxygen</code></li> <li>installing from source: [https://www.doxygen.nl/manual/install.html]</li> </ul> </li> <li> <p>Build the Hyperon C library, following the instructions here: [https://github.com/trueagi-io/hyperon-experimental?tab=readme-ov-file#c-and-python-api]</p> </li> <li> <p>Set CMake environment variables.  Relative to the <code>build</code> directory, run the following:</p> <ul> <li><code>export CMAKE_CURRENT_SOURCE_DIR=../c/</code></li> <li><code>export HYPERONC_INCLUDE_DIR=./hyperonc-install/include/hyperonc/hyperon/</code></li> </ul> </li> <li> <p>Invoke <code>doxygen</code> using the following command: <code>doxygen ../c/hyperonc.doxyfile</code></p> </li> </ol> <p>The top page for the rendered HTML results will be written to <code>./html/index.html</code>, and latex results will be similarly written to <code>./latex/index.tex</code></p>"},{"location":"das_setup/","title":"Das setup","text":""},{"location":"das_setup/#running-das-module-tests-locally","title":"Running DAS module tests locally","text":""},{"location":"das_setup/#install-das-toolbox-in-order-to-get-das-cli-debian-based-linux-users","title":"Install <code>das-toolbox</code> in order to get <code>das-cli</code> (Debian based Linux users):","text":"<pre><code>sudo apt -y update\nsudo apt -y install wget\n\nwget -O - http://45.77.4.33/apt-repo/setup.sh | sudo bash\n\nsudo apt -y install das-toolbox\n\n# &gt;= 0.5.0\ndas-cli --version\n</code></pre> <p>You can also run <code>das-cli</code> from source, using python3 (other OS): <pre><code>git clone https://github.com/singnet/das-toolbox.git\n\ncd das-toolbox\ngit checkout tags/0.5.0\n\n# Optional - Create a virtual env\npython3 -m venv .venv\nsource .venv/bin/activate\n\npip3 install -r das-cli/src/requirements.txt\n</code></pre></p> <ol> <li> <p>Set up <code>das-cli</code> configurations <pre><code>das-cli config set\n# Or\npython3 das-cli/src/das_cli.py config set\n\n# NOTE: Be sure to set Attention Broker's port to 37007\n# For all other prompts, you can just hit ENTER\n\n&gt;&gt;&gt;\nEnter Redis port [40020]: \nIs it a Redis cluster? [y/N]: \nEnter MongoDB port [40021]: \nEnter MongoDB username [admin]: \nEnter MongoDB password [admin]: \nIs it a MongoDB cluster? [y/N]: \nEnter Jupyter Notebook port [40019]: \nEnter the Attention Broker port [40001]: 37007 &lt;--- HERE\nEnter the Query Agent port [40002]: \nEnter the Link Creation Agent Server port [40003]: \nEnter the Link Creation Agent buffer file [/tmp/requests_buffer.bin]: \nEnter the Link Creation Agent request interval (in seconds) [1]: \nEnter the Link Creation Agent thread count [1]: \nEnter the Link Creation Agent default timeout (in seconds) [10]: \nDo you want to save links to a Metta file? [Y/n]: \nDo you want to save links to the database? [Y/n]: \nEnter the Inference Agent port [40004]: \nEnter the Evolution agent port [40005]: \nConfiguration file saved -&gt; /home/gontijo/.das\n</code></pre></p> </li> <li> <p>Start Databases <pre><code>das-cli db start\n# Or\npython3 das-cli/src/das_cli.py db start\n\n&gt;&gt;&gt;\nStarting Redis service...\nRedis has started successfully on port 29000 at localhost, operating under the server user arturgontijo.\nStarting MongoDB service...\nMongoDB has started successfully on port 28000 at localhost, operating under the server user arturgontijo.\n</code></pre></p> </li> <li> <p>Load Databases with <code>das_kb.metta</code> content: <pre><code># We need the metta file's absolute path, moving it to /tmp for convinience\ncp lib/tests/das_kb.metta /tmp\n\n# Then\ndas-cli metta load /tmp/das_kb.metta\n# Or\npython3 das-cli/src/das_cli.py metta load /tmp/das_kb.metta\n\n&gt;&gt;&gt;\ndas-cli-mongodb-28000 is running on port 28000\ndas-cli-redis-29000 is running on port 29000\nLoading metta file /tmp/das_kb.metta...\nConnecting to Redis at localhost:29000\nConnecting to MongoDB at localhost:28000\nDone.\n</code></pre></p> </li> <li> <p>Start Attention Broker service <pre><code>das-cli ab start\n# Or\npython3 das-cli/src/das_cli.py ab start\n\n&gt;&gt;&gt;\nStarting Attention Broker service...\nAttention Broker started on port 37007\n</code></pre></p> </li> <li> <p>Start Query Broker service <pre><code>das-cli qa start\n# Or\npython3 das-cli/src/das_cli.py qa start\n\n&gt;&gt;&gt;\n# Chose a port range (using 52000:52999)\nEnter port range (e.g., 3000:3010): 52000:52999\nStarting Query Agent service...\nQuery Agent started on port 40002\n</code></pre></p> </li> <li> <p>Running DAS tests <pre><code># Run it passing a metta file (from repo's root)\n# NOTE: this run will freeze for ~20s as client tries to get all available services from peers\ncargo run -r --bin metta-repl lib/tests/das.metta\n\n&gt;&gt;&gt;\n[2025-08-19T12:41:03Z WARN  metta_bus_client::bus_node] BusNode::join_network(): Unable to get all services (1/4) from peer localhost:35700\n[()]\n[()]\n[()]\n[()]\n[()]\n\n# Optional: use RUST_LOG=das=LEVEL to inspect workflow\nRUST_LOG=das=debug ./target/release/metta-repl lib/tests/das.metta\n</code></pre></p> </li> <li> <p>Stop all services (removing their containers) <pre><code>das-cli qa stop\ndas-cli ab stop\ndas-cli db stop\n\n# Or\npython3 das-cli/src/das_cli.py qa stop\npython3 das-cli/src/das_cli.py ab stop\npython3 das-cli/src/das_cli.py db stop\n</code></pre></p> </li> </ol>"},{"location":"minimal-metta/","title":"Minimal Metta","text":"<p>This document describes the minimal set of embedded MeTTa instructions which is designed to write the complete MeTTa interpreter in MeTTa. Current version of the document includes improvements which were added after experimenting with the first version of such an interpreter. It is not a final version and some directions of the future work is explained at the end of the document.</p>"},{"location":"minimal-metta/#minimal-instruction-set","title":"Minimal instruction set","text":""},{"location":"minimal-metta/#interpreter-state","title":"Interpreter state","text":"<p>The MeTTa interpreter evaluates an atom passed as an input. It evaluates it step by step executing a single instruction on each step. In order to do that the interpreter needs a context which is wider than the atom itself. The context also includes: - an atomspace which contains the knowledge which drives the evaluation of the   expressions; - bindings of the variables which are used to evaluate expressions; the   bindings are empty at the beginning (see Explicit atomspace variable   bindings).</p> <p>Each step of interpretation inputs and outputs a list of pairs (<code>&lt;atom&gt;</code>, <code>&lt;bindings&gt;</code>) which is called interpretation plan. Each pair in the plan represents one possible way of interpreting the original atom or possible branch of the evaluation. Interpreter doesn't select one of them for further processing. It continues interpreting all of the branches in parallel. Below this is called non-deterministic evaluation.</p> <p>One step of the interpretation is an execution of a single instruction from a plan. An interpreter extracts atom and bindings from the plan and evaluates the atom. The result of the operation is a set of pairs (<code>&lt;atom&gt;</code>, <code>&lt;bindings&gt;</code>). Bindings of the result are merged with the previous bindings. Merge operation can also bring more than one result. Each such result is added as a separate pair into a result set. Finally all results from result set are added into the plan and step finishes.</p> <p>Here we suppose that on the top level the plan contains only the instructions from the minimal set. If an instruction returns the atom which is not from the minimal set it is not interpreted further and returned as a part of the final result. Thus only the instructions of the minimal set are considered a code other atoms are considered a data.</p>"},{"location":"minimal-metta/#evaluation-order","title":"Evaluation order","text":"<p>MeTTa implements the applicative evaluation order by default, arguments are evaluated before they are passed to the function. User can change this order using special meta-types as the types of the arguments. Minimal MeTTa operations don't rely on types and minimal MeTTa uses the fixed normal evaluation order, arguments are passed to the function without evaluation. But there is a chain operation which can be used to evaluate an argument before passing it. Thus <code>chain</code> can be used to change evaluation order in MeTTa interpreter.</p>"},{"location":"minimal-metta/#erroremptynotreducible","title":"Error/Empty/NotReducible/()","text":"<p>There are atoms which can be returned to designate a special situation in a code: - <code>(Error &lt;atom&gt; &lt;message&gt;)</code> means the interpretation is finished with error; - <code>Empty</code> means the corresponding branch of the evaluation returned no results,   such result is not returned among other results when interpreting is   finished; - <code>NotReducible</code> can be returned by <code>eval</code> in order to designate that function   can not be reduced further; for example it can happen when code tries to call   a type constructor (which has no definition), partially defined function   (with argument values which are not handled), or grounded function which   returns <code>NotReducible</code> explicitly; this atom is introduced to separate the   situations when atom should be returned \"as is\" from <code>Empty</code> when atom should   be removed from results; - Empty expression <code>()</code> is an instance of the unit type which is mainly used by   functions with side effects which has no meaningful value to return.</p> <p>These atoms are not interpreted further as they are not a part of the minimal set of instructions and considered a data.</p>"},{"location":"minimal-metta/#eval","title":"eval","text":"<p><code>(eval &lt;atom&gt;)</code> is a first instruction which evaluates an atom passed as an argument. Evaluation is different for the grounded function calls (the expression with a grounded atom on a first position) and pure MeTTa expressions. For the pure MeTTa expression the interpreter searches the <code>(= &lt;atom&gt; &lt;var&gt;)</code> expression in the atomspace. The found values of the <code>&lt;var&gt;</code> are the result of evaluation. Execution of the grounded atom leads to the call of the foreign function passing the tail of the expression as arguments. For example <code>(+ 1 2)</code> calls the implementation of addition with <code>1</code> and <code>2</code> as arguments.  The list of atoms returned by the grounded function is a result of the evaluation in this case. A grounded function can have side effects as well. In both cases bindings of the <code>eval</code>'s argument are merged to the bindings of the result.</p> <p>Atomspace search can bring the list of results which is empty. When search returns no results then <code>NotReducible</code> atom is a result of the instruction. Grounded function can return a list of atoms, empty result, <code>ExecError::Runtime(&lt;message&gt;)</code> or <code>ExecError::NoReduce</code> result. The result of the instruction for a special values are the following: - <code>ExecError::Runtime(&lt;message&gt;)</code> returns <code>(Error &lt;original-atom&gt; &lt;message&gt;)</code>   atom; - <code>ExecError::NoReduce</code> returns <code>NotReducible</code> atom; - currently empty result removes result from the result set. It is done mainly   for compatibility. There is no valid reason to return an empty result from a   grounded function. Function can return <code>()/Empty/NotReducible</code> to express \"no   result\"/\"remove my result\"/\"not defined on data\".</p>"},{"location":"minimal-metta/#chain","title":"chain","text":"<p>Minimal MeTTa implements normal evaluation order (see Evaluation order. Arguments are passed to the function without evaluation. In case when argument should be evaluated before calling a function one can use <code>chain</code> instruction.</p> <p><code>chain</code>'s signature is <code>(chain &lt;atom&gt; &lt;var&gt; &lt;template&gt;)</code> and it is executed in two steps. <code>&lt;atom&gt;</code> argument is evaluated first and bindings of the evaluation result are merged to the bindings of the current result. After that <code>chain</code> substitutes all occurrences of <code>&lt;var&gt;</code> in <code>&lt;template&gt;</code> by the result of the evaluation and returns result of the substitution. When evaluation of the <code>&lt;atom&gt;</code> brings more than a single result <code>chain</code> returns one instance of the <code>&lt;template&gt;</code> expression for each result.</p>"},{"location":"minimal-metta/#functionreturn","title":"function/return","text":"<p><code>function</code> operation has the signature <code>(function &lt;atom&gt;)</code>. It evaluates the <code>&lt;atom&gt;</code> until it becomes <code>(return &lt;atom&gt;)</code>. Then <code>(function (return &lt;atom&gt;))</code> expression returns the <code>&lt;atom&gt;</code>.</p> <p>These operations are introduced for two reasons. First it should be possible to evaluate an atom until some result and prevent further result evaluation. This aspect is discussed in eval or return section.</p> <p>Second without having an abstraction of a function call it is difficult to debug the evaluation process. <code>function/return</code> allows representing nested function calls as a stack and provide controls to put the breakpoints on parts of this stack. Nevertheless using <code>chain</code> instead of <code>function</code> to implement the evaluation loop also allows representing stack in a natural form.</p>"},{"location":"minimal-metta/#unify","title":"unify","text":"<p><code>unify</code> operation allows conditioning on the results of the evaluation. <code>unify</code>'s signature is <code>(unify &lt;atom&gt; &lt;pattern&gt; &lt;then&gt; &lt;else&gt;)</code>. The operation matches <code>&lt;atom&gt;</code> with a <code>&lt;pattern&gt;</code>. If match is successful then it returns <code>&lt;then&gt;</code> atom and merges bindings of the original <code>&lt;atom&gt;</code> to resulting variable bindings. If matching is not successful then it returns the <code>&lt;else&gt;</code> branch with the original variable bindings.</p>"},{"location":"minimal-metta/#cons-atomdecons-atom","title":"cons-atom/decons-atom","text":"<p><code>cons-atom</code> and <code>decons-atom</code> allows constructing and deconstructing the expression atom from/to pair of the head and tail. <code>(decons-atom &lt;expr&gt;)</code> expects non-empty expression as an argument and returns a pair <code>(&lt;head&gt; &lt;tail&gt;)</code>. <code>(cons-atom &lt;head&gt; &lt;tail&gt;)</code> returns an expression where the first sub-atom is <code>&lt;head&gt;</code> and others are copied from <code>&lt;tail&gt;</code>.</p>"},{"location":"minimal-metta/#collapse-bind","title":"collapse-bind","text":"<p><code>collapse-bind</code> has the signature <code>(collapse-bind &lt;atom&gt;)</code>. It evaluates the <code>&lt;atom&gt;</code> and returns an expression which contains all alternative evaluations in a form <code>(&lt;atom&gt; &lt;bindings&gt;)</code>. <code>&lt;bindings&gt;</code> are represented in a form of a grounded atom.</p> <p><code>collapse-bind</code> is part of the inference control provided by a minimal MeTTa interpreter. For example it can be used to get all alternative interpretations of the atom and filter out ones which led to errors.</p> <p>Name <code>collapse-bind</code> is temporary and chosen to eliminate conflict with <code>collapse</code> which is part of the standard library.</p>"},{"location":"minimal-metta/#superpose-bind","title":"superpose-bind","text":"<p><code>superpose-bind</code> has the signature <code>(superpose-bind ((&lt;atom&gt; &lt;bindings&gt;) ...))</code>. It puts list of the results into the interpreter plan each pair as a separate alternative.</p> <p><code>superpose-bind</code> is an operation which is complement to the <code>collapse-bind</code>. <code>superpose-bind</code> takes the result of the <code>collapse-bind</code> as an input. Thus user can collect the list of alternatives using <code>collapse-bind</code> filter them and return filtered items to the plan using <code>superpose-bind</code>.</p>"},{"location":"minimal-metta/#scope-of-a-variable","title":"Scope of a variable","text":"<p>Each separately evaluated expression is a variable scope, and therefore variable names are treated as unique inside an expression. reason is that the whole expression is a variable scope. For example one can write the expression <code>(chain (unify $parent Bob () ()) $_ $parent)</code>. And value of the <code>$parent</code> is returned correctly.</p> <p>When a variable is passed as an argument to a function call and matched by a value then the value is assigned to the variable. If variable passed as an actual argument is matched by a formal argument variable then it is referenced by the formal argument variable. In this case the actual argument variable can receive a value outsides of its scope.</p> <p>For example the following code (written using MeTTa runner syntax) returns <code>B</code>: <pre><code>(= (foo $b) (function (chain (unify B $b () ()) $_ (return ()))))\n!(chain (eval (foo $a)) $_ $a)\n</code></pre></p> <p>If two separate expressions in the space have a variable with the same name, but the variables reside in independent scopes, then the variables are different. Consider the following example: <pre><code>(= (foo) (function (chain (unify A $a () ()) $_ (return ()))))\n!(chain (eval (foo)) $_ $a)\n</code></pre> Here the value will not be assigned to the <code>$a</code> from the caller expression because each of the two variables has a different scope and they do not reference each other.</p>"},{"location":"minimal-metta/#examples","title":"Examples","text":"<p>Examples of the programs written using minimal MeTTa interpreter:</p> <p>Recursive switch implementation:</p> <pre><code>(= (switch $atom $cases)\n  (function\n    (chain (decons-atom $cases) $list\n      (chain (eval (switch-internal $atom $list)) $res\n        (unify $res NotReducible (return Empty) (return $res)) ))))\n\n(= (switch-internal $atom (($pattern $template) $tail))\n  (function\n    (unify $atom $pattern\n      (return $template)\n      (chain (eval (switch $atom $tail)) $ret (return $ret)) )))\n</code></pre> <p>Evaluate atom in a loop until result is calculated:</p> <pre><code>(= (subst $atom $var $templ)\n  (unify $atom $var $templ\n    (Error (subst $atom $var $templ)\n      \\\"subst expects a variable as a second argument\\\") ))\n\n(= (reduce $atom $var $templ)\n  (chain (eval $atom) $res\n    (unify $res Empty\n    Empty\n    (unify $res (Error $a $m)\n      (Error $a $m)\n      (unify $res NotReducible\n        (eval (subst $atom $var $templ))\n        (eval (reduce $res $var $templ)) )))))\n</code></pre>"},{"location":"minimal-metta/#properties","title":"Properties","text":""},{"location":"minimal-metta/#turing-completeness","title":"Turing completeness","text":"<p>The following program implements a Turing machine using the minimal MeTTa instruction set (the full code of the example can be found here):</p> <pre><code>(= (tm $rule $state $tape)\n  (function (eval (tm-body $rule $state $tape))) )\n\n(= (tm-body $rule $state $tape)\n  (unify $state HALT\n    (return $tape)\n    (chain (eval (read $tape)) $char\n      (chain (eval ($rule $state $char)) $res\n        (unify $res ($next-state $next-char $dir)\n          (chain (eval (move $tape $next-char $dir)) $next-tape\n            (eval (tm-body $rule $next-state $next-tape)) )\n          (return (Error (tm-body $rule $state $tape) \\\"Incorrect state\\\")) )))))\n\n(= (read ($head $hole $tail)) $hole)\n\n(= (move ($head $hole $tail) $char N) ($head $char $tail))\n(= (move ($head $hole $tail) $char L) (function\n  (chain (cons-atom $char $head) $next-head\n    (chain (decons-atom $tail) $list\n      (unify $list ($next-hole $next-tail)\n        (return ($next-head $next-hole $next-tail))\n        (return ($next-head 0 ())) )))))\n(= (move ($head $hole $tail) $char R) (function\n  (chain (cons-atom $char $tail) $next-tail\n    (chain (decons-atom $head) $list\n      (unify $list ($next-hole $next-head)\n        (return ($next-head $next-hole $next-tail))\n        (return (() 0 $next-tail)) )))))\n</code></pre>"},{"location":"minimal-metta/#comparison-with-metta-operational-semantics","title":"Comparison with MeTTa Operational Semantics","text":"<p>One difference from MOPS [1] is that the minimal instruction set allows relatively easy write deterministic programs and non-determinism is injected only via matching and evaluation. <code>Query</code> and <code>Chain</code> from MOPS are very similar to <code>eval</code>. <code>Transform</code> is very similar to <code>unify</code>. <code>chain</code> has no analogue in MOPS. <code>cons-atom</code>/<code>decons-atom</code> to some extent are analogues of <code>AtomAdd</code>/<code>AtomRemove</code> in a sense that they can be used to change the state.</p>"},{"location":"minimal-metta/#partial-and-complete-functions","title":"Partial and complete functions","text":"<p>Each instruction in a minimal instruction set is a total function. Nevertheless <code>Empty</code> allows defining partial functions in MeTTa. For example partial <code>if</code> can be defined as follows: <pre><code>(= (if $condition $then) (unify $condition True $then Empty))\n</code></pre></p>"},{"location":"minimal-metta/#eval-or-return","title":"eval or return","text":"<p>Using <code>eval</code> to designate evaluation of the atom seems too verbose. But we need to give a programmer some way to designate whether the atom should be evaluated or not. <code>eval</code> marks atoms which should be evaluated. As an alternative to this solution we could mark atoms which should not be evaluated.</p> <p>Another related issue is that we need ability to make complex evaluations before making a substitution inside <code>chain</code>. For example <code>(chain (eval (foo a)) $x $x)</code> should be able to make and fully evaluate the call of the <code>foo</code> function before inserting the result into the template. We need to define the criteria which specifies when the nested operation is finished and what is the result. Also we need to be able represent evaluation loop inside the code.</p> <p>First version of the minimal interpreter continued the evaluation of the first argument of the <code>chain</code> until it becomes a non-minimal MeTTa instruction. But this approach is too verbose. If it is needed to chain some minimal MeTTa instruction without evaluation then such instruction should be wrapped into a non-minimal MeTTa expression and unwrapped after the substitution is made.</p> <pre><code>  (chain (quote (eval (foo))) $x\n    (unify $x (quote $y)\n      $y\n      (Error $x \"quote expression expected\") ))\n</code></pre> <p>To allow <code>chain</code> relying on the returned result of the first argument the <code>function/return</code> operations are introduced. When user needs to run a complex evaluation inside chain he may wrap it into the <code>function</code> operation. <code>function</code> evaluates its argument in a loop until <code>(return &lt;atom&gt;)</code> is returned. Then it returns the <code>&lt;atom&gt;</code> as a result. If one need to make a substitution it is possible using:</p> <pre><code>  (chain (function (return &lt;atom&gt;)) &lt;var&gt; &lt;templ&gt;)\n</code></pre> <p>One more option is to make <code>chain</code> (and other atoms which can have nested evaluation loops) recognize <code>return</code>. In such case the evaluation loop is executed by the <code>chain</code> itself and <code>function</code> instruction is not needed. Substitution gets the simpler form:</p> <pre><code>  (chain (return &lt;atom&gt;) &lt;var&gt; &lt;templ&gt;)\n</code></pre> <p>The downside of this approach is that loop represented by the outer operation <code>chain</code> and end of the loop represented by <code>return</code> are written in different contexts. Thus programmer should keep in mind that when some function is used from <code>chain</code> and it is not just a equality substitution then <code>return</code> should be used on each exit path while nothing in code of function points to this. Using <code>function</code> operation allows dividing functions on two classes: - functions which evaluate result in a loop and have to use <code>return</code>; - functions which just replace the calling expression by their bodies.</p>"},{"location":"minimal-metta/#metta-interpreter-written-in-rust","title":"MeTTa interpreter written in Rust","text":"<p>MeTTa interpreter written in minimal MeTTa has poor performance. To fix this the interpreter is rewritten in Rust. Rust implementation can be called using <code>(metta &lt;atom&gt; &lt;type&gt; &lt;space&gt;)</code> operation. To be able represent process of the interpretation as a list of steps and keep ability to control the inference <code>metta</code> doesn't evaluate passed atom till the end but instead analyses the atom and returns the plan written in minimal MeTTa. Plan includes steps written as a Rust functions. These steps are called using <code>(call_native &lt;name&gt; &lt;function&gt; &lt;args&gt;)</code> operation.</p> <p>Both <code>metta</code> and <code>call_native</code> could be written as a grounded operations and be a part of a standard library. But this requires grounded operations to be able returning bindings as a results. Returning bindings as results is a nice to have feature anyway to be able representing any functionality as a grounded atom. But it is not implemented yet.</p>"},{"location":"minimal-metta/#future-work","title":"Future work","text":""},{"location":"minimal-metta/#explicit-atomspace-variable-bindings","title":"Explicit atomspace variable bindings","text":"<p>Current implementation implicitly keeps and applies variable bindings during the process of the interpretation. Explicit bindings are used to implement <code>collapse-bind</code> where they are absolutely necessary. Bindings can be easily made explicit everywhere but the value of explicit bindings is not obvious see [discussion in issue</p>"},{"location":"minimal-metta/#290httpsgithubcomtrueagi-iohyperon-experimentalissues290issuecomment-1541314289","title":"290](https://github.com/trueagi-io/hyperon-experimental/issues/290#issuecomment-1541314289).","text":"<p>Making atomspace part of the explicit context could make import semantics more straightforward. In the current implementation of the minimal instruction set it is needed to explicitly pass the atomspace to the interpreter because otherwise grounded <code>get-type</code> function didn't work properly. It also could allow defining <code>eval</code> via <code>unify</code> which minimizes the number of instructions and allows defining <code>eval</code> in a MeTTa program itself. Which in turn allows defining different versions of <code>eval</code> to program different kinds of chaining. Nevertheless defining <code>eval</code> through <code>unify</code> requires rework of the grounded functions interface to allow calling them by executing <code>unify</code> instructions. Which is an interesting direction to follow.</p>"},{"location":"minimal-metta/#special-matching-syntax","title":"Special matching syntax","text":"<p>Sometimes it is convenient to change the semantics of the matching within a pattern. Some real examples are provided below. One possible way to extend matching syntax is embrace atoms by expressions with matching modifier on a first position. For instance <code>(:&lt;mod&gt; &lt;atom&gt;)</code> could apply <code>&lt;mod&gt;</code> rule to match the <code>&lt;atom&gt;</code>. How to eliminate interference of this syntax with symbol atoms used by programmers is an open question.</p>"},{"location":"minimal-metta/#syntax-to-match-atom-by-equality","title":"Syntax to match atom by equality","text":"<p>In many situations we need to check that atom is equal to some symbol. <code>unify</code> doesn't work well in such cases because when checked atom is a variable it is matched with anything (for instance <code>(unify $x Empty then else)</code> returns <code>then</code>). It would be convenient to have a special syntax to match the atom by equality. For instance <code>(unify &lt;atom&gt; (:= Empty) then else)</code> should match <code>&lt;atom&gt;</code> with pattern only when <code>&lt;atom&gt;</code> is <code>Empty</code>.</p>"},{"location":"minimal-metta/#syntax-to-match-part-of-the-expression","title":"Syntax to match part of the expression","text":"<p>We could have a specific syntax which would allow matching part of the expressions. For example such syntax could be used to match head and tail of the expression without using <code>cons-atom</code>/<code>decons-atom</code>. Another example is matching part of the expression with some gap, i.e. <code>(A ... D ...)</code> could match <code>(A B C D E)</code> atom.</p>"},{"location":"minimal-metta/#links","title":"Links","text":"<ol> <li>Lucius Gregory Meredith, Ben Goertzel, Jonathan Warrell, and Adam    Vandervorst. Meta-MeTTa: an operational semantics for MeTTa.    https://raw.githubusercontent.com/leithaus/rho4u/main/ai/mops/mops.pdf</li> </ol>"},{"location":"modules_dev/","title":"MeTTa Modules (Rust / Python Developer Documentation)","text":"<p>TODO: Integrate this documentation within the larger MeTTa Book</p> <p>Modules are implementations of free-standing MeTTa functionality that can be imported into other MeTTa modules or programs.  Modules may be implemented in MeTTa code itself, but they may also include functionality implemented with, or linked from host languages such as Rust, C, or Python.  Modules may include additional files and resources as well.</p> <p>NOTE: Importantly, a module can have sub-module dependencies, aka \"downward\" dependencies, but it cannot have \"upward\" dependencies, ie. dependencies on the client code importing the module.</p>"},{"location":"modules_dev/#what-is-a-module","title":"What is a Module?","text":"<p>Fundamentally a module in a persistent encapsulation of a context within which MeTTa code can run.  Every module has a unique [Space] (and also a [Tokenizer], for now).  For MeTTa code running within the context of a module, the <code>&amp;self</code> token will resolve to the module's space.</p> <p>A loaded module is represented with the [MettaMod] struct.  In addition to a [Space] and a [Tokenizer], a module may also contain a filesystem path to the module's resources, the sub-modules imported by the module, a [ModuleDescriptor] object, and a [PkgInfo] struct, the latter of which are documented in the Package Management section.</p> <p>To execute code in the context of any loaded module, use the [RunnerState::new_with_module] method.</p>"},{"location":"modules_dev/#loading-a-module","title":"Loading a Module","text":"<p>Modules are loaded into a [Metta] runner using one of the module loading methods: [Metta::load_module_direct], [Metta::load_module_at_path], or [RunContext::load_module].  Loaded modules are referred to with a [ModId].</p> <p>Fundamentally, all modules are loaded via a loader object that implements the [ModuleLoader] trait.  Irrespective of the module's original format or host language, a loader object's [ModuleLoader::load] function ultimately loads the module into the runner.</p>"},{"location":"modules_dev/#module-names-name-paths","title":"Module Names &amp; Name Paths","text":"<p>Each loaded module must have a name.  A legal module name is an ascii string, containing only alpha-numeric characters plus <code>_</code> and <code>-</code>.</p> <p>If module loading is initiated through the MeTTa <code>import!</code> operation or the corresponding [RunContext::load_module] API call, then the module name will be used to identify the module to load, following the logic in the Module Name Resolution section.</p> <p>Direct module-loading API calls such as [Metta::load_module_direct], [Metta::load_module_at_path], or [Metta::load_module_alias] all take an explicit module name or name path.</p> <p>Upon loading, the module is subsequently placed into the module name path hierarchy, where <code>top</code> is always the name for the top-module in the runner and the <code>':'</code> character acts as the separator.  An example module name path looks like <code>top:mod1:sub_a</code>, and an example hierarchy is illustrated below.</p> <pre><code>top = 0\n \u251c\u2500corelib = 1\n \u251c\u2500stdlib = 2\n \u251c\u2500mod1 = 3\n \u2502  \u2514\u2500sub_a = 4\n \u2514\u2500mod2 = 5\n    \u2514\u2500sub_b = 6\n</code></pre> <p>In addition, the <code>self</code> token may be used at the beginning of a module name path to refer to the currently running module context.  In the context of the top module, <code>top</code> and <code>self</code> should have an identical meaning.</p> <p>Step-by-step, the MeTTa code: <pre><code>!(import! &amp;self some_module)\n</code></pre> will cause the name <code>some_module</code> to be resolved into a specific module instance; if that module is not yet loaded then it will be, and finally the module will be imported, in totality, into the currently executing module (context).</p> <p></p> <p>NOTE: The same loaded module (with the same ModId) may appear multiple times in the hierarchy, sometimes with different names.  This could be the effect of an \"import as\" operation or making a module alias.</p> <p>NOTE: The same module name may occur in multiple places in the hierarchy, and there is no guaranteed a name will always refer to the same module.  However, within a given node of the module name hierarchy, a module name will always be unique.</p>"},{"location":"modules_dev/#importing-a-module","title":"Importing a Module","text":"<p>A module is imported into another module using one of the import methods:  - [MettaMod::import_dependency_as], corresponding to <code>import module as name</code>  - [MettaMod::import_all_from_dependency], corresponding to <code>import * from module</code>  - [MettaMod::import_item_from_dependency_as], corresponding to <code>import item from module as name</code></p> <p>Once imported, a sub-module is accessed via an embedded [Space] atom in the destination module's space, [Tokenizer] entries for accessing the source module's space, tokens, or a combination of the two.</p>"},{"location":"modules_dev/#behavior-wip","title":"Behavior WIP","text":"<p>TODO: The precise semantics of importing (in other words, linking) are still under discussion and development.  Specifically we may wish to provide a mechanism to explicitly declare what is exported from a module (and thus available for import).  This would be similar to the <code>export</code> key words in some languages, or the <code>pub</code> visibility qualifiers in Rust.</p> <p>In addition, some changes will be needed so that [Tokenizer] entries can be imported and accessed between modules.  Currently Tokenizer entries are only imported using the [MettaMod::import_all_from_dependency] method, and the mechanism at work may lead to unreachable Tokenizer entries.</p> <p>Some issues regarding this are: [https://github.com/trueagi-io/hyperon-experimental/issues/509][https://github.com/trueagi-io/hyperon-experimental/issues/511] [https://github.com/trueagi-io/hyperon-experimental/issues/510]</p> <p>More discussion on these topics is in the section: \"Importing / Linking\" of the <code>modules_internal_discussion.md</code> file.</p>"},{"location":"modules_dev/#package-management","title":"Package Management","text":"<p>Package Management is the set of features that allow for: - searching for modules across multiple locations (Catalogs) - expressing version requirements and selecting compatible versions - loading modules from files or other locations</p> <p>Modularity is a fundamental and inseparable aspect of the MeTTa runner, but Package Management features could be optional.</p>"},{"location":"modules_dev/#module-file-formats","title":"Module File Formats","text":"<p>Modules may be loaded from files and other file-system-like resources (for example, a github repo) using the objects that implement the [FsModuleFormat] trait.  This trait contains the interface to interpret a file or a directory and instantiate a [ModuleLoader] to load the module(s) contained within.</p> <p>The objects [SingleFileModuleFmt] and [DirModuleFmt] are part of the default environment and are capable of loading MeTTa modules from single <code>.metta</code> files and directories containing a <code>module.metta</code> file respectively.  Additionally, the <code>hyperon</code> Python module contains a [FsModuleFormat] for loading MeTTa modules from Python modules - both stand-alone <code>.py</code> files as well as directories containing an <code>__init__.py</code> file.</p> <p>More information on the individual module file formats is available in the MeTTa usage documentation and MeTTa Python documentation respectively.</p>"},{"location":"modules_dev/#the-pkginfo-structure","title":"The PkgInfo Structure","text":"<p>Each module has an associated [PkgInfo] structure, which provides the module author a place to specify meta-data about the module and express requirements for the module's dependencies.  Additionally a [PkgInfo] can provide explicit loading instructions such as file system paths or github URLs for dependent modules.  The [PkgInfo] structure is the same concept as the Cargo.toml file used in Cargo/Rust.</p> <p>The [PkgInfo] should be initialized inside the module's loader function.  If it is not initialized then default values will be used.</p> <p>The fields of the [PkgInfo] struct are documented in the Rust MeTTa documentation here.</p> <p>TODO: PkgInfo documentation also belongs in user-facing docs.  In that section, cover how to specify the pkginfo as a MeTTa structure and/or in a <code>_pkg-info.metta</code> or <code>_pkg-info.json</code> file as opposed to as a Rust struct.</p>"},{"location":"modules_dev/#module-name-resolution","title":"Module Name Resolution","text":"<p>When MeTTa code executes the <code>!(import! &amp;space some_module)</code> operation, the module name needs to be mapped to a loaded or loadable module.  This process occurs according to the logic described by the flowchart below.</p> <p></p> <ol> <li> <p>First the module name is checked against the modules which are already loaded within the context of the running module.  This ensures the same instance of a shared dependency will be loaded everywhere.</p> </li> <li> <p>If a loaded module is not available, the [PkgInfo] will be checked for a corresponding entry.  If an entry specifies a specific location in the file system or a remote repository, then the module will be loaded from that location.  Additionally, the [PkgInfo] may specify version requirements for use by the catalog in locating and selecting an accaptable module.</p> </li> <li> <p>Finally, the Catalogs from the Environment will be queried in priority order. (See the Catalogs section below)</p> </li> </ol> <p>By default, the built-in search paths / catalogs are:</p> <ol> <li>The module's own <code>resource</code> directory, if it has one</li> <li>The <code>hyperon/exts/</code> directory, if the Hyperon Python module is running</li> <li>The MeTTa config <code>modules</code> directory, at an OS-specific location.</li> </ol> <p>Depending on the host OS, the config directory locations will be: * Linux: ~/.config/metta/ * Windows: ~\\AppData\\Roaming\\TrueAGI\\metta\\config\\ * Mac: ~/Library/Application Support/io.TrueAGI.metta/</p> <p>In the future we may create a centralized module catalog along the lines of <code>PyPI</code> or <code>crates.io</code>.</p>"},{"location":"modules_dev/#catalogs","title":"Catalogs","text":"<p>An object that implements the [ModuleCatalog] trait exposes an interface to locate modules based on name and version constraints, and create [ModuleLoader] objects to retrieve and load those modules.</p> <p>One built-in [ModuleCatalog] object type is the [DirCatalog].  As described in the \"Module File Formats\" section, a [DirCatalog] uses a collection of [FsModuleFormat] objects to export a catalog of modules contained within its associated directory.</p> <p>Additional catalogs may be implemented for other module repository formats or protocols - for example a central package service similar to <code>PyPI</code> or <code>crates.io</code>, as mentioned earlier.</p>"},{"location":"modules_dev/#implementing-a-moduleloader","title":"Implementing a [ModuleLoader]","text":"<p>All modules are ultimately loaded programmatically through the MeTTa API, and it's the role of a [ModuleLoader] to make the necessary API calls.</p> <p>The [ModuleLoader::load] method ultimately sets up the module.  Each module has its own [Space] so the space needs to be created first.  Then the module must be initialized using the [RunContext::init_self_module] method.</p> <p>After <code>init_self_module</code> has run, it is now legal to access the module data stricture using [RunContext::module] or [RunContext::module_mut], as well as enqueuing MeTTa code or additional operations to run.</p> <p>An example <code>load</code> method implementation is here: <pre><code>fn load(&amp;self, context: &amp;mut RunContext, descriptor: ModuleDescriptor) -&gt; Result&lt;(), String&gt; {\n\n    let space = DynSpace::new(GroundingSpace::new());\n    let resource_dir = std::path::PathBuf::from(\"/tmp/test_module_resources\")\n    context.init_self_module(descriptor, space, Some(resource_dir.into()));\n\n    let parser = SExprParser::new(METTA_PROGRAM_TEXT);\n    context.push_parser(Box::new(parser));\n\n    Ok(())\n}\n</code></pre></p>"},{"location":"modules_internal_discussion/","title":"Module Design Discussion - Open Questions","text":""},{"location":"modules_internal_discussion/#overview-what-does-module-mean","title":"Overview: What does Module mean?","text":"<p>When I began this task, I conflated the design-space of modularity with package management, however the two are separate and distinct.  I began the task by designing and implementing a package manager, but the current MeTTa semantics lack the fundamental modularity constructs that are a prerequisite for robust package management.</p> <p>It may seem like a tautology, but I feel it bears repeating that the purpose of modules is modularity.  In other words, isolating the implementation and incidental behaviors of some \"module\" code from other \"client\" code.</p> <p>Definition: A module is unit of functionality that can be loaded into a MeTTa runner and used by other MeTTa code without requiring modification of the module, regardless of the location or the format from which the module was loaded.</p>"},{"location":"modules_internal_discussion/#desiderata","title":"Desiderata","text":"<ul> <li>A module should be able to be loaded and tested independently of client code that might load it</li> <li>A module should express its own sub-module dependencies</li> <li>A module should not rely on the client to import sub-dependencies or configure the environment for the module (\"environment\" used here in a loose sense, not the Environment object)</li> <li>A corollary to the above is that a module should not be affected by things the client does aside from the interactions through the module's interface.  For example, a client shouldn't be able to accidentally break a module's implementation by defining atoms or tokens in the client code. </li> </ul> <p>By analogy, Rust <code>mod</code>s meet these criteria, and C header files do not.  Shared libraries, on the other hand, are modules according to the criteria above.</p>"},{"location":"modules_internal_discussion/#mettamod-struct","title":"MettaMod struct","text":"<p>The [MettaMod] struct essentially takes the place of a \"Loading Runner\" in the prior code base.  The major difference being that the MettaMod continues to exist even after the module loader code has evaluated.  More discussion can be found in the \"What is a Module?\" section of the main module docs.</p>"},{"location":"modules_internal_discussion/#question-topic-1-importing-linking","title":"Question Topic 1: Importing &amp; Linking","text":"<p>To discuss import behavior, we need to discuss 3 distinct cases separately.  The cases are:</p> <ul> <li>Import As <code>import module as name</code></li> <li>Import All (aka import *) <code>import * from module</code></li> <li>Import Item <code>import item from module as name</code></li> </ul> <p>In parallel, a discussion on this topic exists here: https://github.com/trueagi-io/hyperon-experimental/issues/509 although this document presently represents a more thorough treatment of the topic.</p>"},{"location":"modules_internal_discussion/#import-as","title":"Import As","text":"<p>This is probably the most straightforward of the three import behaviors.  Currently the code registers a new Tokenizer entry in the destination module's Tokenizer with the space of sub-module.  This behavior is adequate and does the right thing for allowing the sub-module's space to be accessed within the context of the client module.</p> <p>This is implemented by the [MettaMod::import_dependency_as] method.</p> <p>Outstanding Issue: This implementation doesn't provide any way to access tokenizer entries that are part of the sub-module.</p>"},{"location":"modules_internal_discussion/#import-all","title":"Import All","text":"<p>Conceptually this operation imports the entire contents of a sub-module into the target module.  Another way to think about this is overlaying the space and tokens of the sub-module onto the client module.  In practice, given the behavior of the interpreter, the current implementation is a bit convoluted.</p> <p>Currently the implementation leverages the behavior that a nested Space Grounded Atom will behave as an extension of the Space containing it.</p> <p>The import code makes a deep-copy of the sub-module's space, then strips away space atoms that are associated with dependency's own sub-modules (2<sup>nd</sup> order sub-modules), before finally adding the cloned sub-space as a grounded atom into the client's space.</p> <p>After that, the implementation imports the all of the new secondary transitive dependencies into the client, and finally it merges all tokenizer entries from the sub-module into the client.</p> <p>This \"import all\" behavior is implemented by the [MettaMod::import_all_from_dependency] method.</p>"},{"location":"modules_internal_discussion/#this-current-implementation-some-issues","title":"This current implementation some issues","text":"<ul> <li> <p>Inefficient Space Clone: Deep-cloning the sub-modules's space on every import is costly, considering it should be possible to import functionality by reference.  This potentially leads to many copies of the same sub-modules in memory and defeats one of the benefits of modularity.  One potential way to fix this it to create a [Space] implementation that I'll call <code>ModuleSpace</code>, which wraps the module's <code>&amp;self</code> space regardless of its underlying type.  <code>ModuleSpace</code> holds references to the sub-modules' individual spaces and controls which how the sub-module spaces will be combined.  I have not yet tried to implement this so I don't know what other problems may come up.</p> </li> <li> <p>Private Sub-Modules shouldn't be lifted: All transitive dependency sub-modules are lifted into the client scope, including private sub-modules.  Assuming we have a fix for the above, addressing this point may be as simple as not stripping and lifting private sub-modules, so that may be an easy fix.</p> </li> <li> <p>Redundant Tokenizer Entries: Currently Tokenizer entries imported from sub-modules may be inaccessible because they are superseded by existing entries in the module's Tokenizer.  A partial solution here might be to implement something like a \"Layered Tokenizer\" as described here: https://github.com/trueagi-io/hyperon-experimental/issues/408#issuecomment-1839196513</p> </li> </ul>"},{"location":"modules_internal_discussion/#explicit-exports-or-visibility-qualifiers","title":"Explicit exports or visibility qualifiers","text":"<p>Most languages that support modularity allow a module to declare a subset of the objects as available for export.  Sometimes this is done with visibility qualifiers, (for example <code>pub</code> in Rust), or in other situations this is accomplished via the ABI and header files, as with shared libraries imported in C &amp; C++.</p> <p>Explicit control over exports would solve the problem of duplicated or conflicting transitive imports of sub-modules, because private sub-modules would not be exported.</p>"},{"location":"modules_internal_discussion/#import-item","title":"Import Item","text":"<p>The <code>import item from module [as name]</code> is implemented with the [MettaMod::import_item_from_dependency_as] method.  However there is no <code>stdlib</code> operation that calls it, so it's currently inaccessible from MeTTa code.</p>"},{"location":"modules_internal_discussion/#tokenizer-entries-dont-always-have-names-to-import","title":"Tokenizer entries don't always have names to import","text":"<p>When we want to import a tokenizer entry from a sub-module, we need a name to refer to it.  But currently Tokenizer entries don't have names.  By itself, this problem is easy to address, but we should consider our choice of solution in light of the other choices we need to make for the MeTTa language.</p> <p>This issue is discussed in more detail here: https://github.com/trueagi-io/hyperon-experimental/issues/510</p> <p>One solution, as described on github, is to require Tokenizer entries to have corresponding items in the module's Space.</p>"},{"location":"modules_internal_discussion/#question-topic-2-sub-module-version-resolution-discussion","title":"Question Topic 2: Sub-Module Version Resolution Discussion","text":""},{"location":"modules_internal_discussion/#background","title":"Background","text":"<p>There are two desiderata which are at odds with each other and must be balanced:</p> <ul> <li> <p>Implementation sub-modules: We want sub-module dependencies not to interfere with each other as much as is possible.  For example, ModA should be able to import ModC, and ModB should be able to import a different version of ModC.  This should be allowed as long as both ModA and ModB use ModC within their internal implementation.  Within this document I will call this pattern an \"Implementation\" sub-module.</p> </li> <li> <p>Interface sub-modules If ModA imports ModC and uses functionality from ModC in its interface, then ClientMod will transitively import ModC when it imports ModA.  In effect this means the dependent sub-module's version becomes part of the module's interface.  Therefore, within this document, I will call this an \"Interface\" sub-module.  If ClientMod imports ModA and ModB, which both import ModC as an Interface sub-module, then the version (instance) of ModC must be the same between ModA and ModB.</p> </li> </ul>"},{"location":"modules_internal_discussion/#sub-module-set-satisfiability","title":"Sub-Module set satisfiability","text":"<p>The versions of transitive Interface sub-modules must be reconciled such that a given client imports exactly one version of each dependent sub-module, even when that sub-module is shared between two or more other dependents.  Finding the compatible module versions is a flavor of the Satisfiability Problem.</p> <p>Reasonably sophisticated package managers such as Cargo include a Satisfiability Solver, which will attempt to find a set of sub-module versions that satisfy the requirements for each client that imports each dependency.  I believe we will ultimately want to add a solver to MeTTa too, someday.  However this doesn't currently exist.  MeTTa as a language is well-suited to implementing a solver.</p> <p>Until we add a solver to the MeTTa Package Manager, the module resolution logic will progress sequentially with no ability to backtrack.  This means that we will need to rely on each module's author to manually determine a workable set of sub-module versions for themselves.  Then the specific (or narrower) version requirements can be added to the module's [PkgInfo].</p> <p>Current State of the Code: Version requirements for sub-modules are not yet implemented so this is a non-issue in the present implementation.</p>"},{"location":"modules_internal_discussion/#module-namespace-scope","title":"Module Namespace Scope","text":"<p>When a module is loaded, the module's name may be registered in the runner's module namespace, so that subsequent attempts to resolve the same module name elsewhere in the runner will return the already-loaded module as opposed to causing a new instance of the module to be loaded.</p> <p>The question here is which behavior we want for the module namespace:</p> <ul> <li> <p>Proposal A: Global Scope:  This means every module is effectively an Interface Module, and only one version of a given module can be loaded in the same runner.  This is the approach taken by both Cargo and Python (but for different reasons in each case), and a number of other package managers.  However, the reasons that have driven other package managers towards this design don't necessarily apply to MeTTa, and I believe we can support private Implementation sub-modules.  Therefore I do not advocate for this design.</p> </li> <li> <p>Proposal B: Conservative Hierarchical Scope:  Within this design, each module name only propagates upwards to its client if it needs to, or is explicitly re-exported.  This means that Interface modules must be exported or marked some other way.  It also complicates the Sat Solver (see above) as it would need to operate over multiple sets with some partial intersections between them.  I believe this is probably the \"right\" design, but also the most work to implement.</p> </li> <li> <p>Proposal C: 2-Layer \"Public vs. Private\" Scope:  This is the way the code currently works.  Each imported module may be \"Public\", in which case it is available by name to all other modules in the runner, or it may be \"Private\", in which case it is loaded only for the client module that resolves it.  This is a \"poor man's\" version of Proposal B.  However, it has many problematic edge cases so I would prefer to implement Proposal B.</p> </li> </ul> <p>For either Proposal B or C, we probably want to add some form of linting / checking, so users don't accidentally shoot themselves in the foot by exporting items that depend on private (Implementation) sub-modules.  In other words, public interfaces must not include non-public objects.</p> <p>UPDATE: A version of B is now implemented in the code, with the caveat that nothing is private (visibility constructs don't exist for MeTTa modules at all) but sub-modules can be contained within the namespace of their respective parents.</p>"},{"location":"modules_internal_discussion/#remaining-implementation-work","title":"Remaining implementation work","text":"<p>LP-TODO, search code for remaining TODO comments and collect them here so I can prioritize remaining work</p>"},{"location":"modules_internal_discussion/#moduledescriptor-should-be-part-of-pkg_management-features","title":"ModuleDescriptor should be part of pkg_management features","text":"<p>However, we still need a way to globally (within a runner) disambiguate a module.  Currently that's done with a ModuleDescriptor.  My proposal is to implement the hierarchical module name-space.  It's pretty clear that's the direction we want to go, as several open-issues are pointing that way.</p> <p>Then the loaded module table will use full module path instead of ModuleDescriptor, and ModuleDescriptor will be only for modules in a catalog that are not yet loaded.</p>"},{"location":"modules_internal_discussion/#try-stripping-but-not-lifting-private-transitive-imports-in-import_all","title":"Try stripping but not lifting private transitive imports in <code>import_all</code>","text":"<p>In response to the \"Private Sub-Modules shouldn't be lifted\" section, in a discussino with Vitaly I realized perhaps all of the necessary interfaces to transitive sub-modules might be acomplished within the sub-module's space.  So therefore we may be able to get away with stripping but not lifting the private dependencies.</p>"},{"location":"modules_internal_discussion/#catalog-for-all-python-modules","title":"Catalog for All Python modules","text":"<p>Need to implement a ModuleCatalog that publishes all Python modules as MeTTa modules.  This will achieve parity with the current implementation and re-enable the practice of using <code>pip</code> to install MeTTa modules.  Additionally, we may want to support hierarchical module path imports, so that the MeTTa import operation is able to traverse the python module hierarchy to load and import nested Python modules.</p>"},{"location":"modules_internal_discussion/#atom-serde-serde-format-to-encode-any-structured-data-into-atoms","title":"\"atom-serde\", serde format to encode any structured data into atoms","text":"<p>This relates to package management because we want to represent a PkgInfo structure as atoms within MeTTa code.  One reusable appraoch to this is to make a serde format that targets atoms.  This can then be leveraged for many API structures such as the parse tree, etc.</p> <p>There is a discussion on the topic here: https://github.com/trueagi-io/hyperon-experimental/issues/455</p> <p>Nil's work here https://github.com/trueagi-io/protobuf-metta and more generally this thread https://chat.singularitynet.io/chat/pl/u8u9jzrnmp85d8ounmpbmjukyc has raised the idea that we pursue a format that relies on a structure definition that uses the MeTTa type-system, rather than trying to create a self-describing format.</p>"},{"location":"modules_internal_discussion/#circular-import-testing-guard-rails","title":"Circular-import testing &amp; guard-rails","text":"<p>I need to make sure the right things happen when circular loading / imports are attempted.  More dicussion here: https://github.com/trueagi-io/hyperon-experimental/pull/580#discussion_r1491178245</p>"},{"location":"reference/atoms/","title":"Atoms","text":""},{"location":"reference/atoms/#hyperon.atoms","title":"atoms","text":"<p>The Python wrapper for Hyperon Atom Rust types</p>"},{"location":"reference/atoms/#hyperon.atoms.Atom","title":"Atom","text":"<pre><code>Atom(catom)\n</code></pre> <p>Represents an Atom of any type</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize an Atom\"\"\"\n    self.catom = catom\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.get_metatype","title":"get_metatype","text":"<pre><code>get_metatype()\n</code></pre> <p>Gets the metatype (kind) of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_metatype(self):\n    \"\"\"Gets the metatype (kind) of the current Atom instance\"\"\"\n    return hp.atom_get_metatype(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.AtomType","title":"AtomType","text":"<p>Defines all Atom types</p>"},{"location":"reference/atoms/#hyperon.atoms.Bindings","title":"Bindings","text":"<pre><code>Bindings(bindings: Union[CBindings, None] = None)\n</code></pre> <p>Interface for working with atom matching and variable-to-atom binding.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, bindings: Union[hp.CBindings, None] = None):\n    \"\"\"Initializes with or without pre-existing bindings.\"\"\"\n    if bindings is None:\n        self.cbindings = hp.bindings_new()\n    else:\n        self.cbindings = bindings\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memodict={})\n</code></pre> <p>Makes a \"deep copy\" of the bindings.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __deepcopy__(self, memodict={}):\n    \"\"\"Makes a \"deep copy\" of the bindings.\"\"\"\n    return self.clone()\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees the binding resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees the binding resources.\"\"\"\n    if self.cbindings is not None:\n        hp.bindings_free(self.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>For context management.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __enter__(self):\n    \"\"\"For context management.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two bindings objects contain identical associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two bindings objects contain identical associations.\"\"\"\n    return (isinstance(other, Bindings) and\n            hp.bindings_eq(self.cbindings, other.cbindings))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Frees resources on exit.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Frees resources on exit.\"\"\"\n    if self.cbindings is not None:\n        hp.bindings_free(self.cbindings)\n        self.cbindings = None\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a text description of the bindings</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a text description of the bindings\"\"\"\n    return hp.bindings_to_str(self.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.add_var_binding","title":"add_var_binding","text":"<pre><code>add_var_binding(var: VariableAtom, atom: Atom) -&gt; bool\n</code></pre> <p>Adds a binding between a variable and an Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def add_var_binding(self, var: VariableAtom, atom: Atom) -&gt; bool:\n    \"\"\"Adds a binding between a variable and an Atom.\"\"\"\n    return hp.bindings_add_var_binding(self.cbindings, var.catom, atom.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.clone","title":"clone","text":"<pre><code>clone()\n</code></pre> <p>Makes a \"deep copy\" of the bindings</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def clone(self):\n    \"\"\"Makes a \"deep copy\" of the bindings\"\"\"\n    return Bindings(hp.bindings_clone(self.cbindings))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Checks if a bindings contains no associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Checks if a bindings contains no associations.\"\"\"\n    return hp.bindings_is_empty(self.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.iterator","title":"iterator","text":"<pre><code>iterator()\n</code></pre> <p>Returns an iterator over the variable-atom pairs in the bindings</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterator(self):\n    \"\"\"Returns an iterator over the variable-atom pairs in the bindings\"\"\"\n    res = hp.bindings_list(self.cbindings)\n    result = [(Atom._from_catom(r[0]), Atom._from_catom(r[1])) for r in res]\n    return iter(result)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.merge","title":"merge","text":"<pre><code>merge(other: Bindings) -&gt; BindingsSet\n</code></pre> <p>Merges with another Bindings instance, into a Bindings Set.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def merge(self, other: 'Bindings') -&gt; 'BindingsSet':\n    \"\"\"Merges with another Bindings instance, into a Bindings Set.\"\"\"\n    return BindingsSet(hp.bindings_merge(self.cbindings, other.cbindings))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.narrow_vars","title":"narrow_vars","text":"<pre><code>narrow_vars(vars)\n</code></pre> <p>Keeps only specific variable associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def narrow_vars(self, vars ):\n    \"\"\"Keeps only specific variable associations.\"\"\"\n    cvars = hp.CVecAtom = hp.atom_vec_new()\n    for var in vars:\n        hp.atom_vec_push(cvars, var.catom)\n    hp.bindings_narrow_vars(self.cbindings, cvars)\n    hp.atom_vec_free(cvars)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.resolve","title":"resolve","text":"<pre><code>resolve(var: VariableAtom) -&gt; Union[Atom, None]\n</code></pre> <p>Finds the atom for a given variable</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def resolve(self, var: VariableAtom) -&gt; Union[Atom, None]:\n    \"\"\"Finds the atom for a given variable\"\"\"\n    raw_atom = hp.bindings_resolve(self.cbindings, var.catom)\n    return None if raw_atom is None else Atom._from_catom(raw_atom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet","title":"BindingsSet","text":"<pre><code>BindingsSet(input: Union[CBindingsSet, Bindings, None] = None)\n</code></pre> <p>Represents a set of Bindings frames, potentially expressing all possible matches produced by a match operation.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, input: Union[hp.CBindingsSet, Bindings, None] = None):\n    \"\"\"Initializes with optional input.\"\"\"\n    self.shadow_list = None # A lazily initialized list that shadows the BindingsSet values for indexed access\n    if input is None:\n        self.c_set = hp.bindings_set_single()\n    elif isinstance(input, Bindings):\n        self.c_set = hp.bindings_set_from_bindings(input.cbindings)\n    else:\n        self.c_set = input\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memodict={})\n</code></pre> <p>Makes a \"deep copy\" of a BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __deepcopy__(self, memodict={}):\n    \"\"\"Makes a \"deep copy\" of a BindingsSet\"\"\"\n    return self.clone()\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees the BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees the BindingsSet\"\"\"\n    if self.c_set is not None:\n        hp.bindings_set_free(self.c_set)\n        self.c_set = None\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>For context management.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __enter__(self):\n    \"\"\"For context management.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if other BindingsSet contains identical associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if other BindingsSet contains identical associations.\"\"\"\n    return (isinstance(other, BindingsSet) and\n            hp.bindings_set_eq(self.c_set, other.c_set))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Frees resources on exit.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Frees resources on exit.\"\"\"\n    if self.c_set is not None:\n        hp.bindings_set_free(self.c_set)\n        self.c_set = None\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Gets a Bindings frame by index</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Gets a Bindings frame by index\"\"\"\n    if self.shadow_list is None:\n        result = hp.bindings_set_unpack(self.c_set)\n        self.shadow_list = [{k: Atom._from_catom(v) for k, v in bindings.items()} for bindings in result]\n    return self.shadow_list[key]\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a text description of a BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a text description of a BindingsSet\"\"\"\n    return hp.bindings_set_to_str(self.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.add_var_binding","title":"add_var_binding","text":"<pre><code>add_var_binding(var: VariableAtom, value: Atom) -&gt; bool\n</code></pre> <p>Adds a new variable to atom association to every Bindings frame in a BindingsSet.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def add_var_binding(self, var: VariableAtom, value: Atom) -&gt; bool:\n    \"\"\"Adds a new variable to atom association to every Bindings frame in a\n    BindingsSet.\n    \"\"\"\n    self.shadow_list = None\n    return hp.bindings_set_add_var_binding(self.c_set, var.catom, value.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.add_var_equality","title":"add_var_equality","text":"<pre><code>add_var_equality(a: Atom, b: Atom) -&gt; bool\n</code></pre> <p>Asserts equality between two Variable atoms in a BindingsSet.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def add_var_equality(self, a: Atom, b: Atom) -&gt; bool:\n    \"\"\"Asserts equality between two Variable atoms in a BindingsSet.\"\"\"\n    self.shadow_list = None\n    return hp.bindings_set_add_var_equality(self.c_set, a.catom, b.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.clone","title":"clone","text":"<pre><code>clone()\n</code></pre> <p>Makes a \"deep copy\" of a BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def clone(self):\n    \"\"\"Makes a \"deep copy\" of a BindingsSet\"\"\"\n    return BindingsSet(hp.bindings_set_clone(self.c_set))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.empty","title":"empty","text":"<pre><code>empty()\n</code></pre> <p>Creates a new BindingsSet without any Bindings frames. Conceptually, this means no valid matches exist.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def empty():\n    \"\"\"Creates a new BindingsSet without any Bindings frames.\n    Conceptually, this means no valid matches exist.\n    \"\"\"\n    return BindingsSet(hp.bindings_set_empty())\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Checks if a BindingsSet contains no Bindings frames, and thus indicates no match.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Checks if a BindingsSet contains no Bindings frames, and thus indicates\n    no match.\"\"\"\n    return hp.bindings_set_is_empty(self.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.is_single","title":"is_single","text":"<pre><code>is_single() -&gt; bool\n</code></pre> <p>Checks if a Bindings set contains a frame with no associations, and thus allows variables to take any value.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def is_single(self) -&gt; bool:\n    \"\"\"Checks if a Bindings set contains a frame with no associations, and\n    thus allows variables to take any value.\n    \"\"\"\n    return hp.bindings_set_is_single(self.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.iterator","title":"iterator","text":"<pre><code>iterator()\n</code></pre> <p>Returns an iterator over all Bindings frames</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterator(self):\n    \"\"\"Returns an iterator over all Bindings frames\"\"\"\n    res = hp.bindings_set_list(self.c_set)\n    result = [Bindings(r) for r in res]\n    return iter(result)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.merge_into","title":"merge_into","text":"<pre><code>merge_into(input: Union[BindingsSet, Bindings])\n</code></pre> <p>Merges the contents of another BindingsSet or Bindings frame.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def merge_into(self, input: Union['BindingsSet', Bindings]):\n    \"\"\"Merges the contents of another BindingsSet or Bindings frame.\"\"\"\n    self.shadow_list = None\n    if isinstance(input, BindingsSet):\n        hp.bindings_set_merge_into(self.c_set, input.c_set)\n    else:\n        new_set = BindingsSet(input)\n        hp.bindings_set_merge_into(self.c_set, new_set.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.push","title":"push","text":"<pre><code>push(bindings: Bindings)\n</code></pre> <p>Adds a Bindings frame to an existing BindingsSet</p>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.push--parameters","title":"Parameters","text":"<p>bindings:     The Bindings set to incorporate into set. Ownership of this argument is     taken by this function.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def push(self, bindings: Bindings):\n    \"\"\"Adds a Bindings frame to an existing BindingsSet\n\n    Parameters\n    ----------\n    bindings:\n        The Bindings set to incorporate into set. Ownership of this argument is\n        taken by this function.\n    \"\"\"\n    self.shadow_list = None\n    hp.bindings_set_push(self.c_set, bindings.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom","title":"ExpressionAtom","text":"<pre><code>ExpressionAtom(catom)\n</code></pre> <p>               Bases: <code>Atom</code></p> <p>An ExpressionAtom combines different kinds of Atoms, including expressions.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize an expression atom\"\"\"\n    super().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.get_children","title":"get_children","text":"<pre><code>get_children()\n</code></pre> <p>Returns all children Atoms of an expression</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_children(self):\n    \"\"\"Returns all children Atoms of an expression\"\"\"\n    return [Atom._from_catom(catom) for catom in hp.atom_get_children(self.catom)]\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.get_metatype","title":"get_metatype","text":"<pre><code>get_metatype()\n</code></pre> <p>Gets the metatype (kind) of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_metatype(self):\n    \"\"\"Gets the metatype (kind) of the current Atom instance\"\"\"\n    return hp.atom_get_metatype(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom","title":"GroundedAtom","text":"<pre><code>GroundedAtom(catom)\n</code></pre> <p>               Bases: <code>Atom</code></p> <p>A GroundedAtom represents sub-symbolic knowledge. At the API level, it allows keeping data and behaviour inside an Atom. There are three aspects of a GroundedAtom which can be customized:</p> <pre><code>- the type of GroundedAtom is provided by the Atom itself;\n- the matching algorithm used by the Atom;\n- an Atom can be made executable, and used to apply sub-symbolic\n  operations to other Atoms as arguments.\n</code></pre> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize a GroundedAtom\"\"\"\n    super().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.get_grounded_type","title":"get_grounded_type","text":"<pre><code>get_grounded_type()\n</code></pre> <p>Retrieve the grounded type of the GroundedAtom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_grounded_type(self):\n    \"\"\"Retrieve the grounded type of the GroundedAtom.\"\"\"\n    return Atom._from_catom(hp.atom_get_grounded_type(self.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.get_metatype","title":"get_metatype","text":"<pre><code>get_metatype()\n</code></pre> <p>Gets the metatype (kind) of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_metatype(self):\n    \"\"\"Gets the metatype (kind) of the current Atom instance\"\"\"\n    return hp.atom_get_metatype(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.get_object","title":"get_object","text":"<pre><code>get_object()\n</code></pre> <p>Returns the GroundedAtom object, or the Space wrapped inside a GroundedAtom, or convert supported Rust grounded objects into corresponding ValueObjects. Function raises TypeError when grounded atom cannot be converted to Python object. Uncatched Python exception can lead to Rust panic in some contexts, for example when exception is thrown from atomspace query unification procedure. It is highly recommended to call get_object method inside try-except block to catch TypeError.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_object(self):\n    \"\"\"Returns the GroundedAtom object, or the Space wrapped inside a GroundedAtom,\n       or convert supported Rust grounded objects into corresponding ValueObjects.\n       Function raises TypeError when grounded atom cannot be converted to Python object. Uncatched\n       Python exception can lead to Rust panic in some contexts, for example when exception is thrown\n       from atomspace query unification procedure. It is highly recommended to call get_object method\n       inside try-except block to catch TypeError.\n    \"\"\"\n    # TODO: Here code assumes CGrounded object is always Python object.\n    # This is not true in general case. To make code universal we need to\n    # keep kind of the original runtime in CGrounded structure.\n    if hp.atom_is_cgrounded(self.catom):\n        return hp.atom_get_object(self.catom)\n    else:\n        return _priv_gnd_get_object(self)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedObject","title":"GroundedObject","text":"<pre><code>GroundedObject(content, id=None)\n</code></pre> <p>A GroundedObject holds some content and, optionally, an identifier.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, content, id=None):\n    \"\"\"Initializes a new GroundedObject with the given content and identifier.\"\"\"\n    self.content = content\n    self.id = id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        newstr = repr(self.content)[1:-1].translate(str.maketrans({'\"' : r'\\\"'}))\n        return f'\"{newstr}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.IncorrectArgumentError","title":"IncorrectArgumentError","text":"<p>               Bases: <code>Exception</code></p> <p>Argument is not recognized by function implementation. It can be argument of incorrect type or in incorrect format. Interpreter handles this error similarly to the situation when pure function definition is not matched.</p>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject","title":"MatchableObject","text":"<pre><code>MatchableObject(content, id=None)\n</code></pre> <p>               Bases: <code>ValueObject</code></p> <p>Represents an object that can be involved in a matching operation with an Atom.</p> <p>This class is meant to be subclassed by objects that define specific matching behavior with an Atom. It provides a stub method for the matching operation that raises a RuntimeError when called, which must be overridden by subclasses.</p> Inherits <p>ValueObject: The parent class that provides basic value-based equality and representation.</p> <p>Methods:</p> <ul> <li> <code>match_</code>             \u2013              <p>A stub method for matching the object with an Atom.</p> </li> </ul> Example <p>class MyMatchableObject(MatchableObject):     def match_(self, atom):         # Implement the matching logic here         pass</p> <p>my_obj = MyMatchableObject(\"some_value\") my_obj.match_(some_atom)  # Should not raise RuntimeError</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>Raised when the match_ method is called without being overridden by a subclass.</p> </li> </ul> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, content, id=None):\n    \"\"\"Initializes a new GroundedObject with the given content and identifier.\"\"\"\n    self.content = content\n    self.id = id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Gets the value of the object, which is its content.</p>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this ValueObject with another based on their content.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compares the equality of this ValueObject with another based on their content.\"\"\"\n    # TODO: We need to hook this up the the Value-Bridging mechanism when it's designed and built\n    # https://github.com/trueagi-io/hyperon-experimental/issues/351\n\n    # TODO: ?typecheck for the contents\n    return isinstance(other, ValueObject) and self.content == other.content\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        newstr = repr(self.content)[1:-1].translate(str.maketrans({'\"' : r'\\\"'}))\n        return f'\"{newstr}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.match_","title":"match_","text":"<pre><code>match_(atom)\n</code></pre> <p>A stub method for matching the object with an Atom.</p> <p>This method is intended to be overridden by subclasses to provide specific matching behavior with an Atom.</p> <p>Parameters:</p> <ul> <li> <code>atom</code>               (<code>Atom</code>)           \u2013            <p>An Atom object to match against.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>Raised when this method is called without being overridden in a subclass.</p> </li> </ul> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_(self, atom):\n    \"\"\"\n    A stub method for matching the object with an Atom.\n\n    This method is intended to be overridden by subclasses to provide specific\n    matching behavior with an Atom.\n\n    Parameters:\n        atom (Atom): An Atom object to match against.\n\n    Raises:\n        RuntimeError: Raised when this method is called without being overridden in a subclass.\n    \"\"\"\n    raise RuntimeError(\"MatchableObject::match_() is not implemented\")\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.serialize","title":"serialize","text":"<pre><code>serialize(serializer)\n</code></pre> <p>Serialize standard Python values. This implementation is used to pass Python values into the foreign runtime.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def serialize(self, serializer):\n    \"\"\"\n    Serialize standard Python values. This implementation is used to\n    pass Python values into the foreign runtime.\n    \"\"\"\n    if isinstance(self.content, bool):\n        return serializer.serialize_bool(self.content)\n    elif isinstance(self.content, int):\n        return serializer.serialize_int(self.content)\n    elif isinstance(self.content, float):\n        return serializer.serialize_float(self.content)\n    elif isinstance(self.content, str):\n        return serializer.serialize_str(self.content)\n    else:\n        return SerialResult.NOT_SUPPORTED\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MettaError","title":"MettaError","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception; raised when a error should be returned from OperationAtom, , but we don't want to output Python error stack.</p>"},{"location":"reference/atoms/#hyperon.atoms.NoReduceError","title":"NoReduceError","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception; raised when a reduction operation cannot be performed.</p>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject","title":"OperationObject","text":"<pre><code>OperationObject(name, op, unwrap=True)\n</code></pre> <p>               Bases: <code>GroundedObject</code></p> <p>An OperationObject represents an operation as a grounded object, allowing for more advanced logic like lazy evaluation, type-checking, and more.</p> Inherits <p>GroundedObject: The parent class that provides the basic wrapper around content.</p> <p>Attributes:</p> <ul> <li> <code>unwrap</code>               (<code>bool</code>)           \u2013            <p>Determines whether to unwrap the content of GroundedAtoms            when passed as arguments to the operation.</p> </li> </ul> Properties <p>op: Returns the operation function. name: Returns the identifier name for this operation object.</p> <p>Methods:</p> <ul> <li> <code>execute</code>             \u2013              <p>Executes the operation with the provided arguments.</p> </li> <li> <code>__eq__</code>             \u2013              <p>Compares the equality of this OperationObject instance with another.</p> </li> </ul> Example <p>def add(a, b):     return a + b</p> <p>op_obj = OperationObject(\"addition\", add) result = op_obj.execute(3, 4)</p> <p>Parameters:     name (str): The identifier for this operation.     op (function): The function representing the operation.     unwrap (bool, optional): Whether to unwrap GroundedAtom content when applying                              the operation. Defaults to True.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, name, op, unwrap=True):\n    \"\"\"\n    Initializes a new OperationObject with a name identifier, operation function,\n    and an optional unwrap flag.\n    Parameters:\n        name (str): The identifier for this operation.\n        op (function): The function representing the operation.\n        unwrap (bool, optional): Whether to unwrap GroundedAtom content when applying\n                                 the operation. Defaults to True.\n\n    \"\"\"\n    super().__init__(op, name)\n    self.unwrap = unwrap\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Returns the identifier name for this operation object.</p>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.op","title":"op  <code>property</code>","text":"<pre><code>op\n</code></pre> <p>Returns the operation function.</p>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this OperationObject with another based on their names.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OperationObject</code>)           \u2013            <p>Another OperationObject instance to compare.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>True if both OperationObjects have the same name; False otherwise.</p> </li> </ul> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Compares the equality of this OperationObject with another based on their names.\n\n    Parameters:\n        other (OperationObject): Another OperationObject instance to compare.\n\n    Returns:\n        True if both OperationObjects have the same name; False otherwise.\n    \"\"\"\n    return isinstance(other, OperationObject) and self.name == other.name\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        newstr = repr(self.content)[1:-1].translate(str.maketrans({'\"' : r'\\\"'}))\n        return f'\"{newstr}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.execute","title":"execute","text":"<pre><code>execute(*atoms, res_typ=UNDEFINED)\n</code></pre> <p>Executes the operation with the provided arguments.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>           \u2013            <p>Arguments to pass to the operation function.</p> </li> <li> <code>res_typ</code>               (<code>AtomType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The expected result type. Defaults to AtomType.UNDEFINED.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>The result of the operation.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NoReduceError</code>             \u2013            <p>Raised when <code>unwrap=True</code> and a non-GroundedAtom argument is provided.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>Raised when the result of the operation is not a list.</p> </li> </ul> Note <p>Depending on the <code>unwrap</code> attribute, this method will either unwrap GroundedAtoms before passing them to the operation or pass them as is.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def execute(self, *atoms, res_typ=AtomType.UNDEFINED):\n    \"\"\"\n    Executes the operation with the provided arguments.\n\n    Parameters:\n        *args: Arguments to pass to the operation function.\n        res_typ (AtomType, optional): The expected result type. Defaults to AtomType.UNDEFINED.\n\n    Returns:\n        The result of the operation.\n\n    Raises:\n        NoReduceError: Raised when `unwrap=True` and a non-GroundedAtom argument is provided.\n        RuntimeError: Raised when the result of the operation is not a list.\n\n    Note:\n        Depending on the `unwrap` attribute, this method will either unwrap GroundedAtoms\n        before passing them to the operation or pass them as is.\n    \"\"\"\n    # type-check?\n    if self.unwrap:\n        args, kwargs = unwrap_args(atoms)\n        try:\n            result = self.op(*args, **kwargs)\n        except MettaError as e:\n            return [E(S('Error'), *e.args)]\n        if result is None:\n            return [Atoms.UNIT]\n        if callable(result):\n            return [OperationAtom(repr(result), result, unwrap=True)]\n        return [ValueAtom(result, res_typ)]\n    else:\n        result = self.op(*atoms)\n        try:\n            iter(result)\n        except TypeError:\n            raise RuntimeError(\"Grounded operation `\" + self.name + \"` should return list\")\n        return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom","title":"SymbolAtom","text":"<pre><code>SymbolAtom(catom)\n</code></pre> <p>               Bases: <code>Atom</code></p> <p>A SymbolAtom represents a single concept, identified by name. If two symbols have the same name, they reference the same concept.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize a SymbolAtom\"\"\"\n    super().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.get_metatype","title":"get_metatype","text":"<pre><code>get_metatype()\n</code></pre> <p>Gets the metatype (kind) of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_metatype(self):\n    \"\"\"Gets the metatype (kind) of the current Atom instance\"\"\"\n    return hp.atom_get_metatype(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.get_name","title":"get_name","text":"<pre><code>get_name()\n</code></pre> <p>Returns the name of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_name(self):\n    \"\"\"Returns the name of the Atom.\"\"\"\n    return hp.atom_get_name(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject","title":"ValueObject","text":"<pre><code>ValueObject(content, id=None)\n</code></pre> <p>               Bases: <code>GroundedObject</code></p> <p>A ValueObject is a specialized form of GroundedObject, which treats its content as a value. It allows for equality comparison between the content of two ValueObjects.</p> Example <p>obj1 = ValueObject(5) obj2 = ValueObject(5) obj3 = ValueObject(6)</p> <p>print(obj1 == obj2)  # True print(obj1 == obj3)  # False</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, content, id=None):\n    \"\"\"Initializes a new GroundedObject with the given content and identifier.\"\"\"\n    self.content = content\n    self.id = id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Gets the value of the object, which is its content.</p>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this ValueObject with another based on their content.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compares the equality of this ValueObject with another based on their content.\"\"\"\n    # TODO: We need to hook this up the the Value-Bridging mechanism when it's designed and built\n    # https://github.com/trueagi-io/hyperon-experimental/issues/351\n\n    # TODO: ?typecheck for the contents\n    return isinstance(other, ValueObject) and self.content == other.content\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        newstr = repr(self.content)[1:-1].translate(str.maketrans({'\"' : r'\\\"'}))\n        return f'\"{newstr}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.serialize","title":"serialize","text":"<pre><code>serialize(serializer)\n</code></pre> <p>Serialize standard Python values. This implementation is used to pass Python values into the foreign runtime.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def serialize(self, serializer):\n    \"\"\"\n    Serialize standard Python values. This implementation is used to\n    pass Python values into the foreign runtime.\n    \"\"\"\n    if isinstance(self.content, bool):\n        return serializer.serialize_bool(self.content)\n    elif isinstance(self.content, int):\n        return serializer.serialize_int(self.content)\n    elif isinstance(self.content, float):\n        return serializer.serialize_float(self.content)\n    elif isinstance(self.content, str):\n        return serializer.serialize_str(self.content)\n    else:\n        return SerialResult.NOT_SUPPORTED\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom","title":"VariableAtom","text":"<pre><code>VariableAtom(catom)\n</code></pre> <p>               Bases: <code>Atom</code></p> <p>A VariableAtom represents a variable in an expression. It serves as a placeholder that can be matched with, or bound to other Atoms.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize a VariableAtom\"\"\"\n    super().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.get_metatype","title":"get_metatype","text":"<pre><code>get_metatype()\n</code></pre> <p>Gets the metatype (kind) of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_metatype(self):\n    \"\"\"Gets the metatype (kind) of the current Atom instance\"\"\"\n    return hp.atom_get_metatype(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.get_name","title":"get_name","text":"<pre><code>get_name()\n</code></pre> <p>Returns the name of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_name(self):\n    \"\"\"Returns the name of the Atom.\"\"\"\n    return hp.atom_get_name(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.parse_name","title":"parse_name  <code>staticmethod</code>","text":"<pre><code>parse_name(name)\n</code></pre> <p>Construct new VariableAtom instance from VariableAtom.get_name() method results.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>@staticmethod\ndef parse_name(name):\n    \"\"\"Construct new VariableAtom instance from VariableAtom.get_name()\n    method results.\"\"\"\n    return VariableAtom(hp.atom_var_parse_name(name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.E","title":"E","text":"<pre><code>E(*args)\n</code></pre> <p>A convenient method to construct an ExpressionAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def E(*args):\n    \"\"\"A convenient method to construct an ExpressionAtom\"\"\"\n    return ExpressionAtom(hp.atom_expr([atom.catom for atom in args]))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.G","title":"G","text":"<pre><code>G(object, type=UNDEFINED)\n</code></pre> <p>A convenient method to construct a GroundedAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def G(object, type=AtomType.UNDEFINED):\n    \"\"\"A convenient method to construct a GroundedAtom\"\"\"\n    return GroundedAtom(_priv_atom_gnd(object, type))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableAtom","title":"MatchableAtom","text":"<pre><code>MatchableAtom(value, type_name=None, atom_id=None)\n</code></pre> <p>Creates a Grounded Atom that wraps a matchable value, optionally specifying its type and identifier.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def MatchableAtom(value, type_name=None, atom_id=None):\n    \"\"\"\n    Creates a Grounded Atom that wraps a matchable value, optionally specifying its type and identifier.\n    \"\"\"\n    return G(MatchableObject(value, atom_id), _type_sugar(type_name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationAtom","title":"OperationAtom","text":"<pre><code>OperationAtom(name, op, type_names=None, unwrap=True)\n</code></pre> <p>An OperationAtom wraps an operation with optional type information into a GroundedAtom and associates a name with it. Useful for registering custom operations that can be executed in an Atom-based computational environment.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def OperationAtom(name, op, type_names=None, unwrap=True):\n    \"\"\"\n    An OperationAtom wraps an operation with optional type information into a GroundedAtom\n    and associates a name with it. Useful for registering custom operations\n    that can be executed in an Atom-based computational environment.\n    \"\"\"\n    return G(OperationObject(name, op, unwrap), _type_sugar(type_names))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.PrimitiveAtom","title":"PrimitiveAtom","text":"<pre><code>PrimitiveAtom(value, type_name=None, atom_id=None)\n</code></pre> <p>Creates a GroundedAtom that wraps a given Python primitive value without converting it into the MeTTa primitive. By default ValueAtom function converts Python primitives into MeTTa ones. This function is added to override this rule if needed.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def PrimitiveAtom(value, type_name=None, atom_id=None):\n    \"\"\"\n    Creates a GroundedAtom that wraps a given Python primitive value without\n    converting it into the MeTTa primitive. By default ValueAtom function\n    converts Python primitives into MeTTa ones. This function is added to\n    override this rule if needed.\n    \"\"\"\n    PRIMITIVE_TYPES = (int, float, bool)\n    assert isinstance(value, PRIMITIVE_TYPES), f\"Primitive value {PRIMITIVE_TYPES} is expected\"\n    type = _type_sugar(type_name)\n    return GroundedAtom(hp.atom_py(ValueObject(value, atom_id), type.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.S","title":"S","text":"<pre><code>S(name)\n</code></pre> <p>A convenient method to construct a SymbolAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def S(name):\n    \"\"\"A convenient method to construct a SymbolAtom\"\"\"\n    return SymbolAtom(hp.atom_sym(name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.V","title":"V","text":"<pre><code>V(name)\n</code></pre> <p>A convenient method to construct a VariableAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def V(name):\n    \"\"\"A convenient method to construct a VariableAtom\"\"\"\n    return VariableAtom(hp.atom_var(name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueAtom","title":"ValueAtom","text":"<pre><code>ValueAtom(value, type_name=None, atom_id=None)\n</code></pre> <p>Creates a GroundedAtom that wraps a given value, optionally specifying its type and identifier. It has special processing for the objects which have cspace attribute and for ValueObject instances of primitive types. Spaces usually should be treated by a special way. Primitive atoms are converted into the MeTTa primitives.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def ValueAtom(value, type_name=None, atom_id=None):\n    \"\"\"\n    Creates a GroundedAtom that wraps a given value, optionally specifying its\n    type and identifier. It has special processing for the objects which have\n    cspace attribute and for ValueObject instances of primitive types. Spaces\n    usually should be treated by a special way. Primitive atoms are converted\n    into the MeTTa primitives.\n    \"\"\"\n    return G(ValueObject(value, atom_id), _type_sugar(type_name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.atoms_are_equivalent","title":"atoms_are_equivalent","text":"<pre><code>atoms_are_equivalent(first, second)\n</code></pre> <p>Check if two atoms are equivalent</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def atoms_are_equivalent(first, second):\n    \"\"\"Check if two atoms are equivalent\"\"\"\n    return hp.atoms_are_equivalent(first.catom, second.catom)\n</code></pre>"},{"location":"reference/base/","title":"Base","text":""},{"location":"reference/base/#hyperon.base","title":"base","text":""},{"location":"reference/base/#hyperon.base.AbstractSpace","title":"AbstractSpace","text":"<pre><code>AbstractSpace()\n</code></pre> <p>A virtual base class upon which Spaces can be implemented in Python</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialiize the AbstractSpace. Does nothing in the base class\"\"\"\n    return\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.add","title":"add","text":"<pre><code>add(atom)\n</code></pre> <p>Adds an Atom to the atom space. Must be implemented in derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add(self, atom):\n    \"\"\"\n    Adds an Atom to the atom space. Must be implemented in derived classes.\n    \"\"\"\n    raise RuntimeError(\"Space::add() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Counts the number of atoms in the atom space. Optional for derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n    \"\"\"\n    Counts the number of atoms in the atom space. Optional for derived classes.\n    \"\"\"\n    None\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.atoms_iter","title":"atoms_iter","text":"<pre><code>atoms_iter()\n</code></pre> <p>Returns an iterator over atoms in the Space. Optional for derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atoms_iter(self):\n    \"\"\"\n    Returns an iterator over atoms in the Space. Optional for derived classes.\n    \"\"\"\n    None\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.query","title":"query","text":"<pre><code>query(query_atom)\n</code></pre> <p>Performs the specified query on the Space. Should be overridden to return a BindingsSet as the result of the query.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, query_atom):\n    \"\"\"\n    Performs the specified query on the Space.\n    Should be overridden to return a BindingsSet as the result of the query.\n    \"\"\"\n    raise RuntimeError(\"Space::query() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.remove","title":"remove","text":"<pre><code>remove(atom)\n</code></pre> <p>Removes an Atom from the atom space. Must be implemented in derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove(self, atom):\n    \"\"\"\n    Removes an Atom from the atom space. Must be implemented in derived classes.\n    \"\"\"\n    raise RuntimeError(\"Space::remove() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.replace","title":"replace","text":"<pre><code>replace(atom, replacement)\n</code></pre> <p>Replaces an Atom from the atom space. Must be implemented in derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace(self, atom, replacement):\n    \"\"\"\n    Replaces an Atom from the atom space. Must be implemented in derived classes.\n    \"\"\"\n    raise RuntimeError(\"Space::replace() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace","title":"GroundingSpace","text":"<pre><code>GroundingSpace()\n</code></pre> <p>               Bases: <code>AbstractSpace</code></p> <p>A wrapper over the native GroundingSpace implementation, which can be subclassed and extended within Python</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize GroundingSpace and its underlying native implementation.\"\"\"\n    super().__init__()\n    # self.cspace = hp.space_new_grounding()\n    self.gspace = GroundingSpaceRef()\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.add","title":"add","text":"<pre><code>add(atom)\n</code></pre> <p>Adds an Atom to the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add(self, atom):\n    \"\"\"\n    Adds an Atom to the atom space.\n    \"\"\"\n    self.gspace.add_atom(atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Counts the number of Atoms in the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n    \"\"\"\n    Counts the number of Atoms in the atom space.\n    \"\"\"\n    return self.gspace.atom_count()\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.atoms_iter","title":"atoms_iter","text":"<pre><code>atoms_iter()\n</code></pre> <p>Returns an iterator over atoms in the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atoms_iter(self):\n    \"\"\"\n    Returns an iterator over atoms in the atom space.\n    \"\"\"\n    return iter(self.gspace.get_atoms())\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.query","title":"query","text":"<pre><code>query(query_atom)\n</code></pre> <p>Delegates the query to the underlying native GroundingSpace and returns the result BindingsSet</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, query_atom):\n    \"\"\"\n    Delegates the query to the underlying native GroundingSpace\n    and returns the result BindingsSet\n    \"\"\"\n    return self.gspace.query(query_atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.remove","title":"remove","text":"<pre><code>remove(atom)\n</code></pre> <p>Removes an Atom from the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove(self, atom):\n    \"\"\"\n    Removes an Atom from the atom space.\n    \"\"\"\n    return self.gspace.remove_atom(atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.replace","title":"replace","text":"<pre><code>replace(from_atom, to_atom)\n</code></pre> <p>Replaces an Atom in the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace(self, from_atom, to_atom):\n    \"\"\"\n    Replaces an Atom in the atom space.\n    \"\"\"\n    return self.gspace.replace_atom(from_atom, to_atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef","title":"GroundingSpaceRef","text":"<pre><code>GroundingSpaceRef(cspace=None)\n</code></pre> <p>               Bases: <code>SpaceRef</code></p> <p>A reference to a native GroundingSpace, implemented by the MeTTa core library.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, cspace = None):\n    \"\"\"\n    Initialize a new GroundingSpaceRef.\n    If a CSpace object is provided, use it; otherwise create a new GroundingSpace.\n    \"\"\"\n    if cspace is None:\n        self.cspace = hp.space_new_grounding()\n    else:\n        self.cspace = cspace\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Free the underlying CSpace object</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n    \"\"\"Free the underlying CSpace object \"\"\"\n    hp.space_free(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compare two SpaceRef objects for equality, based on their underlying spaces.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compare two SpaceRef objects for equality, based on their underlying spaces.\"\"\"\n    return hp.space_eq(self.cspace, other.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.add_atom","title":"add_atom","text":"<pre><code>add_atom(atom)\n</code></pre> <p>Add an Atom to the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add_atom(self, atom):\n    \"\"\"\n    Add an Atom to the Space.\n    \"\"\"\n    hp.space_add(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n    \"\"\"\n    Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.\n    \"\"\"\n    return hp.space_atom_count(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a new copy of the SpaceRef, referencing the same underlying Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a new copy of the SpaceRef, referencing the same underlying Space.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.get_atoms","title":"get_atoms","text":"<pre><code>get_atoms()\n</code></pre> <p>Returns a list of all Atoms in the Space, or None if that is impossible.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_atoms(self):\n    \"\"\"\n    Returns a list of all Atoms in the Space, or None if that is impossible.\n    \"\"\"\n    res = hp.space_list(self.cspace)\n    if res == None:\n        return None\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Returns the Space object referenced by the SpaceRef, or None if the object does not have a direct Python interface.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_payload(self):\n    \"\"\"\n    Returns the Space object referenced by the SpaceRef, or None if the object does not have a\n    direct Python interface.\n    \"\"\"\n    return hp.space_get_payload(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.query","title":"query","text":"<pre><code>query(pattern)\n</code></pre> <p>Performs the specified query on the Space, and returns the result as a BindingsSet.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, pattern):\n    \"\"\"\n    Performs the specified query on the Space, and returns the result as a BindingsSet.\n    \"\"\"\n    result = hp.space_query(self.cspace, pattern.catom)\n    return BindingsSet(result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.remove_atom","title":"remove_atom","text":"<pre><code>remove_atom(atom)\n</code></pre> <p>Delete the specified Atom from the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove_atom(self, atom):\n    \"\"\"\n    Delete the specified Atom from the Space.\n    \"\"\"\n    return hp.space_remove(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.replace_atom","title":"replace_atom","text":"<pre><code>replace_atom(atom, replacement)\n</code></pre> <p>Replaces the specified Atom, if it exists in the Space, with the supplied replacement.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace_atom(self, atom, replacement):\n    \"\"\"\n    Replaces the specified Atom, if it exists in the Space, with the supplied replacement.\n    \"\"\"\n    return hp.space_replace(self.cspace, atom.catom, replacement.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.subst","title":"subst","text":"<pre><code>subst(pattern, templ)\n</code></pre> <p>Performs a substitution within the Space, based on a pattern and a template.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def subst(self, pattern, templ):\n    \"\"\"\n    Performs a substitution within the Space, based on a pattern and a template.\n    \"\"\"\n    return [Atom._from_catom(catom) for catom in\n            hp.space_subst(self.cspace, pattern.catom,\n                                     templ.catom)]\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter","title":"Interpreter","text":"<pre><code>Interpreter(gnd_space, expr)\n</code></pre> <p>A wrapper class for the MeTTa interpreter that handles the interpretation of expressions in a given grounding space.</p> <p>NOTE: This is a low-level API, and most applications would be better served by a <code>MeTTa</code> runner object</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, gnd_space, expr):\n    \"\"\"\n    Initializes the interpreter with the given grounding space and expression.\n    \"\"\"\n    self.step_result = hp.interpret_init(gnd_space.cspace, expr.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.get_result","title":"get_result","text":"<pre><code>get_result()\n</code></pre> <p>Retrieves the final outcome of the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_result(self):\n    \"\"\"\n    Retrieves the final outcome of the interpretation plan.\n    \"\"\"\n    if self.has_next():\n        raise RuntimeError(\"Plan execution is not finished\")\n    return hp.step_get_result(self.step_result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.get_step_result","title":"get_step_result","text":"<pre><code>get_step_result()\n</code></pre> <p>Gets the current result of the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_step_result(self):\n    \"\"\"\n    Gets the current result of the interpretation plan.\n    \"\"\"\n    return self.step_result\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.has_next","title":"has_next","text":"<pre><code>has_next()\n</code></pre> <p>Checks if there are more steps to execute in the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def has_next(self):\n    \"\"\"\n    Checks if there are more steps to execute in the interpretation plan.\n    \"\"\"\n    return hp.step_has_next(self.step_result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.next","title":"next","text":"<pre><code>next()\n</code></pre> <p>Executes the next step in the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def next(self):\n    \"\"\"\n    Executes the next step in the interpretation plan.\n    \"\"\"\n    if not self.has_next():\n        raise StopIteration()\n    self.step_result = hp.interpret_step(self.step_result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SExprParser","title":"SExprParser","text":"<pre><code>SExprParser(text)\n</code></pre> <p>A class responsible for parsing S-expressions (Symbolic Expressions). This class wraps around a SExprParser object from the core library.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, text):\n    \"\"\"Initialize a new SExprParser object.\"\"\"\n    self.cparser = hp.CSExprParser(text)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SExprParser.parse","title":"parse","text":"<pre><code>parse(tokenizer)\n</code></pre> <p>Parses the S-expression using the provided Tokenizer.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def parse(self, tokenizer):\n    \"\"\"\n    Parses the S-expression using the provided Tokenizer.\n    \"\"\"\n    catom = self.cparser.parse(tokenizer.ctokenizer)\n    if (catom is None):\n        err_str = self.cparser.sexpr_parser_err_str()\n        if (err_str is None):\n            return None\n        else:\n            raise SyntaxError(err_str)\n    else:\n        return Atom._from_catom(catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SExprParser.parse_to_syntax_tree","title":"parse_to_syntax_tree","text":"<pre><code>parse_to_syntax_tree()\n</code></pre> <p>Parses the S-expression into a SyntaxNode representing the top-level of a syntax tree.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def parse_to_syntax_tree(self):\n    \"\"\"\n    Parses the S-expression into a SyntaxNode representing the top-level of a syntax tree.\n    \"\"\"\n    cnode = self.cparser.parse_to_syntax_tree()\n    return SyntaxNode(cnode) if cnode is not None else None\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef","title":"SpaceRef","text":"<pre><code>SpaceRef(space_obj)\n</code></pre> <p>A reference to a Space, which may be accessed directly, wrapped in a grounded atom, or passed to a MeTTa interpreter.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, space_obj):\n    \"\"\"\n    Initialize a new SpaceRef based on the given space object, either a CSpace \n    or a custom Python object.\n    \"\"\"\n    if type(space_obj) is hp.CSpace:\n        self.cspace = space_obj\n    else:\n        self.cspace = hp.space_new_custom(space_obj)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Free the underlying CSpace object</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n    \"\"\"Free the underlying CSpace object \"\"\"\n    hp.space_free(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compare two SpaceRef objects for equality, based on their underlying spaces.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compare two SpaceRef objects for equality, based on their underlying spaces.\"\"\"\n    return hp.space_eq(self.cspace, other.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.add_atom","title":"add_atom","text":"<pre><code>add_atom(atom)\n</code></pre> <p>Add an Atom to the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add_atom(self, atom):\n    \"\"\"\n    Add an Atom to the Space.\n    \"\"\"\n    hp.space_add(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n    \"\"\"\n    Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.\n    \"\"\"\n    return hp.space_atom_count(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a new copy of the SpaceRef, referencing the same underlying Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a new copy of the SpaceRef, referencing the same underlying Space.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.get_atoms","title":"get_atoms","text":"<pre><code>get_atoms()\n</code></pre> <p>Returns a list of all Atoms in the Space, or None if that is impossible.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_atoms(self):\n    \"\"\"\n    Returns a list of all Atoms in the Space, or None if that is impossible.\n    \"\"\"\n    res = hp.space_list(self.cspace)\n    if res == None:\n        return None\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Returns the Space object referenced by the SpaceRef, or None if the object does not have a direct Python interface.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_payload(self):\n    \"\"\"\n    Returns the Space object referenced by the SpaceRef, or None if the object does not have a\n    direct Python interface.\n    \"\"\"\n    return hp.space_get_payload(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.query","title":"query","text":"<pre><code>query(pattern)\n</code></pre> <p>Performs the specified query on the Space, and returns the result as a BindingsSet.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, pattern):\n    \"\"\"\n    Performs the specified query on the Space, and returns the result as a BindingsSet.\n    \"\"\"\n    result = hp.space_query(self.cspace, pattern.catom)\n    return BindingsSet(result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.remove_atom","title":"remove_atom","text":"<pre><code>remove_atom(atom)\n</code></pre> <p>Delete the specified Atom from the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove_atom(self, atom):\n    \"\"\"\n    Delete the specified Atom from the Space.\n    \"\"\"\n    return hp.space_remove(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.replace_atom","title":"replace_atom","text":"<pre><code>replace_atom(atom, replacement)\n</code></pre> <p>Replaces the specified Atom, if it exists in the Space, with the supplied replacement.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace_atom(self, atom, replacement):\n    \"\"\"\n    Replaces the specified Atom, if it exists in the Space, with the supplied replacement.\n    \"\"\"\n    return hp.space_replace(self.cspace, atom.catom, replacement.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.subst","title":"subst","text":"<pre><code>subst(pattern, templ)\n</code></pre> <p>Performs a substitution within the Space, based on a pattern and a template.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def subst(self, pattern, templ):\n    \"\"\"\n    Performs a substitution within the Space, based on a pattern and a template.\n    \"\"\"\n    return [Atom._from_catom(catom) for catom in\n            hp.space_subst(self.cspace, pattern.catom,\n                                     templ.catom)]\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode","title":"SyntaxNode","text":"<pre><code>SyntaxNode(cnode)\n</code></pre> <p>A class representing a node in a parsed syntax tree</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, cnode):\n    \"\"\"\n    Initialize a new Tokenizer.\n    \"\"\"\n    self.cnode = cnode\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Destructor for the SyntaxNode</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n    \"\"\"\n    Destructor for the SyntaxNode\n    \"\"\"\n    hp.syntax_node_free(self.cnode)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Returns the type of a SyntaxNode</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_type(self):\n    \"\"\"\n    Returns the type of a SyntaxNode\n    \"\"\"\n    return hp.syntax_node_type(self.cnode)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode.src_range","title":"src_range","text":"<pre><code>src_range()\n</code></pre> <p>Returns the range of offsets into the source code of the text represented by the SyntaxNode</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def src_range(self):\n    \"\"\"\n    Returns the range of offsets into the source code of the text represented by the SyntaxNode\n    \"\"\"\n    range_tuple = hp.syntax_node_src_range(self.cnode)\n    return range(range_tuple[0], range_tuple[1])\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode.unroll","title":"unroll","text":"<pre><code>unroll()\n</code></pre> <p>Returns a list of all leaf nodes recursively contained within a SyntaxNode</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def unroll(self):\n    \"\"\"\n    Returns a list of all leaf nodes recursively contained within a SyntaxNode\n    \"\"\"\n    syntax_nodes = []\n    for cnode in hp.syntax_node_unroll(self.cnode):\n        syntax_nodes.append(SyntaxNode(cnode))\n    return syntax_nodes\n</code></pre>"},{"location":"reference/base/#hyperon.base.Tokenizer","title":"Tokenizer","text":"<pre><code>Tokenizer(ctokenizer=None)\n</code></pre> <p>A class responsible for text tokenization in the context of Hyperon. This class wraps around a Tokenizer object from the core library.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, ctokenizer = None):\n    \"\"\"\n    Initialize a new Tokenizer.\n    \"\"\"\n    if ctokenizer is None:\n        self.ctokenizer = hp.tokenizer_new()\n    else:\n        self.ctokenizer = ctokenizer\n</code></pre>"},{"location":"reference/base/#hyperon.base.Tokenizer.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Destructor that frees the underlying resources when the Tokenizer instance is destroyed.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n    \"\"\"\n    Destructor that frees the underlying resources when the Tokenizer instance is destroyed.\n    \"\"\"\n    hp.tokenizer_free(self.ctokenizer)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Tokenizer.register_token","title":"register_token","text":"<pre><code>register_token(regex, constr)\n</code></pre> <p>Registers a new custom Token in the Tokenizer based on a regular expression.</p> <p>Parameters:</p> <p>regex:     A string representing the regular expression to match incoming text.     Hyperon uses the Rust RegEx engine and syntax. constr:     A constructor function for generating a new atom when the regex is triggered.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def register_token(self, regex, constr):\n    \"\"\"\n    Registers a new custom Token in the Tokenizer based on a regular expression.\n\n    Parameters:\n    ----------\n    regex:\n       A string representing the regular expression to match incoming text.\n       Hyperon uses the Rust RegEx engine and syntax.\n   constr:\n       A constructor function for generating a new atom when the regex is triggered.\n   \"\"\"\n    hp.tokenizer_register_token(self.ctokenizer, regex, constr)\n</code></pre>"},{"location":"reference/base/#hyperon.base.atom_is_error","title":"atom_is_error","text":"<pre><code>atom_is_error(atom)\n</code></pre> <p>Checks whether an Atom is an error expression</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_is_error(atom):\n    \"\"\"Checks whether an Atom is an error expression\"\"\"\n    return hp.atom_is_error(atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.check_type","title":"check_type","text":"<pre><code>check_type(gnd_space, atom, type)\n</code></pre> <p>Checks whether the given Atom has the specified type in the given space context.</p>"},{"location":"reference/base/#hyperon.base.check_type--parameters","title":"Parameters","text":"<p>gnd_space:     A pointer to the space_t representing the space context in which to perform     the check atom:     A pointer to the atom_t or atom_ref_t representing the atom whose Type the     function will check type:     A pointer to the atom_t or atom_ref_t representing the type to check against</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def check_type(gnd_space, atom, type):\n    \"\"\"\n    Checks whether the given Atom has the specified type in the given space context.\n\n    Parameters\n    ----------\n    gnd_space:\n        A pointer to the space_t representing the space context in which to perform\n        the check\n    atom:\n        A pointer to the atom_t or atom_ref_t representing the atom whose Type the\n        function will check\n    type:\n        A pointer to the atom_t or atom_ref_t representing the type to check against\n    \"\"\"\n\n    return hp.check_type(gnd_space.cspace, atom.catom, type.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.get_atom_types","title":"get_atom_types","text":"<pre><code>get_atom_types(gnd_space, atom)\n</code></pre> <p>Provides all types for the given Atom in the context of the given Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_atom_types(gnd_space, atom):\n    \"\"\"Provides all types for the given Atom in the context of the given Space.\"\"\"\n    result = hp.get_atom_types(gnd_space.cspace, atom.catom)\n    return [Atom._from_catom(catom) for catom in result]\n</code></pre>"},{"location":"reference/base/#hyperon.base.interpret","title":"interpret","text":"<pre><code>interpret(gnd_space, expr)\n</code></pre> <p>Parses the given expression in the specified grounding space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def interpret(gnd_space, expr):\n    \"\"\"\n    Parses the given expression in the specified grounding space.\n    \"\"\"\n    interpreter = Interpreter(gnd_space, expr)\n    while interpreter.has_next():\n        interpreter.next()\n    return [Atom._from_catom(catom) for catom in interpreter.get_result()]\n</code></pre>"},{"location":"reference/base/#hyperon.base.validate_atom","title":"validate_atom","text":"<pre><code>validate_atom(gnd_space, atom)\n</code></pre> <p>Checks whether the given Atom is correctly typed.</p>"},{"location":"reference/base/#hyperon.base.validate_atom--parameters","title":"Parameters","text":"<p>gnd_space:     A pointer to the space_t representing the space context in which to perform     the check atom:     A pointer to the atom_t or atom_ref_t representing the atom whose Type the     function will check</p>"},{"location":"reference/base/#hyperon.base.validate_atom--returns","title":"Returns","text":"<p>True if the Atom is correctly typed, otherwise false</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def validate_atom(gnd_space, atom):\n    \"\"\"\n    Checks whether the given Atom is correctly typed.\n\n    Parameters\n    ----------\n    gnd_space:\n        A pointer to the space_t representing the space context in which to perform\n        the check\n    atom:\n        A pointer to the atom_t or atom_ref_t representing the atom whose Type the\n        function will check\n\n    Returns\n    -------\n    True if the Atom is correctly typed, otherwise false\n    \"\"\"\n    return hp.validate_atom(gnd_space.cspace, atom.catom)\n</code></pre>"},{"location":"reference/ext/","title":"Ext","text":""},{"location":"reference/ext/#hyperon.ext","title":"ext","text":""},{"location":"reference/ext/#hyperon.ext.grounded","title":"grounded","text":"<pre><code>grounded(arg)\n</code></pre> <p>Function decorator which registers a purely Python grounded function using its name as a token and unwrap=True. There are two ways of using this decorator:   - @grounded without arguments and parentheses in extensions   - @grounded(metta), where metta is a MeTTa instance, within Python scripts Note that MeTTa object is passed to the decorator - not to the grounded function, and @grounded creates an atom out of the function itself (which differs from register_atoms, which decorates a function returning mappings from tokens to atoms)</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def grounded(arg):\n    \"\"\"Function decorator which registers a purely Python grounded function\n    using its name as a token and unwrap=True.\n    There are two ways of using this decorator:\n      - @grounded without arguments and parentheses in extensions\n      - @grounded(metta), where metta is a MeTTa instance, within Python scripts\n    Note that MeTTa object is passed to the decorator - not to the grounded function,\n    and @grounded creates an atom out of the function itself (which differs from\n    register_atoms, which decorates a function returning mappings from tokens to atoms)\n    \"\"\"\n    if callable(arg):\n        return _register_grounded(None, arg)\n    else:\n        return lambda func: _register_grounded(arg, func)\n</code></pre>"},{"location":"reference/ext/#hyperon.ext.mark_register_function","title":"mark_register_function","text":"<pre><code>mark_register_function(type, args, kwargs)\n</code></pre> <p>Mark function as function which registers MeTTa atoms or tokens. The following attributes are added to the decorated function:   - metta_type - value of the 'type' parameter   - metta_pass_metta - value of <code>pass_metta</code> parameter</p>"},{"location":"reference/ext/#hyperon.ext.mark_register_function--parameters","title":"Parameters","text":"<p>type:     Kind of the register function:     RegisterType.TOKEN if function register tokens;     RegisterType.ATOM if it register atoms. args:     args passed to decorator. If no argument are used in decorator then     this list contains only function to be decorated. If decorator has     some arguments then this list doesn't contain function and keeps     decorator arguments instead. kwargs:     kwargs passed to decorator. If arguments are used in decorator then     it contains named arguments otherwise it is empty.</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def mark_register_function(type, args, kwargs):\n    \"\"\"Mark function as function which registers MeTTa atoms or tokens.\n    The following attributes are added to the decorated function:\n      - metta_type - value of the 'type' parameter\n      - metta_pass_metta - value of `pass_metta` parameter\n\n    Parameters\n    ----------\n    type:\n        Kind of the register function:\n        RegisterType.TOKEN if function register tokens;\n        RegisterType.ATOM if it register atoms.\n    args:\n        args passed to decorator. If no argument are used in decorator then\n        this list contains only function to be decorated. If decorator has\n        some arguments then this list doesn't contain function and keeps\n        decorator arguments instead.\n    kwargs:\n        kwargs passed to decorator. If arguments are used in decorator then\n        it contains named arguments otherwise it is empty.\n    \"\"\"\n    # Case 1: Decorator used without arguments (i.e., @decorator instead of @decorator(args))\n    if len(args) == 1 and len(kwargs) == 0 and callable(args[0]):\n        func = args[0]\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            return func(*args, **kwargs)\n\n        wrapper.__dict__['metta_type'] = type\n        wrapper.__dict__['metta_pass_metta'] = False\n\n        return wrapper\n    # Case 2: Decorator used with arguments (i.e., @decorator(args))\n    else:\n        pass_metta = kwargs.get('pass_metta', False)\n\n        def no_args_decorator(func):\n\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n                return func(*args, **kwargs)\n\n            wrapper.__dict__['metta_type'] = type\n            wrapper.__dict__['metta_pass_metta'] = pass_metta\n\n            return wrapper\n\n        return no_args_decorator\n</code></pre>"},{"location":"reference/ext/#hyperon.ext.register_atoms","title":"register_atoms","text":"<pre><code>register_atoms(*args, **kwargs)\n</code></pre> <p>Function decorator which registers returned pairs of regular expressions and atoms in a Tokenizer using the RunContext.register_atom() method.</p>"},{"location":"reference/ext/#hyperon.ext.register_atoms--parameters","title":"Parameters","text":"<p>pass_metta:     Pass instance of MeTTa class to the decorated function as an argument.     Default is False.</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def register_atoms(*args, **kwargs):\n    \"\"\"Function decorator which registers returned pairs of regular expressions\n    and atoms in a Tokenizer using the RunContext.register_atom() method.\n\n    Parameters\n    ----------\n    pass_metta:\n        Pass instance of MeTTa class to the decorated function as an argument.\n        Default is False.\n    \"\"\"\n    return mark_register_function(RegisterType.ATOM, args, kwargs)\n</code></pre>"},{"location":"reference/ext/#hyperon.ext.register_tokens","title":"register_tokens","text":"<pre><code>register_tokens(*args, **kwargs)\n</code></pre> <p>Function decorator which registers returned pairs of regular expressions and lambdas in a Tokenizer using the RunContext.register_token() method.</p>"},{"location":"reference/ext/#hyperon.ext.register_tokens--parameters","title":"Parameters","text":"<p>pass_metta : bool, optional     Pass instance of MeTTa class to the decorated function as an argument.     Default is False.</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def register_tokens(*args, **kwargs):\n    \"\"\"Function decorator which registers returned pairs of regular expressions\n    and lambdas in a Tokenizer using the RunContext.register_token() method.\n\n    Parameters\n    ----------\n    pass_metta : bool, optional\n        Pass instance of MeTTa class to the decorated function as an argument.\n        Default is False.\n    \"\"\"\n    return mark_register_function(RegisterType.TOKEN, args, kwargs)\n</code></pre>"},{"location":"reference/runner/","title":"Runner","text":""},{"location":"reference/runner/#hyperon.runner","title":"runner","text":""},{"location":"reference/runner/#hyperon.runner.Environment","title":"Environment","text":"<p>This class contains the API for configuring the host platform interface used by MeTTa</p>"},{"location":"reference/runner/#hyperon.runner.Environment.config_dir","title":"config_dir","text":"<pre><code>config_dir()\n</code></pre> <p>Returns the config dir in the common environment</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def config_dir():\n    \"\"\"Returns the config dir in the common environment\"\"\"\n    path = hp.environment_config_dir()\n    if (len(path) &gt; 0):\n        return path\n    else:\n        return None\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.Environment.custom_env","title":"custom_env","text":"<pre><code>custom_env(working_dir=None, config_dir=None, create_config=None, is_test=None, include_paths=[])\n</code></pre> <p>Returns an EnvBuilder object that can be used to init a MeTTa runner, if you need multiple environments to coexist in the same process</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def custom_env(working_dir = None, config_dir = None, create_config = None, is_test = None, include_paths = []):\n    \"\"\"Returns an EnvBuilder object that can be used to init a MeTTa runner, if you need multiple environments to coexist in the same process\n\n    Keyword arguments:\n        working_dir -- working directory for the environment (default None)\n        config_dir -- path to the configuration directory, None - no\n        configuration directory, \"\" - default configuration directory\n        (default None)\n        create_config -- create configuration directory if not found\n        (default None)\n        is_test -- is environment used in unit-test flag (default None)\n        include_paths -- additional search paths to search for MeTTa\n        modules in the file system (default [])\n    \"\"\"\n    builder = hp.env_builder_start()\n    if working_dir is not None:\n        hp.env_builder_set_working_dir(builder, working_dir)\n    if config_dir is not None:\n        if config_dir == \"\":\n            hp.env_builder_set_default_config_dir(builder)\n        else:\n            hp.env_builder_set_config_dir(builder, config_dir)\n    if create_config is not None:\n        hp.env_builder_create_config_dir(builder, create_config)\n    if is_test is not None:\n        hp.env_builder_set_is_test(builder, is_test)\n    for path in include_paths:\n        hp.env_builder_push_include_path(builder, path)\n    return builder\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.Environment.init_common_env","title":"init_common_env","text":"<pre><code>init_common_env(working_dir=None, config_dir=None, create_config=None, is_test=None, include_paths=[])\n</code></pre> <p>Initialize the common environment with the supplied args</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def init_common_env(working_dir = None, config_dir = None, create_config = None, is_test = None, include_paths = []):\n    \"\"\"Initialize the common environment with the supplied args\n\n    Keyword arguments:\n        working_dir -- working directory for the environment (default None)\n        config_dir -- path to the configuration directory, None - no\n        configuration directory, \"\" - default configuration directory\n        (default None)\n        create_config -- create configuration directory if it doesn't exist\n        (default None)\n        is_test -- is environment used in unit-test flag (default None)\n        include_paths -- additional search paths to search for MeTTa\n        modules in the file system (default [])\n    \"\"\"\n    builder = Environment.custom_env(working_dir, config_dir, create_config, is_test, include_paths)\n    return hp.env_builder_init_common_env(builder)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.Environment.test_env","title":"test_env","text":"<pre><code>test_env()\n</code></pre> <p>Returns an EnvBuilder object specifying a unit-test environment, that can be used to init a MeTTa runner</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def test_env():\n    \"\"\"Returns an EnvBuilder object specifying a unit-test environment, that can be used to init a MeTTa runner\"\"\"\n    return hp.env_builder_use_test_env()\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa","title":"MeTTa","text":"<pre><code>MeTTa(cmetta=None, space=None, env_builder=None)\n</code></pre> <p>This class represents the runner to execute MeTTa programs</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __init__(self, cmetta = None, space = None, env_builder = None):\n\n    if cmetta is not None:\n        self.cmetta = cmetta\n    else:\n        if space is None:\n            space = GroundingSpaceRef()\n        if env_builder is None:\n            env_builder = hp.env_builder_start()\n            hp.env_builder_set_default_config_dir(env_builder)\n        hp.env_builder_push_fs_module_format(env_builder, _PyFileMeTTaModFmt)\n        #LP-TODO-Next, add an fs_module_fmt arg to the standardized way to init environments, so that\n        # the Python user can define additional formats without tweaking any hyperon files.  To make\n        # this convenient it probably means making a virtual ModuleFormat base class\n\n        builtin_mods_path = os.path.join(os.path.dirname(__file__), 'exts')\n        hp.env_builder_push_include_path(env_builder, builtin_mods_path)\n\n        py_site_packages_paths = site.getsitepackages()\n        for path in py_site_packages_paths:\n            hp.env_builder_push_include_path(env_builder, path)\n\n        self.cmetta = hp.metta_new_with_stdlib_loader(_priv_load_module_stdlib, space.cspace, env_builder)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two MeTTa runner handles point to the same runner.</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two MeTTa runner handles point to the same runner.\"\"\"\n    return (hp.metta_eq(self.cmetta, other.cmetta))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.load_module_at_path","title":"load_module_at_path","text":"<pre><code>load_module_at_path(path, mod_name=None)\n</code></pre> <p>Loads a module into the runner directly from resource at a file system path, trying the formats from the runner's environment in succession</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def load_module_at_path(self, path, mod_name=None):\n    \"\"\"\n    Loads a module into the runner directly from resource at a file system path, trying the formats\n    from the runner's environment in succession\n    \"\"\"\n    mod_id = hp.metta_load_module_at_path(self.cmetta, path, mod_name)\n    err_str = hp.metta_err_str(self.cmetta)\n    if (err_str is not None):\n        raise RuntimeError(err_str)\n    return mod_id\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.load_module_direct_from_func","title":"load_module_direct_from_func","text":"<pre><code>load_module_direct_from_func(mod_name, loader_func)\n</code></pre> <p>Loads a module into the runner using a loader function, with the specified name and scope</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def load_module_direct_from_func(self, mod_name, loader_func):\n    \"\"\"Loads a module into the runner using a loader function, with the specified name and scope\"\"\"\n    mod_id = hp.metta_load_module_direct(self.cmetta, mod_name, loader_func)\n    err_str = hp.metta_err_str(self.cmetta)\n    if (err_str is not None):\n        raise RuntimeError(err_str)\n    return mod_id\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.load_module_direct_from_pymod","title":"load_module_direct_from_pymod","text":"<pre><code>load_module_direct_from_pymod(mod_name, pymod_name)\n</code></pre> <p>Loads a module into the runner directly from a Python module, with the specified name and scope</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def load_module_direct_from_pymod(self, mod_name, pymod_name):\n    \"\"\"Loads a module into the runner directly from a Python module, with the specified name and scope\"\"\"\n    if not isinstance(pymod_name, str):\n        pymod_name = repr(pymod_name)\n    def loader_func(tokenizer, metta):\n        _priv_register_module_tokens(pymod_name, tokenizer, metta)\n    return self.load_module_direct_from_func(mod_name, loader_func)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.parse_all","title":"parse_all","text":"<pre><code>parse_all(program)\n</code></pre> <p>Parse an entire program from text into atoms, using the Tokenizer of the runner's top module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def parse_all(self, program):\n    \"\"\"Parse an entire program from text into atoms, using the Tokenizer of the runner's top module\"\"\"\n    return list(self._parse_all(program))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.parse_single","title":"parse_single","text":"<pre><code>parse_single(program)\n</code></pre> <p>Parse the next single token from the text program</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def parse_single(self, program):\n    \"\"\"Parse the next single token from the text program\"\"\"\n    return next(self._parse_all(program))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.register_atom","title":"register_atom","text":"<pre><code>register_atom(name, symbol)\n</code></pre> <p>Registers an Atom</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def register_atom(self, name, symbol):\n    \"\"\"Registers an Atom\"\"\"\n    self.register_token(name, lambda _: symbol)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.register_token","title":"register_token","text":"<pre><code>register_token(regexp, constr)\n</code></pre> <p>Registers a token</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def register_token(self, regexp, constr):\n    \"\"\"Registers a token\"\"\"\n    self.tokenizer().register_token(regexp, constr)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.run","title":"run","text":"<pre><code>run(program, flat=False)\n</code></pre> <p>Runs the MeTTa code from the program string containing S-Expression MeTTa syntax</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def run(self, program, flat=False):\n    \"\"\"Runs the MeTTa code from the program string containing S-Expression MeTTa syntax\"\"\"\n    parser = SExprParser(program)\n    results = hp.metta_run(self.cmetta, parser.cparser)\n    self._run_check_for_error()\n    if flat:\n        return [Atom._from_catom(catom) for result in results for catom in result]\n    else:\n        return [[Atom._from_catom(catom) for catom in result] for result in results]\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.space","title":"space","text":"<pre><code>space()\n</code></pre> <p>Gets the space for the runner's top-level module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def space(self):\n    \"\"\"Gets the space for the runner's top-level module\"\"\"\n    return GroundingSpaceRef._from_cspace(hp.metta_space(self.cmetta))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.tokenizer","title":"tokenizer","text":"<pre><code>tokenizer()\n</code></pre> <p>Gets the tokenizer for the runner's top-level module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def tokenizer(self):\n    \"\"\"Gets the tokenizer for the runner's top-level module\"\"\"\n    return Tokenizer._from_ctokenizer(hp.metta_tokenizer(self.cmetta))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.working_dir","title":"working_dir","text":"<pre><code>working_dir()\n</code></pre> <p>Returns the working dir from the environment associated with the runner</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def working_dir(self):\n    \"\"\"Returns the working dir from the environment associated with the runner\"\"\"\n    return hp.metta_working_dir(self.cmetta)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.ModuleDescriptor","title":"ModuleDescriptor","text":"<pre><code>ModuleDescriptor(c_module_descriptor)\n</code></pre> <p>An object that uniquely describes a module, including the module's name, optionally a version</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __init__(self, c_module_descriptor):\n    \"\"\"Wraps the underlying ModuleDescriptor object from the core\"\"\"\n    self.c_module_descriptor = c_module_descriptor\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext","title":"RunContext","text":"<pre><code>RunContext(c_run_context)\n</code></pre> <p>An accessor object for the API used by the executable atoms inside a MeTTa program</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __init__(self, c_run_context):\n    \"\"\"Wraps the underlying RunContext object from the core\"\"\"\n    self.c_run_context = c_run_context\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.import_dependency","title":"import_dependency","text":"<pre><code>import_dependency(mod_id)\n</code></pre> <p>Imports a loaded module as a dependency of the running module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def import_dependency(self, mod_id):\n    \"\"\"Imports a loaded module as a dependency of the running module\"\"\"\n    if mod_id.is_valid():\n        hp.run_context_import_dependency(self.c_run_context, mod_id)\n    else:\n        raise RuntimeError(\"Invalid ModuleId\")\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.init_self_module","title":"init_self_module","text":"<pre><code>init_self_module(space, resource_dir)\n</code></pre> <p>Must be called exactly once from within a module loader to initialize the module being loaded</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def init_self_module(self, space, resource_dir):\n    \"\"\"Must be called exactly once from within a module loader to initialize the module being loaded\"\"\"\n    hp.run_context_init_self_module(self.c_run_context, space.cspace, resource_dir)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.load_module","title":"load_module","text":"<pre><code>load_module(mod_name)\n</code></pre> <p>Resolves a module by name in the context of the running module, and loads it into the runner</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def load_module(self, mod_name):\n    \"\"\"Resolves a module by name in the context of the running module, and loads it into the runner\"\"\"\n    return hp.run_context_load_module(self.c_run_context, mod_name)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.metta","title":"metta","text":"<pre><code>metta()\n</code></pre> <p>Access the MeTTa runner that the RunContext is running within</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def metta(self):\n    \"\"\"Access the MeTTa runner that the RunContext is running within\"\"\"\n    return MeTTa(cmetta = hp.run_context_get_metta(self.c_run_context))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.register_atom","title":"register_atom","text":"<pre><code>register_atom(name, symbol)\n</code></pre> <p>Registers an Atom with a name in the currently running module's Tokenizer</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def register_atom(self, name, symbol):\n    \"\"\"Registers an Atom with a name in the currently running module's Tokenizer\"\"\"\n    self.register_token(name, lambda _: symbol)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.register_token","title":"register_token","text":"<pre><code>register_token(regexp, constr)\n</code></pre> <p>Registers a token in the currently running module's Tokenizer</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def register_token(self, regexp, constr):\n    \"\"\"Registers a token in the currently running module's Tokenizer\"\"\"\n    self.tokenizer().register_token(regexp, constr)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.space","title":"space","text":"<pre><code>space()\n</code></pre> <p>Access the space for the currently running module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def space(self):\n    \"\"\"Access the space for the currently running module\"\"\"\n    return GroundingSpaceRef._from_cspace(hp.run_context_get_space(self.c_run_context))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunContext.tokenizer","title":"tokenizer","text":"<pre><code>tokenizer()\n</code></pre> <p>Access the tokenizer for the currently running module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def tokenizer(self):\n    \"\"\"Access the tokenizer for the currently running module\"\"\"\n    return Tokenizer._from_ctokenizer(hp.run_context_get_tokenizer(self.c_run_context))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState","title":"RunnerState","text":"<pre><code>RunnerState(metta, program)\n</code></pre> <p>The state for an in-flight MeTTa interpreter handling the interpretation and evaluation of atoms in a given grounding space.</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __init__(self, metta, program):\n    \"\"\"Initialize a RunnerState with a MeTTa object and a program to run\"\"\"\n    parser = SExprParser(program)\n    #WARNING the C parser object has a reference to the text buffer, and hyperonpy's CSExprParser\n    #  copies the buffer into an owned string.  So we need to make sure this parser isn't freed\n    #  until the RunnerState is done with it.\n    self.parser = parser\n    self.cstate = hp.runner_state_new_with_parser(metta.cmetta, parser.cparser)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees a RunnerState and all associated resources.</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees a RunnerState and all associated resources.\"\"\"\n    hp.runner_state_free(self.cstate)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState.current_results","title":"current_results","text":"<pre><code>current_results(flat=False)\n</code></pre> <p>Returns the current in-progress results from an in-flight program evaluation</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def current_results(self, flat=False):\n    \"\"\"\n    Returns the current in-progress results from an in-flight program evaluation\n    \"\"\"\n    results = hp.runner_state_current_results(self.cstate)\n    if flat:\n        return [Atom._from_catom(catom) for result in results for catom in result]\n    else:\n        return [[Atom._from_catom(catom) for catom in result] for result in results]\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState.is_complete","title":"is_complete","text":"<pre><code>is_complete()\n</code></pre> <p>Returns True if the runner has concluded, or False if there are more steps remaining to execute</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def is_complete(self):\n    \"\"\"\n    Returns True if the runner has concluded, or False if there are more steps remaining to execute\n    \"\"\"\n    return hp.runner_state_is_complete(self.cstate)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState.run_step","title":"run_step","text":"<pre><code>run_step()\n</code></pre> <p>Executes the next step in the interpretation plan, or begins interpretation of the next atom in the stream of MeTTa code.</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def run_step(self):\n    \"\"\"\n    Executes the next step in the interpretation plan, or begins interpretation of the next atom in the stream of MeTTa code.\n    \"\"\"\n    hp.runner_state_step(self.cstate)\n    err_str = hp.runner_state_err_str(self.cstate)\n    if (err_str is not None):\n        raise RuntimeError(err_str)\n</code></pre>"},{"location":"reference/stdlib/","title":"Stdlib","text":""},{"location":"reference/stdlib/#hyperon.stdlib","title":"stdlib","text":""},{"location":"reference/stdlib/#hyperon.stdlib.Char","title":"Char","text":"<pre><code>Char(char)\n</code></pre> <p>Emulate Char type as in a traditional FPL</p> Source code in <code>python/hyperon/stdlib.py</code> <pre><code>def __init__(self, char):\n    if len(char) != 1:\n        raise ValueError(\"A Char object must be initialized with a single character.\")\n    self.char = char\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject","title":"RegexMatchableObject","text":"<pre><code>RegexMatchableObject(content, id=None)\n</code></pre> <p>               Bases: <code>MatchableObject</code></p> <p>To match atoms with regular expressions</p> Source code in <code>python/hyperon/stdlib.py</code> <pre><code>def __init__(self, content, id=None):\n    super().__init__(content, id)\n\n    self.content = self.content.replace(\"[[\", \"(\").replace(\"]]\", \")\").replace(\"~\", \" \")\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Gets the value of the object, which is its content.</p>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this ValueObject with another based on their content.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compares the equality of this ValueObject with another based on their content.\"\"\"\n    # TODO: We need to hook this up the the Value-Bridging mechanism when it's designed and built\n    # https://github.com/trueagi-io/hyperon-experimental/issues/351\n\n    # TODO: ?typecheck for the contents\n    return isinstance(other, ValueObject) and self.content == other.content\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        newstr = repr(self.content)[1:-1].translate(str.maketrans({'\"' : r'\\\"'}))\n        return f'\"{newstr}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.serialize","title":"serialize","text":"<pre><code>serialize(serializer)\n</code></pre> <p>Serialize standard Python values. This implementation is used to pass Python values into the foreign runtime.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def serialize(self, serializer):\n    \"\"\"\n    Serialize standard Python values. This implementation is used to\n    pass Python values into the foreign runtime.\n    \"\"\"\n    if isinstance(self.content, bool):\n        return serializer.serialize_bool(self.content)\n    elif isinstance(self.content, int):\n        return serializer.serialize_int(self.content)\n    elif isinstance(self.content, float):\n        return serializer.serialize_float(self.content)\n    elif isinstance(self.content, str):\n        return serializer.serialize_str(self.content)\n    else:\n        return SerialResult.NOT_SUPPORTED\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.text_ops","title":"text_ops","text":"<pre><code>text_ops(metta)\n</code></pre> <p>Add text operators</p> <p>repr: convert Atom to string. parse: convert String to Atom. stringToChars: convert String to tuple of Char. charsToString: convert tuple of Char to String.</p> <p>see test_stdlib.py for examples.</p> Source code in <code>python/hyperon/stdlib.py</code> <pre><code>@register_atoms(pass_metta=True)\ndef text_ops(metta):\n    \"\"\"Add text operators\n\n    repr: convert Atom to string.\n    parse: convert String to Atom.\n    stringToChars: convert String to tuple of Char.\n    charsToString: convert tuple of Char to String.\n\n    see test_stdlib.py for examples.\n\n    \"\"\"\n\n    reprAtom = OperationAtom('repr', lambda a: [ValueAtom(repr(a), 'String')],\n                             ['Atom', 'String'], unwrap=False)\n    parseAtom = OperationAtom('parse', lambda s: parseImpl(s, metta), ['String', 'Atom'], unwrap=False)\n    stringToCharsAtom = OperationAtom('stringToChars', lambda s: [E(*[ValueAtom(Char(c)) for c in str(s)[1:-1]])],\n                                      ['String', 'Atom'], unwrap=False)\n    charsToStringAtom = OperationAtom('charsToString', lambda a: [ValueAtom(\"\".join([str(c)[1:-1] for c in a.get_children()]))],\n                                      ['Atom', 'String'], unwrap=False)\n    return {\n        r\"repr\": reprAtom,\n        r\"parse\": parseAtom,\n        r\"stringToChars\": stringToCharsAtom,\n        r\"charsToString\": charsToStringAtom\n    }\n</code></pre>"}]}