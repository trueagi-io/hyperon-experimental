<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hyperon C: hyperonc-install/include/hyperonc/hyperon/hyperon.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hyperon C
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_c16e19cad15c7819bac9a816b5aa8553.html">hyperonc-install</a></li><li class="navelem"><a href="dir_9a6bbff06f1c31bd23faa309259c83e4.html">include</a></li><li class="navelem"><a href="dir_7f3038a560b29c067ef1a03ca4b2d4d7.html">hyperonc</a></li><li class="navelem"><a href="dir_882f1502d5feb85c6b6d31017e2524d9.html">hyperon</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">hyperon.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
</div>
<p><a href="hyperon_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:write_5Ft" id="r_write_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwrite__t.html">write_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to a Rust std::fmt::Writer to be used from C code.  <a href="structwrite__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:atom_5Fvec_5Ft" id="r_atom_5Fvec_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatom__vec__t.html">atom_vec_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a vector (list) of Atoms.  <a href="structatom__vec__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:exec_5Ferror_5Ft" id="r_exec_5Ferror_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexec__error__t.html">exec_error_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a status used to communicate between Grounded Atom execution and the MeTTa interpreter.  <a href="structexec__error__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:bindings_5Fset_5Ft" id="r_bindings_5Fset_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbindings__set__t.html">bindings_set_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of Bindings frames. Potentially expressing all possible matches produced by a match operarion.  <a href="structbindings__set__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:serializer_5Fapi_5Ft" id="r_serializer_5Fapi_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer__api__t.html">serializer_api_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table of functions to receive values encoded as specific primitive types.  <a href="structserializer__api__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:gnd_5Fapi_5Ft" id="r_gnd_5Fapi_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgnd__api__t.html">gnd_api_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table of callback functions to implement a Grounded Atom with behavior defined in C.  <a href="structgnd__api__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:gnd_5Ft" id="r_gnd_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgnd__t.html">gnd_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct header that must preface a buffer used as a backing object for a Grounded Atom.  <a href="structgnd__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:space_5Ft" id="r_space_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspace__t.html">space_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Space handle, providing access to a Space in which atoms may exist in relation to other atoms.  <a href="structspace__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:bindings_5Ft" id="r_bindings_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbindings__t.html">bindings_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single Bindings frame, which is a group of mutually-compatible variable &lt;-&gt; atom associations, providing a scope in which variable have definde values.  <a href="structbindings__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:space_5Fparams_5Ft" id="r_space_5Fparams_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspace__params__t.html">space_params_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data associated with this particular space, including the space's payload and observers.  <a href="structspace__params__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:space_5Fapi_5Ft" id="r_space_5Fapi_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspace__api__t.html">space_api_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table of functions to define the behavior of a Space implemented in C.  <a href="structspace__api__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:space_5Fevent_5Ft" id="r_space_5Fevent_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspace__event__t.html">space_event_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Space Event.  <a href="structspace__event__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:space_5Fobserver_5Ft" id="r_space_5Fobserver_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspace__observer__t.html">space_observer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Space Observer, registered with a Space.  <a href="structspace__observer__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:space_5Fobserver_5Fapi_5Ft" id="r_space_5Fobserver_5Fapi_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspace__observer__api__t.html">space_observer_api_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table of callback functions to define the behavior of a SpaceObserver implemented in C.  <a href="structspace__observer__api__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:tokenizer_5Ft" id="r_tokenizer_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtokenizer__t.html">tokenizer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a handle to a Tokenizer, capable of recognizing meaningful Token substrings in text.  <a href="structtokenizer__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:token_5Fapi_5Ft" id="r_token_5Fapi_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtoken__api__t.html">token_api_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table of callback functions to implement custom atom parsing.  <a href="structtoken__api__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:sexpr_5Fparser_5Ft" id="r_sexpr_5Fparser_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an S-Expression Parser state machine, to parse input text into an Atom.  <a href="structsexpr__parser__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:syntax_5Fnode_5Ft" id="r_syntax_5Fnode_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyntax__node__t.html">syntax_node_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a component in a syntax tree created by parsing MeTTa code.  <a href="structsyntax__node__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:step_5Fresult_5Ft" id="r_step_5Fresult_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstep__result__t.html">step_result_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the state for an in-flight interpreter operation.  <a href="structstep__result__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:metta_5Ft" id="r_metta_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmetta__t.html">metta_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A top-level MeTTa runner.  <a href="structmetta__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:run_5Fcontext_5Ft" id="r_run_5Fcontext_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrun__context__t.html">run_context_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface object providing access to the MeTTa run interface.  <a href="structrun__context__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:metta_5Fmod_5Fref_5Ft" id="r_metta_5Fmod_5Fref_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmetta__mod__ref__t.html">metta_mod_ref_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MettaMod C API wrapper.  <a href="structmetta__mod__ref__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:module_5Floader_5Ft" id="r_module_5Floader_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodule__loader__t.html">module_loader_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C representation of the Rust [ModuleLoader] interface. User can provide [ModuleLoader] methods implemented in C.  <a href="structmodule__loader__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:env_5Fbuilder_5Ft" id="r_env_5Fbuilder_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenv__builder__t.html">env_builder_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an environment initialization, in progress.  <a href="structenv__builder__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:module_5Fid_5Ft" id="r_module_5Fid_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodule__id__t.html">module_id_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a loaded module inside a specific <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> MeTTa runner.  <a href="structmodule__id__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:runner_5Fstate_5Ft" id="r_runner_5Fstate_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrunner__state__t.html">runner_state_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the state of an in-flight MeTTa execution run.  <a href="structrunner__state__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:module_5Fdescriptor_5Ft" id="r_module_5Fdescriptor_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodule__descriptor__t.html">module_descriptor_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the properties on a specific module, including its name and version.  <a href="structmodule__descriptor__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:fs_5Fmodule_5Fformat_5Ft" id="r_fs_5Fmodule_5Fformat_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__module__format__t.html">fs_module_format_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table of functions to load MeTTa modules from an arbitrary format.  <a href="structfs__module__format__t.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a63fb69c4bb218767c590cfe36dbb70b3" id="r_a63fb69c4bb218767c590cfe36dbb70b3"><td class="memItemLeft" align="right" valign="top"><a id="a63fb69c4bb218767c590cfe36dbb70b3" name="a63fb69c4bb218767c590cfe36dbb70b3"></a>
typedef struct RustEnvBuilder&#160;</td><td class="memItemRight" valign="bottom"><b>RustEnvBuilder</b></td></tr>
<tr class="memitem:a35030ed04a4948d0db9f0948ca3c4246" id="r_a35030ed04a4948d0db9f0948ca3c4246"><td class="memItemLeft" align="right" valign="top"><a id="a35030ed04a4948d0db9f0948ca3c4246" name="a35030ed04a4948d0db9f0948ca3c4246"></a>
typedef struct RustMetta&#160;</td><td class="memItemRight" valign="bottom"><b>RustMetta</b></td></tr>
<tr class="memitem:a7e5a19c608c5c2cb5436ebc29e66aeb9" id="r_a7e5a19c608c5c2cb5436ebc29e66aeb9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="#a7e5a19c608c5c2cb5436ebc29e66aeb9">RustMettaModRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e5a19c608c5c2cb5436ebc29e66aeb9">RustMettaModRef</a></td></tr>
<tr class="memitem:a849dba2766a05806be8e0460243079a9" id="r_a849dba2766a05806be8e0460243079a9"><td class="memItemLeft" align="right" valign="top"><a id="a849dba2766a05806be8e0460243079a9" name="a849dba2766a05806be8e0460243079a9"></a>
typedef struct RustModuleDescriptor&#160;</td><td class="memItemRight" valign="bottom"><b>RustModuleDescriptor</b></td></tr>
<tr class="memitem:a2af70b078ba623cc0bec5de173b69007" id="r_a2af70b078ba623cc0bec5de173b69007"><td class="memItemLeft" align="right" valign="top"><a id="a2af70b078ba623cc0bec5de173b69007" name="a2af70b078ba623cc0bec5de173b69007"></a>
typedef struct RustRunContext&#160;</td><td class="memItemRight" valign="bottom"><b>RustRunContext</b></td></tr>
<tr class="memitem:ad861d68f9de57538d4a028d8df8d15b5" id="r_ad861d68f9de57538d4a028d8df8d15b5"><td class="memItemLeft" align="right" valign="top"><a id="ad861d68f9de57538d4a028d8df8d15b5" name="ad861d68f9de57538d4a028d8df8d15b5"></a>
typedef struct RustRunnerState&#160;</td><td class="memItemRight" valign="bottom"><b>RustRunnerState</b></td></tr>
<tr class="memitem:acbb7fca86928624e2afc536a05e96701" id="r_acbb7fca86928624e2afc536a05e96701"><td class="memItemLeft" align="right" valign="top"><a id="acbb7fca86928624e2afc536a05e96701" name="acbb7fca86928624e2afc536a05e96701"></a>
typedef struct RustSyntaxNode&#160;</td><td class="memItemRight" valign="bottom"><b>RustSyntaxNode</b></td></tr>
<tr class="memitem:ga8fd8a99298ab86ca0f4007a26b9009e3" id="r_ga8fd8a99298ab86ca0f4007a26b9009e3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a>) (const struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> *vec, void *context)</td></tr>
<tr class="memdesc:ga8fd8a99298ab86ca0f4007a26b9009e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature for a callback providing access to an <span class="tt"><a class="el" href="structatom__vec__t.html" title="Contains a vector (list) of Atoms.">atom_vec_t</a></span>  <br /></td></tr>
<tr class="memitem:ga0feaa3726ea80b9198f76603e94d5360" id="r_ga0feaa3726ea80b9198f76603e94d5360"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga0feaa3726ea80b9198f76603e94d5360">c_atom_callback_t</a>) (<a class="el" href="structatom__ref__t.html">atom_ref_t</a> atom, void *context)</td></tr>
<tr class="memdesc:ga0feaa3726ea80b9198f76603e94d5360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature for a callback providing access to an atom.  <br /></td></tr>
<tr class="memitem:ga1267722de0fd04857c20a9501c4b354e" id="r_ga1267722de0fd04857c20a9501c4b354e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga1267722de0fd04857c20a9501c4b354e">c_var_binding_callback_t</a>) (<a class="el" href="structatom__ref__t.html">atom_ref_t</a> var, <a class="el" href="structatom__ref__t.html">atom_ref_t</a> value, void *context)</td></tr>
<tr class="memdesc:ga1267722de0fd04857c20a9501c4b354e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature for a callback providing access to a variable &lt;-&gt; atom pair, associated with a binding.  <br /></td></tr>
<tr class="memitem:ga9032f4b404a59b2012eaa35340a5ccda" id="r_ga9032f4b404a59b2012eaa35340a5ccda"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga9032f4b404a59b2012eaa35340a5ccda">bindings_mut_callback_t</a>) (struct <a class="el" href="structbindings__t.html">bindings_t</a> *bindings, void *context)</td></tr>
<tr class="memdesc:ga9032f4b404a59b2012eaa35340a5ccda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature for a callback providing mutable access to individual Bindings frames within a Bindings Set.  <br /></td></tr>
<tr class="memitem:gac384a0391a5289fce4e892c3c1a066c3" id="r_gac384a0391a5289fce4e892c3c1a066c3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#gac384a0391a5289fce4e892c3c1a066c3">c_syntax_node_callback_t</a>) (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node, void *context)</td></tr>
<tr class="memdesc:gac384a0391a5289fce4e892c3c1a066c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature for a callback providing access to a <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span>  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1ad5d52e239321fe08b1a7f547be8b01" id="r_a1ad5d52e239321fe08b1a7f547be8b01"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ad5d52e239321fe08b1a7f547be8b01">serial_result_t</a> { <a class="el" href="#a1ad5d52e239321fe08b1a7f547be8b01a2bc49ec37d6a5715dd23e85f1ff5bb59">OK</a>
, <a class="el" href="#a1ad5d52e239321fe08b1a7f547be8b01a9bf1138c8c1f4519e5b814514b750ca3">NOT_SUPPORTED</a>
 }</td></tr>
<tr class="memitem:ga8a39750896676dfd62ad63a45839dd9a" id="r_ga8a39750896676dfd62ad63a45839dd9a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga8a39750896676dfd62ad63a45839dd9a">atom_type_t</a> { <a class="el" href="group__atom__group.html#gga8a39750896676dfd62ad63a45839dd9aae3d30ffaffa3c06ed917e565dda1fbc5">SYMBOL</a>
, <a class="el" href="group__atom__group.html#gga8a39750896676dfd62ad63a45839dd9aa39031ce5df6f91d3778590d6d644b9ea">VARIABLE</a>
, <a class="el" href="group__atom__group.html#gga8a39750896676dfd62ad63a45839dd9aabf65150431dad5e3c992e73b24f45e25">EXPR</a>
, <a class="el" href="group__atom__group.html#gga8a39750896676dfd62ad63a45839dd9aaefa0f3ce09b7d810dde1e3cde60f7c4f">GROUNDED</a>
 }</td></tr>
<tr class="memdesc:ga8a39750896676dfd62ad63a45839dd9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents whether an atom is a Symbol, Variable, Expression, or Grounded atom.  <a href="group__atom__group.html#ga8a39750896676dfd62ad63a45839dd9a">More...</a><br /></td></tr>
<tr class="memitem:ga040a8f0cf4e60bf0ed21309a9b72a0ba" id="r_ga040a8f0cf4e60bf0ed21309a9b72a0ba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__observer__group.html#ga040a8f0cf4e60bf0ed21309a9b72a0ba">space_event_type_t</a> { <a class="el" href="group__space__observer__group.html#gga040a8f0cf4e60bf0ed21309a9b72a0baad03aac8b9e33f9227b196b6aed045794">SPACE_EVENT_TYPE_ADD</a>
, <a class="el" href="group__space__observer__group.html#gga040a8f0cf4e60bf0ed21309a9b72a0baa19bdb7e727740a94b38789d197c84095">SPACE_EVENT_TYPE_REMOVE</a>
, <a class="el" href="group__space__observer__group.html#gga040a8f0cf4e60bf0ed21309a9b72a0baa0611a2f7bd161b3c0c7581c512e997f8">SPACE_EVENT_TYPE_REPLACE</a>
 }</td></tr>
<tr class="memdesc:ga040a8f0cf4e60bf0ed21309a9b72a0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different types of Space Events.  <a href="group__space__observer__group.html#ga040a8f0cf4e60bf0ed21309a9b72a0ba">More...</a><br /></td></tr>
<tr class="memitem:ga71159ff1ca88a54c5857cdfe598dc692" id="r_ga71159ff1ca88a54c5857cdfe598dc692"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__observer__group.html#ga71159ff1ca88a54c5857cdfe598dc692">space_event_field_t</a> { <a class="el" href="group__space__observer__group.html#gga71159ff1ca88a54c5857cdfe598dc692a6f2f0542d68e7596b1b8b072fdf68f0f">SPACE_EVENT_FIELD_ADD</a>
, <a class="el" href="group__space__observer__group.html#gga71159ff1ca88a54c5857cdfe598dc692aa953362c69a4b77e85945d10191f7638">SPACE_EVENT_FIELD_REMOVE</a>
, <a class="el" href="group__space__observer__group.html#gga71159ff1ca88a54c5857cdfe598dc692af2e37334458c028f90e82095631a9632">SPACE_EVENT_FIELD_REPLACE_PATTERN</a>
, <a class="el" href="group__space__observer__group.html#gga71159ff1ca88a54c5857cdfe598dc692a93e1cf55800e425ee7b0c90b724ecfc9">SPACE_EVENT_FIELD_REPLACE_TEMPLATE</a>
 }</td></tr>
<tr class="memdesc:ga71159ff1ca88a54c5857cdfe598dc692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor constants, to access the fields of a <span class="tt"><a class="el" href="structspace__event__t.html" title="Represents a Space Event.">space_event_t</a></span>  <a href="group__space__observer__group.html#ga71159ff1ca88a54c5857cdfe598dc692">More...</a><br /></td></tr>
<tr class="memitem:gaa712c20d55774112ce9f3890d752a004" id="r_gaa712c20d55774112ce9f3890d752a004"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#gaa712c20d55774112ce9f3890d752a004">syntax_node_type_t</a> { <br />
&#160;&#160;<a class="el" href="group__tokenizer__and__parser__group.html#ggaa712c20d55774112ce9f3890d752a004aae696377c19e507b64e16be78ce3bbdb">COMMENT</a>
, <a class="el" href="group__tokenizer__and__parser__group.html#ggaa712c20d55774112ce9f3890d752a004a3ce0ede9808c443a2e15006f01fb91d7">VARIABLE_TOKEN</a>
, <a class="el" href="group__tokenizer__and__parser__group.html#ggaa712c20d55774112ce9f3890d752a004a67fc1734265f2e84177a9bc259f1b187">STRING_TOKEN</a>
, <a class="el" href="group__tokenizer__and__parser__group.html#ggaa712c20d55774112ce9f3890d752a004a1d32fc48eff72113cf76816bf6222739">WORD_TOKEN</a>
, <br />
&#160;&#160;<a class="el" href="group__tokenizer__and__parser__group.html#ggaa712c20d55774112ce9f3890d752a004af0b0ce2414f256bad9da221d2532147d">OPEN_PAREN</a>
, <a class="el" href="group__tokenizer__and__parser__group.html#ggaa712c20d55774112ce9f3890d752a004a7093c88a2f741fb4dae5c36809a1958f">CLOSE_PAREN</a>
, <a class="el" href="group__tokenizer__and__parser__group.html#ggaa712c20d55774112ce9f3890d752a004aba113c37f25d24aada154b75c7dd91ba">WHITESPACE</a>
, <a class="el" href="group__tokenizer__and__parser__group.html#ggaa712c20d55774112ce9f3890d752a004a529e12725494ed531cceae5c7cf67207">LEFTOVER_TEXT</a>
, <br />
&#160;&#160;<a class="el" href="group__tokenizer__and__parser__group.html#ggaa712c20d55774112ce9f3890d752a004a86e85aeda2fee48d0fb55ddfb18093f8">EXPRESSION_GROUP</a>
, <a class="el" href="group__tokenizer__and__parser__group.html#ggaa712c20d55774112ce9f3890d752a004a0f0ed217e6e29f661e404c05543fda61">ERROR_GROUP</a>
<br />
 }</td></tr>
<tr class="memdesc:gaa712c20d55774112ce9f3890d752a004"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of language construct respresented by a <a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a>.  <a href="group__tokenizer__and__parser__group.html#gaa712c20d55774112ce9f3890d752a004">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1d390db8fcc34983d5317db0bbe989f6" id="r_ga1d390db8fcc34983d5317db0bbe989f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__group.html#ga1d390db8fcc34983d5317db0bbe989f6">log_error</a> (const char *msg)</td></tr>
<tr class="memdesc:ga1d390db8fcc34983d5317db0bbe989f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs an error through the MeTTa library's logger. Does not halt execution.  <br /></td></tr>
<tr class="memitem:ga3c5d61ca7bb17b82bc0739bc45e4cd4b" id="r_ga3c5d61ca7bb17b82bc0739bc45e4cd4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__group.html#ga3c5d61ca7bb17b82bc0739bc45e4cd4b">log_warn</a> (const char *msg)</td></tr>
<tr class="memdesc:ga3c5d61ca7bb17b82bc0739bc45e4cd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs a warning through the MeTTa library's logger.  <br /></td></tr>
<tr class="memitem:ga00ab4d4c0b970dca7ecbce08c912d828" id="r_ga00ab4d4c0b970dca7ecbce08c912d828"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__group.html#ga00ab4d4c0b970dca7ecbce08c912d828">log_info</a> (const char *msg)</td></tr>
<tr class="memdesc:ga00ab4d4c0b970dca7ecbce08c912d828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs an informative message through the MeTTa library's logger.  <br /></td></tr>
<tr class="memitem:ga6fad018c1b1d1122d866f739152af11c" id="r_ga6fad018c1b1d1122d866f739152af11c"><td class="memItemLeft" align="right" valign="top">intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc__group.html#ga6fad018c1b1d1122d866f739152af11c">write_str</a> (struct <a class="el" href="structwrite__t.html">write_t</a> cwrite, const char *text)</td></tr>
<tr class="memdesc:ga6fad018c1b1d1122d866f739152af11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write C string into a Rust writer.  <br /></td></tr>
<tr class="memitem:gaf9671a4df299e680d2bb6cb70c9afb62" id="r_gaf9671a4df299e680d2bb6cb70c9afb62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__ref__t.html">atom_ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#gaf9671a4df299e680d2bb6cb70c9afb62">atom_ref</a> (const <a class="el" href="structatom__t.html">atom_t</a> *atom)</td></tr>
<tr class="memdesc:gaf9671a4df299e680d2bb6cb70c9afb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> that points to another atom you own.  <br /></td></tr>
<tr class="memitem:gac67bdec25b726b7f680b7a843fa4e9b1" id="r_gac67bdec25b726b7f680b7a843fa4e9b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__ref__t.html">atom_ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#gac67bdec25b726b7f680b7a843fa4e9b1">atom_ref_null</a> (void)</td></tr>
<tr class="memdesc:gac67bdec25b726b7f680b7a843fa4e9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> that points nothing.  <br /></td></tr>
<tr class="memitem:ga419a4d0d779527802b50326a88c37332" id="r_ga419a4d0d779527802b50326a88c37332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga419a4d0d779527802b50326a88c37332">atom_sym</a> (const char *name)</td></tr>
<tr class="memdesc:ga419a4d0d779527802b50326a88c37332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Symbol atom with the specified name.  <br /></td></tr>
<tr class="memitem:gae9065279c5f5521f414d512e4e3bd0a8" id="r_gae9065279c5f5521f414d512e4e3bd0a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#gae9065279c5f5521f414d512e4e3bd0a8">atom_expr</a> (<a class="el" href="structatom__t.html">atom_t</a> *children, uintptr_t size)</td></tr>
<tr class="memdesc:gae9065279c5f5521f414d512e4e3bd0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Expression atom with the specified children atoms.  <br /></td></tr>
<tr class="memitem:ga451b5cfce6e30f79df7d21c51a3fdb21" id="r_ga451b5cfce6e30f79df7d21c51a3fdb21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga451b5cfce6e30f79df7d21c51a3fdb21">atom_expr_from_vec</a> (struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> children)</td></tr>
<tr class="memdesc:ga451b5cfce6e30f79df7d21c51a3fdb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Expression atom with the children contained in an <span class="tt"><a class="el" href="structatom__vec__t.html" title="Contains a vector (list) of Atoms.">atom_vec_t</a></span>  <br /></td></tr>
<tr class="memitem:ga8e9de2900187565d44bca5b70a0c669e" id="r_ga8e9de2900187565d44bca5b70a0c669e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga8e9de2900187565d44bca5b70a0c669e">atom_var</a> (const char *name)</td></tr>
<tr class="memdesc:ga8e9de2900187565d44bca5b70a0c669e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Variable atom with the specified name.  <br /></td></tr>
<tr class="memitem:ga39f1ba2bb039593e0bfa4a3d70169b16" id="r_ga39f1ba2bb039593e0bfa4a3d70169b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga39f1ba2bb039593e0bfa4a3d70169b16">atom_var_parse_name</a> (const char *name)</td></tr>
<tr class="memdesc:ga39f1ba2bb039593e0bfa4a3d70169b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Variable atom parsing full formatted name of the variable.  <br /></td></tr>
<tr class="memitem:gadd7da962227a991c28186299170f5e60" id="r_gadd7da962227a991c28186299170f5e60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#gadd7da962227a991c28186299170f5e60">atom_gnd</a> (struct <a class="el" href="structgnd__t.html">gnd_t</a> *gnd)</td></tr>
<tr class="memitem:gabfa567d250ef52a7f2a407f2bd7c24d7" id="r_gabfa567d250ef52a7f2a407f2bd7c24d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#gabfa567d250ef52a7f2a407f2bd7c24d7">atom_bool</a> (bool b)</td></tr>
<tr class="memitem:ga7cc11147cfa0b6c2680327eaab2645ad" id="r_ga7cc11147cfa0b6c2680327eaab2645ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga7cc11147cfa0b6c2680327eaab2645ad">atom_int</a> (int64_t n)</td></tr>
<tr class="memitem:ga64ec88ca53b4ce8dfd3b9da1a9b67f8e" id="r_ga64ec88ca53b4ce8dfd3b9da1a9b67f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga64ec88ca53b4ce8dfd3b9da1a9b67f8e">atom_float</a> (double f)</td></tr>
<tr class="memitem:ga4edfc284c01c335e48f7264cf5ab027c" id="r_ga4edfc284c01c335e48f7264cf5ab027c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga4edfc284c01c335e48f7264cf5ab027c">atom_gnd_for_space</a> (const struct <a class="el" href="structspace__t.html">space_t</a> *space)</td></tr>
<tr class="memdesc:ga4edfc284c01c335e48f7264cf5ab027c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Grounded Atom referencing a Space.  <br /></td></tr>
<tr class="memitem:ga16c30a26365362d512d39e7bfb657ec9" id="r_ga16c30a26365362d512d39e7bfb657ec9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga16c30a26365362d512d39e7bfb657ec9">atom_free</a> (<a class="el" href="structatom__t.html">atom_t</a> atom)</td></tr>
<tr class="memdesc:ga16c30a26365362d512d39e7bfb657ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an atom and all associated resources.  <br /></td></tr>
<tr class="memitem:ga753b37b98ea33342e6c59ae4f6f531b3" id="r_ga753b37b98ea33342e6c59ae4f6f531b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga753b37b98ea33342e6c59ae4f6f531b3">atom_clone</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga753b37b98ea33342e6c59ae4f6f531b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a "deep copy" of an atom. Useful to turn an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> into an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span>  <br /></td></tr>
<tr class="memitem:ga81c594ac890274ec2032ead659b4955f" id="r_ga81c594ac890274ec2032ead659b4955f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga81c594ac890274ec2032ead659b4955f">atom_eq</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *a, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *b)</td></tr>
<tr class="memdesc:ga81c594ac890274ec2032ead659b4955f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two atom objects represent the same conceptual atom.  <br /></td></tr>
<tr class="memitem:ga0948ea12bfa73f1c2453634186ef1c07" id="r_ga0948ea12bfa73f1c2453634186ef1c07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga0948ea12bfa73f1c2453634186ef1c07">atoms_are_equivalent</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *a, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *b)</td></tr>
<tr class="memdesc:ga0948ea12bfa73f1c2453634186ef1c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two atoms are alpha equivalent.  <br /></td></tr>
<tr class="memitem:ga45019285d58a93a88327a5557895130b" id="r_ga45019285d58a93a88327a5557895130b"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__atom__group.html#ga8a39750896676dfd62ad63a45839dd9a">atom_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga45019285d58a93a88327a5557895130b">atom_get_metatype</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga45019285d58a93a88327a5557895130b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the metatype of an atom.  <br /></td></tr>
<tr class="memitem:ga49806bfca2937236779b59778b978d0e" id="r_ga49806bfca2937236779b59778b978d0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga49806bfca2937236779b59778b978d0e">atom_is_null</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga49806bfca2937236779b59778b978d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the referenced atom is invalid, otherwise returns <span class="tt">false</span>  <br /></td></tr>
<tr class="memitem:gad6b7bebbdd94cf9b0579e1f12e398533" id="r_gad6b7bebbdd94cf9b0579e1f12e398533"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#gad6b7bebbdd94cf9b0579e1f12e398533">atom_to_str</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:gad6b7bebbdd94cf9b0579e1f12e398533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a human-readable text description of an atom.  <br /></td></tr>
<tr class="memitem:ga8033d8be97cbebc5c9b9323fe1d4c1b9" id="r_ga8033d8be97cbebc5c9b9323fe1d4c1b9"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga8033d8be97cbebc5c9b9323fe1d4c1b9">atom_get_name</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:ga8033d8be97cbebc5c9b9323fe1d4c1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the name of an atom into a text buffer.  <br /></td></tr>
<tr class="memitem:gab21346868ef5fa3a7b455723ae9e2d9d" id="r_gab21346868ef5fa3a7b455723ae9e2d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#gab21346868ef5fa3a7b455723ae9e2d9d">atom_get_children</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom, <a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:gab21346868ef5fa3a7b455723ae9e2d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to all children atoms within an expression atom.  <br /></td></tr>
<tr class="memitem:ga4d798c34510a3eb93989ac2e7dcee706" id="r_ga4d798c34510a3eb93989ac2e7dcee706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga4d798c34510a3eb93989ac2e7dcee706">atom_iterate</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom, <a class="el" href="group__atom__group.html#ga0feaa3726ea80b9198f76603e94d5360">c_atom_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:ga4d798c34510a3eb93989ac2e7dcee706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a depth-first exhaustive iteration of an atom and all its children recursively.  <br /></td></tr>
<tr class="memitem:ga415aae7c3525dc8cab37cf88ff2ebfc5" id="r_ga415aae7c3525dc8cab37cf88ff2ebfc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga415aae7c3525dc8cab37cf88ff2ebfc5">atom_get_grounded_type</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga415aae7c3525dc8cab37cf88ff2ebfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the grounded type of a Grounded Atom.  <br /></td></tr>
<tr class="memitem:gae8ac0fb8c56481d89c2db8b6b8d20709" id="r_gae8ac0fb8c56481d89c2db8b6b8d20709"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structgnd__t.html">gnd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#gae8ac0fb8c56481d89c2db8b6b8d20709">atom_get_object</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:gae8ac0fb8c56481d89c2db8b6b8d20709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a pointer to an object backing a Grounded Atom.  <br /></td></tr>
<tr class="memitem:gae19d9f3cdeb87547c1c82d7ff1696d90" id="r_gae19d9f3cdeb87547c1c82d7ff1696d90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#gae19d9f3cdeb87547c1c82d7ff1696d90">atom_is_cgrounded</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:gae19d9f3cdeb87547c1c82d7ff1696d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the atom refers to CGrounded object.  <br /></td></tr>
<tr class="memitem:ga7c9055ced20b4a177700cd6962ff34e4" id="r_ga7c9055ced20b4a177700cd6962ff34e4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__t.html">space_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__group.html#ga7c9055ced20b4a177700cd6962ff34e4">atom_get_space</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga7c9055ced20b4a177700cd6962ff34e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the space wrapped inside a Grounded atom.  <br /></td></tr>
<tr class="memitem:ga556c0cc1b468349226b75d310547de9a" id="r_ga556c0cc1b468349226b75d310547de9a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structexec__error__t.html">exec_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grounded__atom__group.html#ga556c0cc1b468349226b75d310547de9a">exec_error_runtime</a> (const char *message)</td></tr>
<tr class="memdesc:ga556c0cc1b468349226b75d310547de9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structexec__error__t.html" title="Represents a status used to communicate between Grounded Atom execution and the MeTTa interpreter.">exec_error_t</a></span> representing a runtime error that will halt the MeTTa interpreter.  <br /></td></tr>
<tr class="memitem:gaf6a45ffc2d31dbcc5846d0a22ea6c7c6" id="r_gaf6a45ffc2d31dbcc5846d0a22ea6c7c6"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structexec__error__t.html">exec_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grounded__atom__group.html#gaf6a45ffc2d31dbcc5846d0a22ea6c7c6">exec_error_no_reduce</a> (void)</td></tr>
<tr class="memdesc:gaf6a45ffc2d31dbcc5846d0a22ea6c7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structexec__error__t.html" title="Represents a status used to communicate between Grounded Atom execution and the MeTTa interpreter.">exec_error_t</a></span> representing a "Don't Reduce" status, telling the MeTTa interpreter to process the atoms as they are.  <br /></td></tr>
<tr class="memitem:ga1874048fa19c993e80c36d4087dc209e" id="r_ga1874048fa19c993e80c36d4087dc209e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structexec__error__t.html">exec_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grounded__atom__group.html#ga1874048fa19c993e80c36d4087dc209e">exec_error_incorrect_argument</a> (void)</td></tr>
<tr class="memdesc:ga1874048fa19c993e80c36d4087dc209e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structexec__error__t.html" title="Represents a status used to communicate between Grounded Atom execution and the MeTTa interpreter.">exec_error_t</a></span> representing a "Incorrect Argument" status, telling the MeTTa interpreter that argument was not recognized by the function implementation.  <br /></td></tr>
<tr class="memitem:ga4067ffa4ce30237ad6c3637c10e3ff6c" id="r_ga4067ffa4ce30237ad6c3637c10e3ff6c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structexec__error__t.html">exec_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grounded__atom__group.html#ga4067ffa4ce30237ad6c3637c10e3ff6c">exec_error_no_err</a> (void)</td></tr>
<tr class="memdesc:ga4067ffa4ce30237ad6c3637c10e3ff6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structexec__error__t.html" title="Represents a status used to communicate between Grounded Atom execution and the MeTTa interpreter.">exec_error_t</a></span> representing a "No Error" status. This is the default interpreter status.  <br /></td></tr>
<tr class="memitem:ga930d859475d0af6bfe45a5bab40d42c5" id="r_ga930d859475d0af6bfe45a5bab40d42c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grounded__atom__group.html#ga930d859475d0af6bfe45a5bab40d42c5">exec_error_free</a> (struct <a class="el" href="structexec__error__t.html">exec_error_t</a> error)</td></tr>
<tr class="memdesc:ga930d859475d0af6bfe45a5bab40d42c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an <span class="tt"><a class="el" href="structexec__error__t.html" title="Represents a status used to communicate between Grounded Atom execution and the MeTTa interpreter.">exec_error_t</a></span>  <br /></td></tr>
<tr class="memitem:ga267639b4bd9e3f740cf60600c063d6e0" id="r_ga267639b4bd9e3f740cf60600c063d6e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grounded__atom__group.html#ga267639b4bd9e3f740cf60600c063d6e0">throw_panic_with_message</a> (const char *message)</td></tr>
<tr class="memdesc:ga267639b4bd9e3f740cf60600c063d6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to throw panic from C Api with message to prevent panics without any info.  <br /></td></tr>
<tr class="memitem:ga8c3e42f61643a7eb534bf4b5e0a6ef2c" id="r_ga8c3e42f61643a7eb534bf4b5e0a6ef2c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__vec__group.html#ga8c3e42f61643a7eb534bf4b5e0a6ef2c">atom_vec_new</a> (void)</td></tr>
<tr class="memdesc:ga8c3e42f61643a7eb534bf4b5e0a6ef2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty <span class="tt"><a class="el" href="structatom__vec__t.html" title="Contains a vector (list) of Atoms.">atom_vec_t</a></span>  <br /></td></tr>
<tr class="memitem:gafe431d82cdd392a2aa3e36ae0dafa5d5" id="r_gafe431d82cdd392a2aa3e36ae0dafa5d5"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__vec__group.html#gafe431d82cdd392a2aa3e36ae0dafa5d5">atom_vec_clone</a> (const struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> *vec)</td></tr>
<tr class="memdesc:gafe431d82cdd392a2aa3e36ae0dafa5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structatom__vec__t.html" title="Contains a vector (list) of Atoms.">atom_vec_t</a></span> by cloning an existing <span class="tt"><a class="el" href="structatom__vec__t.html" title="Contains a vector (list) of Atoms.">atom_vec_t</a></span>  <br /></td></tr>
<tr class="memitem:gaa6595068a0e3ebcb626b64adb8edfba1" id="r_gaa6595068a0e3ebcb626b64adb8edfba1"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__vec__group.html#gaa6595068a0e3ebcb626b64adb8edfba1">atom_vec_from_array</a> (<a class="el" href="structatom__t.html">atom_t</a> *atoms, uintptr_t size)</td></tr>
<tr class="memdesc:gaa6595068a0e3ebcb626b64adb8edfba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structatom__vec__t.html" title="Contains a vector (list) of Atoms.">atom_vec_t</a></span> from a C-style array.  <br /></td></tr>
<tr class="memitem:ga882320d488d178423eeb6c742c88bdc2" id="r_ga882320d488d178423eeb6c742c88bdc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__vec__group.html#ga882320d488d178423eeb6c742c88bdc2">atom_vec_free</a> (struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> vec)</td></tr>
<tr class="memdesc:ga882320d488d178423eeb6c742c88bdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <span class="tt"><a class="el" href="structatom__vec__t.html" title="Contains a vector (list) of Atoms.">atom_vec_t</a></span>  <br /></td></tr>
<tr class="memitem:ga3658a28f8f9a6932ea6c99c00a3a298a" id="r_ga3658a28f8f9a6932ea6c99c00a3a298a"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__vec__group.html#ga3658a28f8f9a6932ea6c99c00a3a298a">atom_vec_len</a> (const struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> *vec)</td></tr>
<tr class="memdesc:ga3658a28f8f9a6932ea6c99c00a3a298a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a vec.  <br /></td></tr>
<tr class="memitem:ga4d75a16571de2b041674eb92486710c9" id="r_ga4d75a16571de2b041674eb92486710c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__vec__group.html#ga4d75a16571de2b041674eb92486710c9">atom_vec_pop</a> (struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> *vec)</td></tr>
<tr class="memdesc:ga4d75a16571de2b041674eb92486710c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element from a vec, and returns it.  <br /></td></tr>
<tr class="memitem:gaea795aaedfe4bd01d6f6654517c1cc8b" id="r_gaea795aaedfe4bd01d6f6654517c1cc8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__vec__group.html#gaea795aaedfe4bd01d6f6654517c1cc8b">atom_vec_push</a> (struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> *vec, <a class="el" href="structatom__t.html">atom_t</a> atom)</td></tr>
<tr class="memdesc:gaea795aaedfe4bd01d6f6654517c1cc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the atom onto the end of the vec.  <br /></td></tr>
<tr class="memitem:gad74a4fa33a95d268654ca76182536921" id="r_gad74a4fa33a95d268654ca76182536921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__ref__t.html">atom_ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atom__vec__group.html#gad74a4fa33a95d268654ca76182536921">atom_vec_get</a> (const struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> *vec, uintptr_t idx)</td></tr>
<tr class="memdesc:gad74a4fa33a95d268654ca76182536921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an atom at a specified index in a vec.  <br /></td></tr>
<tr class="memitem:gac00cb724ec3b03d7f7f607d8c1e50263" id="r_gac00cb724ec3b03d7f7f607d8c1e50263"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#gac00cb724ec3b03d7f7f607d8c1e50263">atom_match_atom</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *a, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *b)</td></tr>
<tr class="memdesc:gac00cb724ec3b03d7f7f607d8c1e50263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches one atom with another, establishing bindings between them.  <br /></td></tr>
<tr class="memitem:gaac960ec0603851955f95d9c9fa4977b7" id="r_gaac960ec0603851955f95d9c9fa4977b7"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="structserial__result__t.html">serial_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serializer__group.html#gaac960ec0603851955f95d9c9fa4977b7">atom_gnd_serialize</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom, const struct <a class="el" href="structserializer__api__t.html">serializer_api_t</a> *api, void *context)</td></tr>
<tr class="memdesc:gaac960ec0603851955f95d9c9fa4977b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a grounded atom using the given serializer.  <br /></td></tr>
<tr class="memitem:ga2a1e2af718a0accd358144113baf6a71" id="r_ga2a1e2af718a0accd358144113baf6a71"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbindings__t.html">bindings_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga2a1e2af718a0accd358144113baf6a71">bindings_new</a> (void)</td></tr>
<tr class="memdesc:ga2a1e2af718a0accd358144113baf6a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structbindings__t.html" title="Represents a single Bindings frame, which is a group of mutually-compatible variable &lt;-&gt; atom associa...">bindings_t</a></span> containing no variable &lt;-&gt; atom associations, leaving all variables free to match any atom.  <br /></td></tr>
<tr class="memitem:ga4f54fcd366648ead8757ffe8fef5e003" id="r_ga4f54fcd366648ead8757ffe8fef5e003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga4f54fcd366648ead8757ffe8fef5e003">bindings_free</a> (struct <a class="el" href="structbindings__t.html">bindings_t</a> bindings)</td></tr>
<tr class="memdesc:ga4f54fcd366648ead8757ffe8fef5e003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <span class="tt"><a class="el" href="structbindings__t.html" title="Represents a single Bindings frame, which is a group of mutually-compatible variable &lt;-&gt; atom associa...">bindings_t</a></span>  <br /></td></tr>
<tr class="memitem:ga3cbbc7c69ea939666a0358ce8e907cd4" id="r_ga3cbbc7c69ea939666a0358ce8e907cd4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbindings__t.html">bindings_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga3cbbc7c69ea939666a0358ce8e907cd4">bindings_clone</a> (const struct <a class="el" href="structbindings__t.html">bindings_t</a> *bindings)</td></tr>
<tr class="memdesc:ga3cbbc7c69ea939666a0358ce8e907cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a "deep copy" of a <span class="tt"><a class="el" href="structbindings__t.html" title="Represents a single Bindings frame, which is a group of mutually-compatible variable &lt;-&gt; atom associa...">bindings_t</a></span>  <br /></td></tr>
<tr class="memitem:ga7b67034d94554cfbd87dde4d53b69bcf" id="r_ga7b67034d94554cfbd87dde4d53b69bcf"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga7b67034d94554cfbd87dde4d53b69bcf">bindings_to_str</a> (const struct <a class="el" href="structbindings__t.html">bindings_t</a> *bindings, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:ga7b67034d94554cfbd87dde4d53b69bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a text description of a <span class="tt"><a class="el" href="structbindings__t.html" title="Represents a single Bindings frame, which is a group of mutually-compatible variable &lt;-&gt; atom associa...">bindings_t</a></span>  <br /></td></tr>
<tr class="memitem:ga91c2ba485c49605dad8b8415fe12dd87" id="r_ga91c2ba485c49605dad8b8415fe12dd87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga91c2ba485c49605dad8b8415fe12dd87">bindings_eq</a> (const struct <a class="el" href="structbindings__t.html">bindings_t</a> *a, const struct <a class="el" href="structbindings__t.html">bindings_t</a> *b)</td></tr>
<tr class="memdesc:ga91c2ba485c49605dad8b8415fe12dd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <span class="tt"><a class="el" href="structbindings__t.html" title="Represents a single Bindings frame, which is a group of mutually-compatible variable &lt;-&gt; atom associa...">bindings_t</a></span> objects contain identical associations.  <br /></td></tr>
<tr class="memitem:ga57f7d27e317dad6c548488cd6cdd29b2" id="r_ga57f7d27e317dad6c548488cd6cdd29b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga57f7d27e317dad6c548488cd6cdd29b2">bindings_traverse</a> (const struct <a class="el" href="structbindings__t.html">bindings_t</a> *bindings, <a class="el" href="group__matching__group.html#ga1267722de0fd04857c20a9501c4b354e">c_var_binding_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:ga57f7d27e317dad6c548488cd6cdd29b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates each variable &lt;-&gt; Atom association within a <span class="tt"><a class="el" href="structbindings__t.html" title="Represents a single Bindings frame, which is a group of mutually-compatible variable &lt;-&gt; atom associa...">bindings_t</a></span>  <br /></td></tr>
<tr class="memitem:ga755bcbd05628e5aaca10def38a869da3" id="r_ga755bcbd05628e5aaca10def38a869da3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga755bcbd05628e5aaca10def38a869da3">bindings_add_var_binding</a> (struct <a class="el" href="structbindings__t.html">bindings_t</a> *bindings, <a class="el" href="structatom__t.html">atom_t</a> var, <a class="el" href="structatom__t.html">atom_t</a> atom)</td></tr>
<tr class="memdesc:ga755bcbd05628e5aaca10def38a869da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new variable &lt;-&gt; atom association within a <span class="tt"><a class="el" href="structbindings__t.html" title="Represents a single Bindings frame, which is a group of mutually-compatible variable &lt;-&gt; atom associa...">bindings_t</a></span>  <br /></td></tr>
<tr class="memitem:ga7d76c4d3408bf20e8ccee7583184b0fc" id="r_ga7d76c4d3408bf20e8ccee7583184b0fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga7d76c4d3408bf20e8ccee7583184b0fc">bindings_is_empty</a> (const struct <a class="el" href="structbindings__t.html">bindings_t</a> *bindings)</td></tr>
<tr class="memdesc:ga7d76c4d3408bf20e8ccee7583184b0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <span class="tt"><a class="el" href="structbindings__t.html" title="Represents a single Bindings frame, which is a group of mutually-compatible variable &lt;-&gt; atom associa...">bindings_t</a></span> contains no associations.  <br /></td></tr>
<tr class="memitem:ga5e837a95ad72bd8db6f78e9fc7f25a67" id="r_ga5e837a95ad72bd8db6f78e9fc7f25a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga5e837a95ad72bd8db6f78e9fc7f25a67">bindings_resolve</a> (const struct <a class="el" href="structbindings__t.html">bindings_t</a> *bindings, <a class="el" href="structatom__t.html">atom_t</a> var)</td></tr>
<tr class="memdesc:ga5e837a95ad72bd8db6f78e9fc7f25a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the atom bound to the supplied variable name in the <span class="tt"><a class="el" href="structbindings__t.html" title="Represents a single Bindings frame, which is a group of mutually-compatible variable &lt;-&gt; atom associa...">bindings_t</a></span>  <br /></td></tr>
<tr class="memitem:gac369ead3a6a62ce00daf462f00cbd40a" id="r_gac369ead3a6a62ce00daf462f00cbd40a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#gac369ead3a6a62ce00daf462f00cbd40a">bindings_merge</a> (struct <a class="el" href="structbindings__t.html">bindings_t</a> _self, const struct <a class="el" href="structbindings__t.html">bindings_t</a> *other)</td></tr>
<tr class="memdesc:gac369ead3a6a62ce00daf462f00cbd40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two <span class="tt"><a class="el" href="structbindings__t.html" title="Represents a single Bindings frame, which is a group of mutually-compatible variable &lt;-&gt; atom associa...">bindings_t</a></span> Bindings frames together into a Bindings Set.  <br /></td></tr>
<tr class="memitem:ga4bc4755984ec12e2814b626793607109" id="r_ga4bc4755984ec12e2814b626793607109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga4bc4755984ec12e2814b626793607109">bindings_narrow_vars</a> (struct <a class="el" href="structbindings__t.html">bindings_t</a> *bindings, const struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> *vars)</td></tr>
<tr class="memdesc:ga4bc4755984ec12e2814b626793607109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all variable associations from a <span class="tt"><a class="el" href="structbindings__t.html" title="Represents a single Bindings frame, which is a group of mutually-compatible variable &lt;-&gt; atom associa...">bindings_t</a></span> except those in the supplied list.  <br /></td></tr>
<tr class="memitem:ga68ffae0b765cea5b783e0aa1d271e22c" id="r_ga68ffae0b765cea5b783e0aa1d271e22c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga68ffae0b765cea5b783e0aa1d271e22c">bindings_set_empty</a> (void)</td></tr>
<tr class="memdesc:ga68ffae0b765cea5b783e0aa1d271e22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structbindings__set__t.html" title="Represents a set of Bindings frames. Potentially expressing all possible matches produced by a match ...">bindings_set_t</a></span> without any Bindings frames. Conceptually this means no valid matches exist.  <br /></td></tr>
<tr class="memitem:ga7802fe129b00705022a07532c788116f" id="r_ga7802fe129b00705022a07532c788116f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga7802fe129b00705022a07532c788116f">bindings_set_single</a> (void)</td></tr>
<tr class="memdesc:ga7802fe129b00705022a07532c788116f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structbindings__set__t.html" title="Represents a set of Bindings frames. Potentially expressing all possible matches produced by a match ...">bindings_set_t</a></span> with one new Bindings frame. Conceptually this means all variables are able to take on any value.  <br /></td></tr>
<tr class="memitem:ga50c44a2051a7336763a6d7a496ab21ed" id="r_ga50c44a2051a7336763a6d7a496ab21ed"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga50c44a2051a7336763a6d7a496ab21ed">bindings_set_from_bindings</a> (struct <a class="el" href="structbindings__t.html">bindings_t</a> bindings)</td></tr>
<tr class="memdesc:ga50c44a2051a7336763a6d7a496ab21ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structbindings__set__t.html" title="Represents a set of Bindings frames. Potentially expressing all possible matches produced by a match ...">bindings_set_t</a></span> with the specified Bindings frame.  <br /></td></tr>
<tr class="memitem:gab581b3266b9fbbd8e95a1a004bacacf9" id="r_gab581b3266b9fbbd8e95a1a004bacacf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#gab581b3266b9fbbd8e95a1a004bacacf9">bindings_set_push</a> (struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> *set, struct <a class="el" href="structbindings__t.html">bindings_t</a> bindings)</td></tr>
<tr class="memdesc:gab581b3266b9fbbd8e95a1a004bacacf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a Bindings frame to an existing <span class="tt"><a class="el" href="structbindings__set__t.html" title="Represents a set of Bindings frames. Potentially expressing all possible matches produced by a match ...">bindings_set_t</a></span>  <br /></td></tr>
<tr class="memitem:gaafd3dd6c4b7db7119f958c780f2fa563" id="r_gaafd3dd6c4b7db7119f958c780f2fa563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#gaafd3dd6c4b7db7119f958c780f2fa563">bindings_set_free</a> (struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> set)</td></tr>
<tr class="memdesc:gaafd3dd6c4b7db7119f958c780f2fa563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <span class="tt"><a class="el" href="structbindings__set__t.html" title="Represents a set of Bindings frames. Potentially expressing all possible matches produced by a match ...">bindings_set_t</a></span>  <br /></td></tr>
<tr class="memitem:gabb4bbc2412104f453c102a04e5863f50" id="r_gabb4bbc2412104f453c102a04e5863f50"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#gabb4bbc2412104f453c102a04e5863f50">bindings_set_clone</a> (const struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> *set)</td></tr>
<tr class="memdesc:gabb4bbc2412104f453c102a04e5863f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a "deep copy" of a <span class="tt"><a class="el" href="structbindings__set__t.html" title="Represents a set of Bindings frames. Potentially expressing all possible matches produced by a match ...">bindings_set_t</a></span>  <br /></td></tr>
<tr class="memitem:gad8055587fe3ec5e28e5da67996c8fc47" id="r_gad8055587fe3ec5e28e5da67996c8fc47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#gad8055587fe3ec5e28e5da67996c8fc47">bindings_set_eq</a> (const struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> *a, const struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> *b)</td></tr>
<tr class="memdesc:gad8055587fe3ec5e28e5da67996c8fc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <span class="tt"><a class="el" href="structbindings__set__t.html" title="Represents a set of Bindings frames. Potentially expressing all possible matches produced by a match ...">bindings_set_t</a></span> objects contain identical associations.  <br /></td></tr>
<tr class="memitem:ga27b6344fc45b7216f3de3cb93274c303" id="r_ga27b6344fc45b7216f3de3cb93274c303"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga27b6344fc45b7216f3de3cb93274c303">bindings_set_to_str</a> (const struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> *set, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:ga27b6344fc45b7216f3de3cb93274c303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a text description of a <span class="tt"><a class="el" href="structbindings__set__t.html" title="Represents a set of Bindings frames. Potentially expressing all possible matches produced by a match ...">bindings_set_t</a></span>  <br /></td></tr>
<tr class="memitem:ga04a2d6a2733555e9ee26490acc07c588" id="r_ga04a2d6a2733555e9ee26490acc07c588"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga04a2d6a2733555e9ee26490acc07c588">bindings_set_is_empty</a> (const struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> *set)</td></tr>
<tr class="memdesc:ga04a2d6a2733555e9ee26490acc07c588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <span class="tt"><a class="el" href="structbindings__set__t.html" title="Represents a set of Bindings frames. Potentially expressing all possible matches produced by a match ...">bindings_set_t</a></span> contains no Bindings frames, and thus indicates no match.  <br /></td></tr>
<tr class="memitem:ga2a7f9672f4b141e28528c4bf58ea002b" id="r_ga2a7f9672f4b141e28528c4bf58ea002b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga2a7f9672f4b141e28528c4bf58ea002b">bindings_set_is_single</a> (const struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> *set)</td></tr>
<tr class="memdesc:ga2a7f9672f4b141e28528c4bf58ea002b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <span class="tt"><a class="el" href="structbindings__set__t.html" title="Represents a set of Bindings frames. Potentially expressing all possible matches produced by a match ...">bindings_set_t</a></span> contains a frame with no associations, and is thus allows variables to take on any value.  <br /></td></tr>
<tr class="memitem:gacdec726cae8800f549a5cec926b7c200" id="r_gacdec726cae8800f549a5cec926b7c200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#gacdec726cae8800f549a5cec926b7c200">bindings_set_iterate</a> (struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> *set, <a class="el" href="group__matching__group.html#ga9032f4b404a59b2012eaa35340a5ccda">bindings_mut_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:gacdec726cae8800f549a5cec926b7c200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides sequential access to each Bindings frame within a Bindings set.  <br /></td></tr>
<tr class="memitem:gafc66c8e6fb71f6f87ed122728d123c31" id="r_gafc66c8e6fb71f6f87ed122728d123c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#gafc66c8e6fb71f6f87ed122728d123c31">bindings_set_add_var_equality</a> (struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> *set, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *a, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *b)</td></tr>
<tr class="memdesc:gafc66c8e6fb71f6f87ed122728d123c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts equality between two Variable atoms in a Bindings set.  <br /></td></tr>
<tr class="memitem:ga1272640e889a52daeba6f42df4516965" id="r_ga1272640e889a52daeba6f42df4516965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga1272640e889a52daeba6f42df4516965">bindings_set_add_var_binding</a> (struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> *set, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *var, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *value)</td></tr>
<tr class="memdesc:ga1272640e889a52daeba6f42df4516965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new variable &lt;-&gt; atom association to every Bindings frame in a Bindings set.  <br /></td></tr>
<tr class="memitem:ga38053c1f18e0915b1d31d7d99d4a8719" id="r_ga38053c1f18e0915b1d31d7d99d4a8719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matching__group.html#ga38053c1f18e0915b1d31d7d99d4a8719">bindings_set_merge_into</a> (struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> *_self, const struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a> *other)</td></tr>
<tr class="memdesc:ga38053c1f18e0915b1d31d7d99d4a8719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the contents of one Bindings set into another Bindings set.  <br /></td></tr>
<tr class="memitem:ga3b1204075bbc552ed623b1b9e0aa57eb" id="r_ga3b1204075bbc552ed623b1b9e0aa57eb"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__t.html">space_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#ga3b1204075bbc552ed623b1b9e0aa57eb">space_new</a> (const struct <a class="el" href="structspace__api__t.html">space_api_t</a> *api, void *payload)</td></tr>
<tr class="memdesc:ga3b1204075bbc552ed623b1b9e0aa57eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Space, backed by an implementation in C.  <br /></td></tr>
<tr class="memitem:ga0cc53ed059ecda436d1b973445135a64" id="r_ga0cc53ed059ecda436d1b973445135a64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#ga0cc53ed059ecda436d1b973445135a64">space_free</a> (struct <a class="el" href="structspace__t.html">space_t</a> space)</td></tr>
<tr class="memdesc:ga0cc53ed059ecda436d1b973445135a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <span class="tt"><a class="el" href="structspace__t.html" title="A Space handle, providing access to a Space in which atoms may exist in relation to other atoms.">space_t</a></span> handle.  <br /></td></tr>
<tr class="memitem:ga2c34e3b2fed72c7accdf01551e431135" id="r_ga2c34e3b2fed72c7accdf01551e431135"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__t.html">space_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#ga2c34e3b2fed72c7accdf01551e431135">space_clone_handle</a> (const struct <a class="el" href="structspace__t.html">space_t</a> *space)</td></tr>
<tr class="memdesc:ga2c34e3b2fed72c7accdf01551e431135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structspace__t.html" title="A Space handle, providing access to a Space in which atoms may exist in relation to other atoms.">space_t</a></span> handle that refers to the same underlying space as another <span class="tt"><a class="el" href="structspace__t.html" title="A Space handle, providing access to a Space in which atoms may exist in relation to other atoms.">space_t</a></span>  <br /></td></tr>
<tr class="memitem:ga6d0bbce45fe8e08267df73263f00d793" id="r_ga6d0bbce45fe8e08267df73263f00d793"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#ga6d0bbce45fe8e08267df73263f00d793">space_eq</a> (const struct <a class="el" href="structspace__t.html">space_t</a> *a, const struct <a class="el" href="structspace__t.html">space_t</a> *b)</td></tr>
<tr class="memdesc:ga6d0bbce45fe8e08267df73263f00d793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <span class="tt"><a class="el" href="structspace__t.html" title="A Space handle, providing access to a Space in which atoms may exist in relation to other atoms.">space_t</a></span> handles refer to the same underlying Space.  <br /></td></tr>
<tr class="memitem:ga9a44c9c9da62a09f489ada7b9977342c" id="r_ga9a44c9c9da62a09f489ada7b9977342c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#ga9a44c9c9da62a09f489ada7b9977342c">space_get_payload</a> (struct <a class="el" href="structspace__t.html">space_t</a> *space)</td></tr>
<tr class="memdesc:ga9a44c9c9da62a09f489ada7b9977342c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the payload object belonging to a space implemented in C.  <br /></td></tr>
<tr class="memitem:gaee19faff7e88b3c17994f1f1dd96647c" id="r_gaee19faff7e88b3c17994f1f1dd96647c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#gaee19faff7e88b3c17994f1f1dd96647c">space_add</a> (struct <a class="el" href="structspace__t.html">space_t</a> *space, <a class="el" href="structatom__t.html">atom_t</a> atom)</td></tr>
<tr class="memdesc:gaee19faff7e88b3c17994f1f1dd96647c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an atom to the Space.  <br /></td></tr>
<tr class="memitem:ga4d75c0003c7fd51f1bc7075b687583dc" id="r_ga4d75c0003c7fd51f1bc7075b687583dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#ga4d75c0003c7fd51f1bc7075b687583dc">space_remove</a> (struct <a class="el" href="structspace__t.html">space_t</a> *space, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga4d75c0003c7fd51f1bc7075b687583dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a specific atom from the Space.  <br /></td></tr>
<tr class="memitem:gacdc6ee35a8245872e19cbf40395bf2ca" id="r_gacdc6ee35a8245872e19cbf40395bf2ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#gacdc6ee35a8245872e19cbf40395bf2ca">space_replace</a> (struct <a class="el" href="structspace__t.html">space_t</a> *space, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *from, <a class="el" href="structatom__t.html">atom_t</a> to)</td></tr>
<tr class="memdesc:gacdc6ee35a8245872e19cbf40395bf2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces an Atom in the Space with another Atom.  <br /></td></tr>
<tr class="memitem:ga28c3f465539b4d98e8baa39bb06fe414" id="r_ga28c3f465539b4d98e8baa39bb06fe414"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbindings__set__t.html">bindings_set_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#ga28c3f465539b4d98e8baa39bb06fe414">space_query</a> (const struct <a class="el" href="structspace__t.html">space_t</a> *space, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *pattern)</td></tr>
<tr class="memdesc:ga28c3f465539b4d98e8baa39bb06fe414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a Space for atoms matching a pattern.  <br /></td></tr>
<tr class="memitem:ga7170b17ed76146c04fa0c718d580d3f5" id="r_ga7170b17ed76146c04fa0c718d580d3f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#ga7170b17ed76146c04fa0c718d580d3f5">space_subst</a> (const struct <a class="el" href="structspace__t.html">space_t</a> *space, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *pattern, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *templ, <a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:ga7170b17ed76146c04fa0c718d580d3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes all Atoms matching a pattern with Atoms constructed from a template.  <br /></td></tr>
<tr class="memitem:gaa7d2aa2f6e2f1f191179c1d9f5cf0021" id="r_gaa7d2aa2f6e2f1f191179c1d9f5cf0021"><td class="memItemLeft" align="right" valign="top">intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#gaa7d2aa2f6e2f1f191179c1d9f5cf0021">space_atom_count</a> (const struct <a class="el" href="structspace__t.html">space_t</a> *space)</td></tr>
<tr class="memdesc:gaa7d2aa2f6e2f1f191179c1d9f5cf0021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of top-level atoms in a Space, if it can be readily determined.  <br /></td></tr>
<tr class="memitem:ga181a17cf4f63d2ff5e39172be01f5bc3" id="r_ga181a17cf4f63d2ff5e39172be01f5bc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#ga181a17cf4f63d2ff5e39172be01f5bc3">space_iterate</a> (const struct <a class="el" href="structspace__t.html">space_t</a> *space, <a class="el" href="group__atom__group.html#ga0feaa3726ea80b9198f76603e94d5360">c_atom_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:ga181a17cf4f63d2ff5e39172be01f5bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates all top-level Atoms in a Space, if that is possible.  <br /></td></tr>
<tr class="memitem:ga69fe7c2917f1bb1797512025b774d416" id="r_ga69fe7c2917f1bb1797512025b774d416"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__t.html">space_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__client__group.html#ga69fe7c2917f1bb1797512025b774d416">space_new_grounding_space</a> (void)</td></tr>
<tr class="memdesc:ga69fe7c2917f1bb1797512025b774d416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Space, backed by a GroundSpace.  <br /></td></tr>
<tr class="memitem:ga6e798e7ac2377040a3ee140efb33163b" id="r_ga6e798e7ac2377040a3ee140efb33163b"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__space__observer__group.html#ga040a8f0cf4e60bf0ed21309a9b72a0ba">space_event_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__observer__group.html#ga6e798e7ac2377040a3ee140efb33163b">space_event_get_type</a> (const struct <a class="el" href="structspace__event__t.html">space_event_t</a> *event)</td></tr>
<tr class="memdesc:ga6e798e7ac2377040a3ee140efb33163b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of a Space Event.  <br /></td></tr>
<tr class="memitem:ga5f6f0d383d54828b6761d3767911c500" id="r_ga5f6f0d383d54828b6761d3767911c500"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__ref__t.html">atom_ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__observer__group.html#ga5f6f0d383d54828b6761d3767911c500">space_event_get_field_atom</a> (const struct <a class="el" href="structspace__event__t.html">space_event_t</a> *event, enum <a class="el" href="group__space__observer__group.html#ga71159ff1ca88a54c5857cdfe598dc692">space_event_field_t</a> field)</td></tr>
<tr class="memdesc:ga5f6f0d383d54828b6761d3767911c500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the atom associated with a field of a <span class="tt"><a class="el" href="structspace__event__t.html" title="Represents a Space Event.">space_event_t</a></span>  <br /></td></tr>
<tr class="memitem:ga9e9c49a19bc8e79cae8472f7f7c5a68b" id="r_ga9e9c49a19bc8e79cae8472f7f7c5a68b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__observer__t.html">space_observer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__observer__group.html#ga9e9c49a19bc8e79cae8472f7f7c5a68b">space_register_observer</a> (struct <a class="el" href="structspace__t.html">space_t</a> *space, const struct <a class="el" href="structspace__observer__api__t.html">space_observer_api_t</a> *observer_api, void *observer_payload)</td></tr>
<tr class="memdesc:ga9e9c49a19bc8e79cae8472f7f7c5a68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new observer, to monitor activity within the Space.  <br /></td></tr>
<tr class="memitem:ga99a94c7dac6cb2dafb81c9f96add7b68" id="r_ga99a94c7dac6cb2dafb81c9f96add7b68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__observer__group.html#ga99a94c7dac6cb2dafb81c9f96add7b68">space_observer_free</a> (struct <a class="el" href="structspace__observer__t.html">space_observer_t</a> observer)</td></tr>
<tr class="memdesc:ga99a94c7dac6cb2dafb81c9f96add7b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <span class="tt"><a class="el" href="structspace__observer__t.html" title="Represents a Space Observer, registered with a Space.">space_observer_t</a></span>  <br /></td></tr>
<tr class="memitem:gabeab2d42e8283fcac84b9e436018a1f9" id="r_gabeab2d42e8283fcac84b9e436018a1f9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__observer__group.html#gabeab2d42e8283fcac84b9e436018a1f9">space_observer_get_payload</a> (const struct <a class="el" href="structspace__observer__t.html">space_observer_t</a> *observer)</td></tr>
<tr class="memdesc:gabeab2d42e8283fcac84b9e436018a1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the payload associated with the <a class="el" href="structspace__observer__t.html" title="Represents a Space Observer, registered with a Space.">space_observer_t</a>.  <br /></td></tr>
<tr class="memitem:gaa1f4eeec858e08fa13c51e838e180028" id="r_gaa1f4eeec858e08fa13c51e838e180028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__impl__group.html#gaa1f4eeec858e08fa13c51e838e180028">space_params_notify_all_observers</a> (const struct <a class="el" href="structspace__params__t.html">space_params_t</a> *params, const struct <a class="el" href="structspace__event__t.html">space_event_t</a> *event)</td></tr>
<tr class="memdesc:gaa1f4eeec858e08fa13c51e838e180028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies all associated observers of an event.  <br /></td></tr>
<tr class="memitem:gabd61911473602b05ad66b779c1b1d1cd" id="r_gabd61911473602b05ad66b779c1b1d1cd"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__event__t.html">space_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__impl__group.html#gabd61911473602b05ad66b779c1b1d1cd">space_event_new_add</a> (<a class="el" href="structatom__t.html">atom_t</a> atom)</td></tr>
<tr class="memdesc:gabd61911473602b05ad66b779c1b1d1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structspace__event__t.html" title="Represents a Space Event.">space_event_t</a></span> representing an <span class="tt">Add</span> event.  <br /></td></tr>
<tr class="memitem:gaafa82403ad9b2726e04d3b6d2fdb6d1e" id="r_gaafa82403ad9b2726e04d3b6d2fdb6d1e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__event__t.html">space_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__impl__group.html#gaafa82403ad9b2726e04d3b6d2fdb6d1e">space_event_new_remove</a> (<a class="el" href="structatom__t.html">atom_t</a> atom)</td></tr>
<tr class="memdesc:gaafa82403ad9b2726e04d3b6d2fdb6d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structspace__event__t.html" title="Represents a Space Event.">space_event_t</a></span> representing a <span class="tt">Remove</span> event.  <br /></td></tr>
<tr class="memitem:ga58f7ea301351823e2e9ab50ea274f5e1" id="r_ga58f7ea301351823e2e9ab50ea274f5e1"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__event__t.html">space_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__impl__group.html#ga58f7ea301351823e2e9ab50ea274f5e1">space_event_new_replace</a> (<a class="el" href="structatom__t.html">atom_t</a> pattern, <a class="el" href="structatom__t.html">atom_t</a> tmpl)</td></tr>
<tr class="memdesc:ga58f7ea301351823e2e9ab50ea274f5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <span class="tt"><a class="el" href="structspace__event__t.html" title="Represents a Space Event.">space_event_t</a></span> representing a <span class="tt">Replace</span> event.  <br /></td></tr>
<tr class="memitem:ga1437d1eea94d55a8c8f1b3a3fdfe039e" id="r_ga1437d1eea94d55a8c8f1b3a3fdfe039e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__space__impl__group.html#ga1437d1eea94d55a8c8f1b3a3fdfe039e">space_event_free</a> (struct <a class="el" href="structspace__event__t.html">space_event_t</a> event)</td></tr>
<tr class="memdesc:ga1437d1eea94d55a8c8f1b3a3fdfe039e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <span class="tt"><a class="el" href="structspace__event__t.html" title="Represents a Space Event.">space_event_t</a></span>  <br /></td></tr>
<tr class="memitem:gad8614b89e31ed717a51f1055c436744f" id="r_gad8614b89e31ed717a51f1055c436744f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#gad8614b89e31ed717a51f1055c436744f">tokenizer_new</a> (void)</td></tr>
<tr class="memdesc:gad8614b89e31ed717a51f1055c436744f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Tokenizer, without any registered Tokens.  <br /></td></tr>
<tr class="memitem:gad406ea7b7a462ebb00ced9d9052607d5" id="r_gad406ea7b7a462ebb00ced9d9052607d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#gad406ea7b7a462ebb00ced9d9052607d5">tokenizer_free</a> (struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> tokenizer)</td></tr>
<tr class="memdesc:gad406ea7b7a462ebb00ced9d9052607d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a Tokenizer handle.  <br /></td></tr>
<tr class="memitem:gaead24238f59d2df002061961866bb6ed" id="r_gaead24238f59d2df002061961866bb6ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#gaead24238f59d2df002061961866bb6ed">tokenizer_register_token</a> (struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> *tokenizer, const char *regex, const struct <a class="el" href="structtoken__api__t.html">token_api_t</a> *api, void *context)</td></tr>
<tr class="memdesc:gaead24238f59d2df002061961866bb6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new custom Token in a Tokenizer.  <br /></td></tr>
<tr class="memitem:ga56d5697609f691fca9647881fea9112a" id="r_ga56d5697609f691fca9647881fea9112a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#ga56d5697609f691fca9647881fea9112a">tokenizer_clone</a> (const struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> *tokenizer)</td></tr>
<tr class="memdesc:ga56d5697609f691fca9647881fea9112a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a "deep copy" of a Tokenizer.  <br /></td></tr>
<tr class="memitem:gadd26925a0c7e8ce118c9c4f0bf48f21c" id="r_gadd26925a0c7e8ce118c9c4f0bf48f21c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#gadd26925a0c7e8ce118c9c4f0bf48f21c">sexpr_parser_new</a> (const char *text)</td></tr>
<tr class="memdesc:gadd26925a0c7e8ce118c9c4f0bf48f21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new S-Expression Parser.  <br /></td></tr>
<tr class="memitem:ga1a64ae026a50cbf1bca6d7c222cea19c" id="r_ga1a64ae026a50cbf1bca6d7c222cea19c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#ga1a64ae026a50cbf1bca6d7c222cea19c">sexpr_parser_free</a> (struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> parser)</td></tr>
<tr class="memdesc:ga1a64ae026a50cbf1bca6d7c222cea19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an S-Expression Parser.  <br /></td></tr>
<tr class="memitem:gaaf9c0c5587ad4fa324c7dd2f744031fa" id="r_gaaf9c0c5587ad4fa324c7dd2f744031fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#gaaf9c0c5587ad4fa324c7dd2f744031fa">sexpr_parser_parse</a> (struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> *parser, const struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> *tokenizer)</td></tr>
<tr class="memdesc:gaaf9c0c5587ad4fa324c7dd2f744031fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the text associated with an <span class="tt"><a class="el" href="structsexpr__parser__t.html" title="Represents an S-Expression Parser state machine, to parse input text into an Atom.">sexpr_parser_t</a></span>, and creates the corresponding Atom.  <br /></td></tr>
<tr class="memitem:ga30dd580bc479b4115c44e3158719d746" id="r_ga30dd580bc479b4115c44e3158719d746"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#ga30dd580bc479b4115c44e3158719d746">sexpr_parser_err_str</a> (const struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> *parser)</td></tr>
<tr class="memdesc:ga30dd580bc479b4115c44e3158719d746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error string associated with the last <span class="tt">sexpr_parser_parse</span> call.  <br /></td></tr>
<tr class="memitem:ga8bd019b50118713e56eb22c460520d94" id="r_ga8bd019b50118713e56eb22c460520d94"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#ga8bd019b50118713e56eb22c460520d94">sexpr_parser_parse_to_syntax_tree</a> (struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> *parser)</td></tr>
<tr class="memdesc:ga8bd019b50118713e56eb22c460520d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the text associated with an <span class="tt"><a class="el" href="structsexpr__parser__t.html" title="Represents an S-Expression Parser state machine, to parse input text into an Atom.">sexpr_parser_t</a></span>, and creates a syntax tree.  <br /></td></tr>
<tr class="memitem:gabf7e8877026914bcbcfe4828e207ce74" id="r_gabf7e8877026914bcbcfe4828e207ce74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#gabf7e8877026914bcbcfe4828e207ce74">syntax_node_free</a> (struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> node)</td></tr>
<tr class="memdesc:gabf7e8877026914bcbcfe4828e207ce74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a>.  <br /></td></tr>
<tr class="memitem:ga2848d589e097d56d39fd5ca160daaf9b" id="r_ga2848d589e097d56d39fd5ca160daaf9b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#ga2848d589e097d56d39fd5ca160daaf9b">syntax_node_clone</a> (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node)</td></tr>
<tr class="memdesc:ga2848d589e097d56d39fd5ca160daaf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of a <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span>  <br /></td></tr>
<tr class="memitem:ga0161a7f0efb123c485646516bf8b1c52" id="r_ga0161a7f0efb123c485646516bf8b1c52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#ga0161a7f0efb123c485646516bf8b1c52">syntax_node_iterate</a> (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node, <a class="el" href="group__tokenizer__and__parser__group.html#gac384a0391a5289fce4e892c3c1a066c3">c_syntax_node_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:ga0161a7f0efb123c485646516bf8b1c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a depth-first iteration of all child syntax nodes within a syntax tree.  <br /></td></tr>
<tr class="memitem:ga8a87568403de72d2607c0e6bd08410ff" id="r_ga8a87568403de72d2607c0e6bd08410ff"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__tokenizer__and__parser__group.html#gaa712c20d55774112ce9f3890d752a004">syntax_node_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#ga8a87568403de72d2607c0e6bd08410ff">syntax_node_type</a> (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node)</td></tr>
<tr class="memdesc:ga8a87568403de72d2607c0e6bd08410ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of a <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span>  <br /></td></tr>
<tr class="memitem:gac27310c183211f17a923c46befb31f1d" id="r_gac27310c183211f17a923c46befb31f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#gac27310c183211f17a923c46befb31f1d">syntax_node_is_null</a> (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node)</td></tr>
<tr class="memdesc:gac27310c183211f17a923c46befb31f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if a syntax node represents the end of the stream.  <br /></td></tr>
<tr class="memitem:ga2f904f0820cf14f8e94e31c72480ae03" id="r_ga2f904f0820cf14f8e94e31c72480ae03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#ga2f904f0820cf14f8e94e31c72480ae03">syntax_node_is_leaf</a> (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node)</td></tr>
<tr class="memdesc:ga2f904f0820cf14f8e94e31c72480ae03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if a syntax node is a leaf (has no children) and <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:ga9682eedb0f5bfd0d43c9af3e3a1b2bb9" id="r_ga9682eedb0f5bfd0d43c9af3e3a1b2bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tokenizer__and__parser__group.html#ga9682eedb0f5bfd0d43c9af3e3a1b2bb9">syntax_node_src_range</a> (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node, uintptr_t *range_start, uintptr_t *range_end)</td></tr>
<tr class="memdesc:ga9682eedb0f5bfd0d43c9af3e3a1b2bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beginning and end positions in the parsed source of the text represented by the syntax node.  <br /></td></tr>
<tr class="memitem:ga1b5321b2a9bfdd2bd4b2e1d0f7e14bbb" id="r_ga1b5321b2a9bfdd2bd4b2e1d0f7e14bbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#ga1b5321b2a9bfdd2bd4b2e1d0f7e14bbb">atom_is_error</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga1b5321b2a9bfdd2bd4b2e1d0f7e14bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an atom is a MeTTa error expression.  <br /></td></tr>
<tr class="memitem:gaf50bbf593f933de17201935f62ecd263" id="r_gaf50bbf593f933de17201935f62ecd263"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#gaf50bbf593f933de17201935f62ecd263">atom_error_message</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:gaf50bbf593f933de17201935f62ecd263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the text message from an error expression atom into a buffer.  <br /></td></tr>
<tr class="memitem:gabb315897656a8d20a83673d70655d708" id="r_gabb315897656a8d20a83673d70655d708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#gabb315897656a8d20a83673d70655d708">ATOM_TYPE_UNDEFINED</a> (void)</td></tr>
<tr class="memdesc:gabb315897656a8d20a83673d70655d708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Symbol atom for the special MeTTa symbol: "%Undefined%".  <br /></td></tr>
<tr class="memitem:ga110b8e6977f708aa7dbe1b9fbfb5b2c3" id="r_ga110b8e6977f708aa7dbe1b9fbfb5b2c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#ga110b8e6977f708aa7dbe1b9fbfb5b2c3">ATOM_TYPE_TYPE</a> (void)</td></tr>
<tr class="memdesc:ga110b8e6977f708aa7dbe1b9fbfb5b2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Symbol atom for the special MeTTa symbol: "Type", used to indicate that an atom represents the type of another atom.  <br /></td></tr>
<tr class="memitem:ga8bc87ee381f9ac56a4b7514a763c3fe7" id="r_ga8bc87ee381f9ac56a4b7514a763c3fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#ga8bc87ee381f9ac56a4b7514a763c3fe7">ATOM_TYPE_ATOM</a> (void)</td></tr>
<tr class="memdesc:ga8bc87ee381f9ac56a4b7514a763c3fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Symbol atom for the special MeTTa symbol: "Atom", used to indicate that an atom's type is a generic atom.  <br /></td></tr>
<tr class="memitem:gae29f513599f7e422487e0b4e9884523e" id="r_gae29f513599f7e422487e0b4e9884523e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#gae29f513599f7e422487e0b4e9884523e">ATOM_TYPE_SYMBOL</a> (void)</td></tr>
<tr class="memdesc:gae29f513599f7e422487e0b4e9884523e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Symbol atom for the special MeTTa symbol: "Symbol", used to indicate that an atom's type is a symbol atom.  <br /></td></tr>
<tr class="memitem:gaf7f228993d009c9cb27e29362e752c5a" id="r_gaf7f228993d009c9cb27e29362e752c5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#gaf7f228993d009c9cb27e29362e752c5a">ATOM_TYPE_VARIABLE</a> (void)</td></tr>
<tr class="memdesc:gaf7f228993d009c9cb27e29362e752c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Symbol atom for the special MeTTa symbol: "Variable", used to indicate that an atom's type is a variable atom.  <br /></td></tr>
<tr class="memitem:gaf79894dbfebdc6cfe978f550d1aa2ac1" id="r_gaf79894dbfebdc6cfe978f550d1aa2ac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#gaf79894dbfebdc6cfe978f550d1aa2ac1">ATOM_TYPE_EXPRESSION</a> (void)</td></tr>
<tr class="memdesc:gaf79894dbfebdc6cfe978f550d1aa2ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Symbol atom for the special MeTTa symbol: "Expression", used to indicate that an atom's type is an expression atom.  <br /></td></tr>
<tr class="memitem:ga0ff67952618ae617052761ad4948a119" id="r_ga0ff67952618ae617052761ad4948a119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#ga0ff67952618ae617052761ad4948a119">ATOM_TYPE_GROUNDED</a> (void)</td></tr>
<tr class="memdesc:ga0ff67952618ae617052761ad4948a119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Symbol atom for the special MeTTa symbol: "Grounded", used to indicate that an atom's type is a grounded atom.  <br /></td></tr>
<tr class="memitem:ga5b7b8f16bade41526b3bc31f38f11ff1" id="r_ga5b7b8f16bade41526b3bc31f38f11ff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#ga5b7b8f16bade41526b3bc31f38f11ff1">ATOM_TYPE_GROUNDED_SPACE</a> (void)</td></tr>
<tr class="memdesc:ga5b7b8f16bade41526b3bc31f38f11ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Symbol atom for the special MeTTa symbol used to indicate that an atom's type is a wrapper around a Space.  <br /></td></tr>
<tr class="memitem:ga4eda11ce2688f6e96488bba306ee7371" id="r_ga4eda11ce2688f6e96488bba306ee7371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#ga4eda11ce2688f6e96488bba306ee7371">ATOM_TYPE_UNIT</a> (void)</td></tr>
<tr class="memdesc:ga4eda11ce2688f6e96488bba306ee7371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an atom used to indicate that an atom's type is a unit type.  <br /></td></tr>
<tr class="memitem:gab828f9dfe105633c9116cd35d1f27387" id="r_gab828f9dfe105633c9116cd35d1f27387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#gab828f9dfe105633c9116cd35d1f27387">ATOM_TYPE_NUMBER</a> (void)</td></tr>
<tr class="memdesc:gab828f9dfe105633c9116cd35d1f27387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an atom used to indicate that an atom's type is a Number type.  <br /></td></tr>
<tr class="memitem:gac95d27bc53309ff277bdcd3cc6d6cf71" id="r_gac95d27bc53309ff277bdcd3cc6d6cf71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#gac95d27bc53309ff277bdcd3cc6d6cf71">ATOM_TYPE_BOOL</a> (void)</td></tr>
<tr class="memdesc:gac95d27bc53309ff277bdcd3cc6d6cf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an atom used to indicate that an atom's type is a Bool type.  <br /></td></tr>
<tr class="memitem:ga288831a2958dfefdaf821b42df01fd1f" id="r_ga288831a2958dfefdaf821b42df01fd1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#ga288831a2958dfefdaf821b42df01fd1f">ATOM_TYPE_STRING</a> (void)</td></tr>
<tr class="memdesc:ga288831a2958dfefdaf821b42df01fd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an atom used to indicate that an atom's type is a String type.  <br /></td></tr>
<tr class="memitem:ga93b7c4b26a3017beef6bdfffeb66e682" id="r_ga93b7c4b26a3017beef6bdfffeb66e682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#ga93b7c4b26a3017beef6bdfffeb66e682">EMPTY_ATOM</a> (void)</td></tr>
<tr class="memdesc:ga93b7c4b26a3017beef6bdfffeb66e682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Symbol atom for the special MeTTa symbol used to indicate empty results returned by function.  <br /></td></tr>
<tr class="memitem:gaf0e56cfedb471652072aca57735e3023" id="r_gaf0e56cfedb471652072aca57735e3023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#gaf0e56cfedb471652072aca57735e3023">UNIT_ATOM</a> (void)</td></tr>
<tr class="memdesc:gaf0e56cfedb471652072aca57735e3023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an atom used to return from functions which are not supposed to return results (print for example).  <br /></td></tr>
<tr class="memitem:gae0dddcd227ab71ef5d2bff94986bfccf" id="r_gae0dddcd227ab71ef5d2bff94986bfccf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#gae0dddcd227ab71ef5d2bff94986bfccf">METTA_ATOM</a> (void)</td></tr>
<tr class="memdesc:gae0dddcd227ab71ef5d2bff94986bfccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Symbol atom for the special MeTTa symbol used to indicate calling MeTTa interpreter.  <br /></td></tr>
<tr class="memitem:ga416c71efc7a353817b9103a1eb1db716" id="r_ga416c71efc7a353817b9103a1eb1db716"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#ga416c71efc7a353817b9103a1eb1db716">check_type</a> (const struct <a class="el" href="structspace__t.html">space_t</a> *space, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *typ)</td></tr>
<tr class="memdesc:ga416c71efc7a353817b9103a1eb1db716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether Atom <span class="tt">atom</span> has Type <span class="tt">typ</span> in context of <span class="tt">space</span>  <br /></td></tr>
<tr class="memitem:ga353a28d814d5f7f2a4090e0778399666" id="r_ga353a28d814d5f7f2a4090e0778399666"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#ga353a28d814d5f7f2a4090e0778399666">validate_atom</a> (const struct <a class="el" href="structspace__t.html">space_t</a> *space, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga353a28d814d5f7f2a4090e0778399666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <span class="tt">atom</span> is correctly typed.  <br /></td></tr>
<tr class="memitem:gab8285de95f5a58c2bacc78818874f94c" id="r_gab8285de95f5a58c2bacc78818874f94c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metta__language__group.html#gab8285de95f5a58c2bacc78818874f94c">get_atom_types</a> (const struct <a class="el" href="structspace__t.html">space_t</a> *space, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom, <a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:gab8285de95f5a58c2bacc78818874f94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides all types for <span class="tt">atom</span> in the context of <span class="tt">space</span>  <br /></td></tr>
<tr class="memitem:ga9ab2f56ef27dd6d3c2279ade44a6a4ba" id="r_ga9ab2f56ef27dd6d3c2279ade44a6a4ba"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstep__result__t.html">step_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga9ab2f56ef27dd6d3c2279ade44a6a4ba">interpret_init</a> (struct <a class="el" href="structspace__t.html">space_t</a> *space, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *expr)</td></tr>
<tr class="memdesc:ga9ab2f56ef27dd6d3c2279ade44a6a4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an interpreter operation and take the initial step.  <br /></td></tr>
<tr class="memitem:ga46c4f6387eff941a375d75e9fb70104b" id="r_ga46c4f6387eff941a375d75e9fb70104b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstep__result__t.html">step_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga46c4f6387eff941a375d75e9fb70104b">interpret_step</a> (struct <a class="el" href="structstep__result__t.html">step_result_t</a> step)</td></tr>
<tr class="memdesc:ga46c4f6387eff941a375d75e9fb70104b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a subsequent step in an in-flight interpreter operation.  <br /></td></tr>
<tr class="memitem:ga7b4fd14aa654366f9c922e0b55bfaf6c" id="r_ga7b4fd14aa654366f9c922e0b55bfaf6c"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga7b4fd14aa654366f9c922e0b55bfaf6c">step_to_str</a> (const struct <a class="el" href="structstep__result__t.html">step_result_t</a> *step, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:ga7b4fd14aa654366f9c922e0b55bfaf6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a text description of a <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> into a buffer.  <br /></td></tr>
<tr class="memitem:ga63b1315f944f3c4faa72dfe899526723" id="r_ga63b1315f944f3c4faa72dfe899526723"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga63b1315f944f3c4faa72dfe899526723">step_has_next</a> (const struct <a class="el" href="structstep__result__t.html">step_result_t</a> *step)</td></tr>
<tr class="memdesc:ga63b1315f944f3c4faa72dfe899526723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines a <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> to determine if more work is needed.  <br /></td></tr>
<tr class="memitem:gadab1c155c75bbc732aa5edc83ac73b79" id="r_gadab1c155c75bbc732aa5edc83ac73b79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#gadab1c155c75bbc732aa5edc83ac73b79">step_get_result</a> (struct <a class="el" href="structstep__result__t.html">step_result_t</a> step, <a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:gadab1c155c75bbc732aa5edc83ac73b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes a <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> and provides the ultimate outcome of a MeTTa interpreter session.  <br /></td></tr>
<tr class="memitem:ga0fae150c70a9749a63d02af3dec13dcf" id="r_ga0fae150c70a9749a63d02af3dec13dcf"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmetta__t.html">metta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga0fae150c70a9749a63d02af3dec13dcf">metta_new</a> (void)</td></tr>
<tr class="memdesc:ga0fae150c70a9749a63d02af3dec13dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-level MeTTa Runner, with only the Rust stdlib loaded.  <br /></td></tr>
<tr class="memitem:ga40bfcb434d9cf2fe79ceb84625894c6d" id="r_ga40bfcb434d9cf2fe79ceb84625894c6d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmetta__t.html">metta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga40bfcb434d9cf2fe79ceb84625894c6d">metta_new_with_stdlib_loader</a> (struct <a class="el" href="structmodule__loader__t.html">module_loader_t</a> *stdlib_loader_mov, struct <a class="el" href="structspace__t.html">space_t</a> *space_ref, struct <a class="el" href="structenv__builder__t.html">env_builder_t</a> env_builder_mov)</td></tr>
<tr class="memdesc:ga40bfcb434d9cf2fe79ceb84625894c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-level MeTTa Runner, with the specified <span class="tt">stdlib</span> module loaded.  <br /></td></tr>
<tr class="memitem:ga9bd33f0ebf40f201c1378534f49d0eaf" id="r_ga9bd33f0ebf40f201c1378534f49d0eaf"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmetta__t.html">metta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga9bd33f0ebf40f201c1378534f49d0eaf">metta_new_core</a> (struct <a class="el" href="structspace__t.html">space_t</a> *space, struct <a class="el" href="structenv__builder__t.html">env_builder_t</a> env_builder)</td></tr>
<tr class="memdesc:ga9bd33f0ebf40f201c1378534f49d0eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new core MeTTa runner, with no loaded stdlib nor initialization.  <br /></td></tr>
<tr class="memitem:ga3f1bc3621331808c16eaa05ad22b1417" id="r_ga3f1bc3621331808c16eaa05ad22b1417"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmetta__t.html">metta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga3f1bc3621331808c16eaa05ad22b1417">metta_clone_handle</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *metta)</td></tr>
<tr class="memdesc:ga3f1bc3621331808c16eaa05ad22b1417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones a <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handle.  <br /></td></tr>
<tr class="memitem:ga0db9c5ab905ebe5285ff2418779b5dee" id="r_ga0db9c5ab905ebe5285ff2418779b5dee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga0db9c5ab905ebe5285ff2418779b5dee">metta_free</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> metta)</td></tr>
<tr class="memdesc:ga0db9c5ab905ebe5285ff2418779b5dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handle.  <br /></td></tr>
<tr class="memitem:gafdfc4efb62fd521a004958ddd55702ea" id="r_gafdfc4efb62fd521a004958ddd55702ea"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#gafdfc4efb62fd521a004958ddd55702ea">metta_err_str</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *metta)</td></tr>
<tr class="memdesc:gafdfc4efb62fd521a004958ddd55702ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error string associated with the last <span class="tt">metta_run</span>, <span class="tt">metta_evaluate_atom</span>, or <span class="tt">metta_load_module</span> call.  <br /></td></tr>
<tr class="memitem:gac72e96d47a54a372ec1d32c59420ba2d" id="r_gac72e96d47a54a372ec1d32c59420ba2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#gac72e96d47a54a372ec1d32c59420ba2d">metta_eq</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *a, const struct <a class="el" href="structmetta__t.html">metta_t</a> *b)</td></tr>
<tr class="memdesc:gac72e96d47a54a372ec1d32c59420ba2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handles to test whether the referenced MeTTa runner is the same.  <br /></td></tr>
<tr class="memitem:ga7adfab973fdd5ca4806fcba1ec049f13" id="r_ga7adfab973fdd5ca4806fcba1ec049f13"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__t.html">space_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga7adfab973fdd5ca4806fcba1ec049f13">metta_space</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> *metta)</td></tr>
<tr class="memdesc:ga7adfab973fdd5ca4806fcba1ec049f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the Space of the runner's top-level module.  <br /></td></tr>
<tr class="memitem:ga82e95ca93f0c1bb8b65816d1dbd5974d" id="r_ga82e95ca93f0c1bb8b65816d1dbd5974d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga82e95ca93f0c1bb8b65816d1dbd5974d">metta_tokenizer</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> *metta)</td></tr>
<tr class="memdesc:ga82e95ca93f0c1bb8b65816d1dbd5974d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the Tokenizer of the runner's top-level module.  <br /></td></tr>
<tr class="memitem:ga0fac7779f10dededa29013b902ff7455" id="r_ga0fac7779f10dededa29013b902ff7455"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga0fac7779f10dededa29013b902ff7455">metta_working_dir</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:ga0fac7779f10dededa29013b902ff7455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the working directory of the runner's environment into a buffer.  <br /></td></tr>
<tr class="memitem:ga9a5092224ff87fd7de602a2667614c4d" id="r_ga9a5092224ff87fd7de602a2667614c4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga9a5092224ff87fd7de602a2667614c4d">metta_run</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> parser, <a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:ga9a5092224ff87fd7de602a2667614c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the MeTTa runner until the input text has been fully parsed and evaluated.  <br /></td></tr>
<tr class="memitem:ga2d304e7181fd9d1fb41b618e7d4e0e38" id="r_ga2d304e7181fd9d1fb41b618e7d4e0e38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga2d304e7181fd9d1fb41b618e7d4e0e38">metta_evaluate_atom</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, <a class="el" href="structatom__t.html">atom_t</a> atom, <a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:ga2d304e7181fd9d1fb41b618e7d4e0e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the MeTTa runner to evaluate an input Atom.  <br /></td></tr>
<tr class="memitem:gaa191e65a9443e87f8c81b80136fb6439" id="r_gaa191e65a9443e87f8c81b80136fb6439"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmodule__id__t.html">module_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#gaa191e65a9443e87f8c81b80136fb6439">metta_load_module_direct</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> *metta_ref, const char *name_ref, struct <a class="el" href="structmodule__loader__t.html">module_loader_t</a> *loader_mov)</td></tr>
<tr class="memdesc:gaa191e65a9443e87f8c81b80136fb6439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a module directly into the runner, from a <a class="el" href="structmodule__loader__t.html" title="A C representation of the Rust [ModuleLoader] interface. User can provide [ModuleLoader] methods impl...">module_loader_t</a>.  <br /></td></tr>
<tr class="memitem:ga83161daec4c3c076f2bebaf1b675ceb2" id="r_ga83161daec4c3c076f2bebaf1b675ceb2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmodule__id__t.html">module_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga83161daec4c3c076f2bebaf1b675ceb2">metta_load_module_at_path</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, const char *path, const char *name)</td></tr>
<tr class="memdesc:ga83161daec4c3c076f2bebaf1b675ceb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a module into the runner from a module resource at a file system path.  <br /></td></tr>
<tr class="memitem:gabf884db2b979249261339770d3de86ff" id="r_gabf884db2b979249261339770d3de86ff"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__t.html">space_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#gabf884db2b979249261339770d3de86ff">metta_get_module_space</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, struct <a class="el" href="structmodule__id__t.html">module_id_t</a> mod_id)</td></tr>
<tr class="memdesc:gabf884db2b979249261339770d3de86ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Space for a loaded module.  <br /></td></tr>
<tr class="memitem:ga807a3a941df92f54e28ceb245671c4f3" id="r_ga807a3a941df92f54e28ceb245671c4f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga807a3a941df92f54e28ceb245671c4f3">run_context_push_parser</a> (struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context, struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> parser)</td></tr>
<tr class="memdesc:ga807a3a941df92f54e28ceb245671c4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the parser to the Run Context's queue of input to run.  <br /></td></tr>
<tr class="memitem:gafbbe0e25cd3e024eb6fa8cd8f2b2b9e5" id="r_gafbbe0e25cd3e024eb6fa8cd8f2b2b9e5"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmetta__t.html">metta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#gafbbe0e25cd3e024eb6fa8cd8f2b2b9e5">run_context_get_metta</a> (const struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context)</td></tr>
<tr class="memdesc:gafbbe0e25cd3e024eb6fa8cd8f2b2b9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> runner that a run context is executing within.  <br /></td></tr>
<tr class="memitem:ga7f5e200571764a8f6b24fdf4a993d40e" id="r_ga7f5e200571764a8f6b24fdf4a993d40e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__t.html">space_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga7f5e200571764a8f6b24fdf4a993d40e">run_context_get_space</a> (const struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context)</td></tr>
<tr class="memdesc:ga7f5e200571764a8f6b24fdf4a993d40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the Space of the currently running module.  <br /></td></tr>
<tr class="memitem:ga7b0eda1064b72452c001980e172de85a" id="r_ga7b0eda1064b72452c001980e172de85a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga7b0eda1064b72452c001980e172de85a">run_context_get_tokenizer</a> (const struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context)</td></tr>
<tr class="memdesc:ga7b0eda1064b72452c001980e172de85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the Tokenizer of the currently running module.  <br /></td></tr>
<tr class="memitem:ga5b7ae412e6cc3f7126b1ec6011ce483e" id="r_ga5b7ae412e6cc3f7126b1ec6011ce483e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga5b7ae412e6cc3f7126b1ec6011ce483e">run_context_raise_error</a> (struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context, const char *message)</td></tr>
<tr class="memdesc:ga5b7ae412e6cc3f7126b1ec6011ce483e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a runtime error.  <br /></td></tr>
<tr class="memitem:ga573f10ed5f78555dc9ee2edc429bd8f4" id="r_ga573f10ed5f78555dc9ee2edc429bd8f4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrunner__state__t.html">runner_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga573f10ed5f78555dc9ee2edc429bd8f4">runner_state_new_with_parser</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> parser)</td></tr>
<tr class="memdesc:ga573f10ed5f78555dc9ee2edc429bd8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a>, to use for step-wise execution of MeTTa text.  <br /></td></tr>
<tr class="memitem:gad99336318e713daa7ed30ebc56b82762" id="r_gad99336318e713daa7ed30ebc56b82762"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrunner__state__t.html">runner_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#gad99336318e713daa7ed30ebc56b82762">runner_state_new_with_atoms</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, const struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> *atoms)</td></tr>
<tr class="memdesc:gad99336318e713daa7ed30ebc56b82762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a>, to use for step-wise execution of a list of atoms.  <br /></td></tr>
<tr class="memitem:gadf3ade0caafe291b2fb3a5ada6154478" id="r_gadf3ade0caafe291b2fb3a5ada6154478"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#gadf3ade0caafe291b2fb3a5ada6154478">runner_state_free</a> (struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> state)</td></tr>
<tr class="memdesc:gadf3ade0caafe291b2fb3a5ada6154478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a>.  <br /></td></tr>
<tr class="memitem:ga3018cdbc5d450c8b7bb322c641bd7d87" id="r_ga3018cdbc5d450c8b7bb322c641bd7d87"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga3018cdbc5d450c8b7bb322c641bd7d87">runner_state_err_str</a> (const struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *state)</td></tr>
<tr class="memdesc:ga3018cdbc5d450c8b7bb322c641bd7d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error string associated with the last <span class="tt">runner_state_step</span>  <br /></td></tr>
<tr class="memitem:gac5d60583dda4bd7c31a876582c42810e" id="r_gac5d60583dda4bd7c31a876582c42810e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#gac5d60583dda4bd7c31a876582c42810e">runner_state_step</a> (struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *state)</td></tr>
<tr class="memdesc:gac5d60583dda4bd7c31a876582c42810e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs one step of the runner.  <br /></td></tr>
<tr class="memitem:gabe67b8549e322ba0f36c1ef1133b430f" id="r_gabe67b8549e322ba0f36c1ef1133b430f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#gabe67b8549e322ba0f36c1ef1133b430f">runner_state_is_complete</a> (const struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *state)</td></tr>
<tr class="memdesc:gabe67b8549e322ba0f36c1ef1133b430f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a> has completed all outstanding work.  <br /></td></tr>
<tr class="memitem:ga039ce982dfdf406bf1b05f8b78ec4b1b" id="r_ga039ce982dfdf406bf1b05f8b78ec4b1b"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#ga039ce982dfdf406bf1b05f8b78ec4b1b">runner_state_to_str</a> (const struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *state, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:ga039ce982dfdf406bf1b05f8b78ec4b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a text description of a <span class="tt"><a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a></span> into a buffer.  <br /></td></tr>
<tr class="memitem:gae96248f793285f209d526284a382963f" id="r_gae96248f793285f209d526284a382963f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interpreter__group.html#gae96248f793285f209d526284a382963f">runner_state_current_results</a> (const struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *state, <a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:gae96248f793285f209d526284a382963f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the current in-flight results in the <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a>.  <br /></td></tr>
<tr class="memitem:ga6290c6ab680c8ae05930e0d6fc7d03e4" id="r_ga6290c6ab680c8ae05930e0d6fc7d03e4"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#ga6290c6ab680c8ae05930e0d6fc7d03e4">environment_config_dir</a> (char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:ga6290c6ab680c8ae05930e0d6fc7d03e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the config_dir path from the common environment into a text buffer.  <br /></td></tr>
<tr class="memitem:ga8e02840d6d709a408a6748ddb7780774" id="r_ga8e02840d6d709a408a6748ddb7780774"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structenv__builder__t.html">env_builder_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#ga8e02840d6d709a408a6748ddb7780774">env_builder_start</a> (void)</td></tr>
<tr class="memdesc:ga8e02840d6d709a408a6748ddb7780774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins initialization of an environment.  <br /></td></tr>
<tr class="memitem:ga974b2bec267fcaaf10a482ab675fcd00" id="r_ga974b2bec267fcaaf10a482ab675fcd00"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structenv__builder__t.html">env_builder_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#ga974b2bec267fcaaf10a482ab675fcd00">env_builder_use_default</a> (void)</td></tr>
<tr class="memdesc:ga974b2bec267fcaaf10a482ab675fcd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <span class="tt"><a class="el" href="structenv__builder__t.html" title="Represents an environment initialization, in progress.">env_builder_t</a></span> to specify that the default common environment should be used.  <br /></td></tr>
<tr class="memitem:gafa7212b47e34f5caffb039fe3794f8a9" id="r_gafa7212b47e34f5caffb039fe3794f8a9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structenv__builder__t.html">env_builder_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#gafa7212b47e34f5caffb039fe3794f8a9">env_builder_use_test_env</a> (void)</td></tr>
<tr class="memdesc:gafa7212b47e34f5caffb039fe3794f8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience to create an <span class="tt"><a class="el" href="structenv__builder__t.html" title="Represents an environment initialization, in progress.">env_builder_t</a></span>, to specify that a unit-test environment should be used.  <br /></td></tr>
<tr class="memitem:ga3ff3761777cd48fbd5f09f2455225035" id="r_ga3ff3761777cd48fbd5f09f2455225035"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#ga3ff3761777cd48fbd5f09f2455225035">env_builder_init_common_env</a> (struct <a class="el" href="structenv__builder__t.html">env_builder_t</a> builder)</td></tr>
<tr class="memdesc:ga3ff3761777cd48fbd5f09f2455225035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes initialization of the common environment.  <br /></td></tr>
<tr class="memitem:gaf0c38b7a69605338da661f60963e6618" id="r_gaf0c38b7a69605338da661f60963e6618"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#gaf0c38b7a69605338da661f60963e6618">env_builder_set_working_dir</a> (struct <a class="el" href="structenv__builder__t.html">env_builder_t</a> *builder, const char *path)</td></tr>
<tr class="memdesc:gaf0c38b7a69605338da661f60963e6618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the working directory for the environment.  <br /></td></tr>
<tr class="memitem:ga223598c0d66bb04a8665d2217c361a19" id="r_ga223598c0d66bb04a8665d2217c361a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#ga223598c0d66bb04a8665d2217c361a19">env_builder_set_config_dir</a> (struct <a class="el" href="structenv__builder__t.html">env_builder_t</a> *builder, const char *path)</td></tr>
<tr class="memdesc:ga223598c0d66bb04a8665d2217c361a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the config directory for the environment.  <br /></td></tr>
<tr class="memitem:ga8889cc36c8b58187df2fda2301935765" id="r_ga8889cc36c8b58187df2fda2301935765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#ga8889cc36c8b58187df2fda2301935765">env_builder_create_config_dir</a> (struct <a class="el" href="structenv__builder__t.html">env_builder_t</a> *builder, bool should_create)</td></tr>
<tr class="memdesc:ga8889cc36c8b58187df2fda2301935765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the config dir should be created if it doesn't already exist.  <br /></td></tr>
<tr class="memitem:gafd1129aa579ed7ecf02f18c03c5ec3c4" id="r_gafd1129aa579ed7ecf02f18c03c5ec3c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#gafd1129aa579ed7ecf02f18c03c5ec3c4">env_builder_set_default_config_dir</a> (struct <a class="el" href="structenv__builder__t.html">env_builder_t</a> *builder)</td></tr>
<tr class="memdesc:gafd1129aa579ed7ecf02f18c03c5ec3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default config directory for the environment.  <br /></td></tr>
<tr class="memitem:gae1b50ef8af8807ff1f495a3a67480ffb" id="r_gae1b50ef8af8807ff1f495a3a67480ffb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#gae1b50ef8af8807ff1f495a3a67480ffb">env_builder_set_is_test</a> (struct <a class="el" href="structenv__builder__t.html">env_builder_t</a> *builder, bool is_test)</td></tr>
<tr class="memdesc:gae1b50ef8af8807ff1f495a3a67480ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the environment for use in unit testing.  <br /></td></tr>
<tr class="memitem:gad4e469047be954665c620249061a3246" id="r_gad4e469047be954665c620249061a3246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#gad4e469047be954665c620249061a3246">env_builder_push_include_path</a> (struct <a class="el" href="structenv__builder__t.html">env_builder_t</a> *builder, const char *path)</td></tr>
<tr class="memdesc:gad4e469047be954665c620249061a3246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directory to search for module imports.  <br /></td></tr>
<tr class="memitem:gaf89d4239453428e8400666d812a4e2b6" id="r_gaf89d4239453428e8400666d812a4e2b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#gaf89d4239453428e8400666d812a4e2b6">env_builder_push_fs_module_format</a> (struct <a class="el" href="structenv__builder__t.html">env_builder_t</a> *builder, const struct <a class="el" href="structfs__module__format__t.html">fs_module_format_t</a> *format)</td></tr>
<tr class="memdesc:gaf89d4239453428e8400666d812a4e2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds logic to interpret a foreign format for MeTTa modules loaded from the file system.  <br /></td></tr>
<tr class="memitem:ga427f1a6b74db8f7a029bdd1ff67f8a54" id="r_ga427f1a6b74db8f7a029bdd1ff67f8a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__group.html#ga427f1a6b74db8f7a029bdd1ff67f8a54">run_context_init_self_module</a> (struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context, struct <a class="el" href="structspace__t.html">space_t</a> *space, const char *resource_dir_path)</td></tr>
<tr class="memdesc:ga427f1a6b74db8f7a029bdd1ff67f8a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called within a module <span class="tt">loader</span> function to initialize the new module.  <br /></td></tr>
<tr class="memitem:gaa2116d9ded6a33281d43b23a72e5a57c" id="r_gaa2116d9ded6a33281d43b23a72e5a57c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmodule__id__t.html">module_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__group.html#gaa2116d9ded6a33281d43b23a72e5a57c">run_context_load_module</a> (struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context, const char *name)</td></tr>
<tr class="memdesc:gaa2116d9ded6a33281d43b23a72e5a57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves a module name in the context of a running module, and loads that module if it's not already loaded.  <br /></td></tr>
<tr class="memitem:gadbe139b7af4b5d35090837f4395a8521" id="r_gadbe139b7af4b5d35090837f4395a8521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__group.html#gadbe139b7af4b5d35090837f4395a8521">run_context_import_dependency</a> (struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context, struct <a class="el" href="structmodule__id__t.html">module_id_t</a> mod_id)</td></tr>
<tr class="memdesc:gadbe139b7af4b5d35090837f4395a8521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports a dependency module into the currently running module. This is "import *" behavior.  <br /></td></tr>
<tr class="memitem:a32f449961442b8bcf8f53d9985a4555d" id="r_a32f449961442b8bcf8f53d9985a4555d"><td class="memItemLeft" align="right" valign="top"><a id="a32f449961442b8bcf8f53d9985a4555d" name="a32f449961442b8bcf8f53d9985a4555d"></a>
enum <a class="el" href="structserial__result__t.html">serial_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>serialize_bool_rust_adapter</b> (void *context, bool v)</td></tr>
<tr class="memitem:ac656c973555033c34dc82c041b468e5a" id="r_ac656c973555033c34dc82c041b468e5a"><td class="memItemLeft" align="right" valign="top"><a id="ac656c973555033c34dc82c041b468e5a" name="ac656c973555033c34dc82c041b468e5a"></a>
enum <a class="el" href="structserial__result__t.html">serial_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>serialize_longlong_rust_adapter</b> (void *context, long long v)</td></tr>
<tr class="memitem:a9f21c8e59fc57191dcccc98d2896d4cd" id="r_a9f21c8e59fc57191dcccc98d2896d4cd"><td class="memItemLeft" align="right" valign="top"><a id="a9f21c8e59fc57191dcccc98d2896d4cd" name="a9f21c8e59fc57191dcccc98d2896d4cd"></a>
enum <a class="el" href="structserial__result__t.html">serial_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>serialize_double_rust_adapter</b> (void *context, double v)</td></tr>
<tr class="memitem:ad4d73a50fc3b709e66f036a1567ecc36" id="r_ad4d73a50fc3b709e66f036a1567ecc36"><td class="memItemLeft" align="right" valign="top"><a id="ad4d73a50fc3b709e66f036a1567ecc36" name="ad4d73a50fc3b709e66f036a1567ecc36"></a>
enum <a class="el" href="structserial__result__t.html">serial_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>serialize_str_rust_adapter</b> (void *context, const char *v)</td></tr>
<tr class="memitem:gae100fc269ee1b49a55f9d9076330a676" id="r_gae100fc269ee1b49a55f9d9076330a676"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__group.html#gae100fc269ee1b49a55f9d9076330a676">metta_mod_ref_tokenizer</a> (const struct <a class="el" href="structmetta__mod__ref__t.html">metta_mod_ref_t</a> *mod_ref)</td></tr>
<tr class="memdesc:gae100fc269ee1b49a55f9d9076330a676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns tokenizer of the MeTTa module.  <br /></td></tr>
<tr class="memitem:gabefe4044b27a30231d1fa76d9ab25bdf" id="r_gabefe4044b27a30231d1fa76d9ab25bdf"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmodule__descriptor__t.html">module_descriptor_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__group.html#gabefe4044b27a30231d1fa76d9ab25bdf">module_descriptor_new</a> (const char *name)</td></tr>
<tr class="memdesc:gabefe4044b27a30231d1fa76d9ab25bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="structmodule__descriptor__t.html" title="Identifies the properties on a specific module, including its name and version.">module_descriptor_t</a> with the specified name.  <br /></td></tr>
<tr class="memitem:ab5fd5bb493b87c9181bc2e7d0acfed91" id="r_ab5fd5bb493b87c9181bc2e7d0acfed91"><td class="memItemLeft" align="right" valign="top"><a id="ab5fd5bb493b87c9181bc2e7d0acfed91" name="ab5fd5bb493b87c9181bc2e7d0acfed91"></a>
struct <a class="el" href="structmodule__descriptor__t.html">module_descriptor_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>module_descriptor_new_with_path_and_fmt_id</b> (const char *name, const char *path, uint64_t fmt_id)</td></tr>
<tr class="memitem:gaade7e8d0ec9a65dcc83a4daaeb539309" id="r_gaade7e8d0ec9a65dcc83a4daaeb539309"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmodule__descriptor__t.html">module_descriptor_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__group.html#gaade7e8d0ec9a65dcc83a4daaeb539309">module_descriptor_clone</a> (const struct <a class="el" href="structmodule__descriptor__t.html">module_descriptor_t</a> *descriptor)</td></tr>
<tr class="memdesc:gaade7e8d0ec9a65dcc83a4daaeb539309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="structmodule__descriptor__t.html" title="Identifies the properties on a specific module, including its name and version.">module_descriptor_t</a> that is a clone of the argument passed.  <br /></td></tr>
<tr class="memitem:gaa7f136e7cb9462b090911a5b39254f6a" id="r_gaa7f136e7cb9462b090911a5b39254f6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__group.html#gaa7f136e7cb9462b090911a5b39254f6a">module_descriptor_free</a> (struct <a class="el" href="structmodule__descriptor__t.html">module_descriptor_t</a> descriptor)</td></tr>
<tr class="memdesc:gaa7f136e7cb9462b090911a5b39254f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="structmodule__descriptor__t.html" title="Identifies the properties on a specific module, including its name and version.">module_descriptor_t</a>.  <br /></td></tr>
<tr class="memitem:ga10af9f5e33088afd0c67c05ba850be00" id="r_ga10af9f5e33088afd0c67c05ba850be00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__group.html#ga10af9f5e33088afd0c67c05ba850be00">module_id_is_valid</a> (const struct <a class="el" href="structmodule__id__t.html">module_id_t</a> *mod_id)</td></tr>
<tr class="memdesc:ga10af9f5e33088afd0c67c05ba850be00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> is a <a class="el" href="structmodule__id__t.html" title="Identifies a loaded module inside a specific metta_t MeTTa runner.">module_id_t</a> is valid, otherwise returns <span class="tt">false</span>  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a7e5a19c608c5c2cb5436ebc29e66aeb9" name="a7e5a19c608c5c2cb5436ebc29e66aeb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5a19c608c5c2cb5436ebc29e66aeb9">&#9670;&#160;</a></span>RustMettaModRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="#a7e5a19c608c5c2cb5436ebc29e66aeb9">RustMettaModRef</a> <a class="el" href="#a7e5a19c608c5c2cb5436ebc29e66aeb9">RustMettaModRef</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure is required to remove notice of MettaMod from C header file </p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a1ad5d52e239321fe08b1a7f547be8b01" name="a1ad5d52e239321fe08b1a7f547be8b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad5d52e239321fe08b1a7f547be8b01">&#9670;&#160;</a></span>serial_result_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum serial_result_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1ad5d52e239321fe08b1a7f547be8b01a2bc49ec37d6a5715dd23e85f1ff5bb59" name="a1ad5d52e239321fe08b1a7f547be8b01a2bc49ec37d6a5715dd23e85f1ff5bb59"></a>OK&#160;</td><td class="fielddoc"><p>Successful serialization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1ad5d52e239321fe08b1a7f547be8b01a9bf1138c8c1f4519e5b814514b750ca3" name="a1ad5d52e239321fe08b1a7f547be8b01a9bf1138c8c1f4519e5b814514b750ca3"></a>NOT_SUPPORTED&#160;</td><td class="fielddoc"><p>Serialization of the value is not supported by serializer. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
