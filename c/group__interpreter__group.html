<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hyperon C: MeTTa Interpreter Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hyperon C
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">MeTTa Interpreter Interface </div></div>
</div><!--header-->
<div class="contents">

<p>Top-level API to execute MeTTa code.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:step_5Fresult_5Ft" id="r_step_5Fresult_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstep__result__t.html">step_result_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the state for an in-flight interpreter operation.  <a href="structstep__result__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:metta_5Ft" id="r_metta_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmetta__t.html">metta_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A top-level MeTTa runner.  <a href="structmetta__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:run_5Fcontext_5Ft" id="r_run_5Fcontext_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrun__context__t.html">run_context_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface object providing access to the MeTTa run interface.  <a href="structrun__context__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:runner_5Fstate_5Ft" id="r_runner_5Fstate_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrunner__state__t.html">runner_state_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the state of an in-flight MeTTa execution run.  <a href="structrunner__state__t.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9ab2f56ef27dd6d3c2279ade44a6a4ba" id="r_ga9ab2f56ef27dd6d3c2279ade44a6a4ba"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstep__result__t.html">step_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9ab2f56ef27dd6d3c2279ade44a6a4ba">interpret_init</a> (struct <a class="el" href="structspace__t.html">space_t</a> *space, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *expr)</td></tr>
<tr class="memdesc:ga9ab2f56ef27dd6d3c2279ade44a6a4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an interpreter operation and take the initial step.  <br /></td></tr>
<tr class="memitem:ga46c4f6387eff941a375d75e9fb70104b" id="r_ga46c4f6387eff941a375d75e9fb70104b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstep__result__t.html">step_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga46c4f6387eff941a375d75e9fb70104b">interpret_step</a> (struct <a class="el" href="structstep__result__t.html">step_result_t</a> step)</td></tr>
<tr class="memdesc:ga46c4f6387eff941a375d75e9fb70104b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a subsequent step in an in-flight interpreter operation.  <br /></td></tr>
<tr class="memitem:ga7b4fd14aa654366f9c922e0b55bfaf6c" id="r_ga7b4fd14aa654366f9c922e0b55bfaf6c"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7b4fd14aa654366f9c922e0b55bfaf6c">step_to_str</a> (const struct <a class="el" href="structstep__result__t.html">step_result_t</a> *step, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:ga7b4fd14aa654366f9c922e0b55bfaf6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a text description of a <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> into a buffer.  <br /></td></tr>
<tr class="memitem:ga63b1315f944f3c4faa72dfe899526723" id="r_ga63b1315f944f3c4faa72dfe899526723"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga63b1315f944f3c4faa72dfe899526723">step_has_next</a> (const struct <a class="el" href="structstep__result__t.html">step_result_t</a> *step)</td></tr>
<tr class="memdesc:ga63b1315f944f3c4faa72dfe899526723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines a <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> to determine if more work is needed.  <br /></td></tr>
<tr class="memitem:gadab1c155c75bbc732aa5edc83ac73b79" id="r_gadab1c155c75bbc732aa5edc83ac73b79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadab1c155c75bbc732aa5edc83ac73b79">step_get_result</a> (struct <a class="el" href="structstep__result__t.html">step_result_t</a> step, <a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:gadab1c155c75bbc732aa5edc83ac73b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes a <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> and provides the ultimate outcome of a MeTTa interpreter session.  <br /></td></tr>
<tr class="memitem:ga0fae150c70a9749a63d02af3dec13dcf" id="r_ga0fae150c70a9749a63d02af3dec13dcf"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmetta__t.html">metta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0fae150c70a9749a63d02af3dec13dcf">metta_new</a> (void)</td></tr>
<tr class="memdesc:ga0fae150c70a9749a63d02af3dec13dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-level MeTTa Runner, with only the Rust stdlib loaded.  <br /></td></tr>
<tr class="memitem:ga40bfcb434d9cf2fe79ceb84625894c6d" id="r_ga40bfcb434d9cf2fe79ceb84625894c6d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmetta__t.html">metta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga40bfcb434d9cf2fe79ceb84625894c6d">metta_new_with_stdlib_loader</a> (struct <a class="el" href="structmodule__loader__t.html">module_loader_t</a> *stdlib_loader_mov, struct <a class="el" href="structspace__t.html">space_t</a> *space_ref, struct <a class="el" href="structenv__builder__t.html">env_builder_t</a> env_builder_mov)</td></tr>
<tr class="memdesc:ga40bfcb434d9cf2fe79ceb84625894c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-level MeTTa Runner, with the specified <span class="tt">stdlib</span> module loaded.  <br /></td></tr>
<tr class="memitem:ga9bd33f0ebf40f201c1378534f49d0eaf" id="r_ga9bd33f0ebf40f201c1378534f49d0eaf"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmetta__t.html">metta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9bd33f0ebf40f201c1378534f49d0eaf">metta_new_core</a> (struct <a class="el" href="structspace__t.html">space_t</a> *space, struct <a class="el" href="structenv__builder__t.html">env_builder_t</a> env_builder)</td></tr>
<tr class="memdesc:ga9bd33f0ebf40f201c1378534f49d0eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new core MeTTa runner, with no loaded stdlib nor initialization.  <br /></td></tr>
<tr class="memitem:ga3f1bc3621331808c16eaa05ad22b1417" id="r_ga3f1bc3621331808c16eaa05ad22b1417"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmetta__t.html">metta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f1bc3621331808c16eaa05ad22b1417">metta_clone_handle</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *metta)</td></tr>
<tr class="memdesc:ga3f1bc3621331808c16eaa05ad22b1417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones a <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handle.  <br /></td></tr>
<tr class="memitem:ga0db9c5ab905ebe5285ff2418779b5dee" id="r_ga0db9c5ab905ebe5285ff2418779b5dee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0db9c5ab905ebe5285ff2418779b5dee">metta_free</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> metta)</td></tr>
<tr class="memdesc:ga0db9c5ab905ebe5285ff2418779b5dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handle.  <br /></td></tr>
<tr class="memitem:gafdfc4efb62fd521a004958ddd55702ea" id="r_gafdfc4efb62fd521a004958ddd55702ea"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafdfc4efb62fd521a004958ddd55702ea">metta_err_str</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *metta)</td></tr>
<tr class="memdesc:gafdfc4efb62fd521a004958ddd55702ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error string associated with the last <span class="tt">metta_run</span>, <span class="tt">metta_evaluate_atom</span>, or <span class="tt">metta_load_module</span> call.  <br /></td></tr>
<tr class="memitem:gac72e96d47a54a372ec1d32c59420ba2d" id="r_gac72e96d47a54a372ec1d32c59420ba2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac72e96d47a54a372ec1d32c59420ba2d">metta_eq</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *a, const struct <a class="el" href="structmetta__t.html">metta_t</a> *b)</td></tr>
<tr class="memdesc:gac72e96d47a54a372ec1d32c59420ba2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handles to test whether the referenced MeTTa runner is the same.  <br /></td></tr>
<tr class="memitem:ga7adfab973fdd5ca4806fcba1ec049f13" id="r_ga7adfab973fdd5ca4806fcba1ec049f13"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__t.html">space_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7adfab973fdd5ca4806fcba1ec049f13">metta_space</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> *metta)</td></tr>
<tr class="memdesc:ga7adfab973fdd5ca4806fcba1ec049f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the Space of the runner's top-level module.  <br /></td></tr>
<tr class="memitem:ga82e95ca93f0c1bb8b65816d1dbd5974d" id="r_ga82e95ca93f0c1bb8b65816d1dbd5974d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga82e95ca93f0c1bb8b65816d1dbd5974d">metta_tokenizer</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> *metta)</td></tr>
<tr class="memdesc:ga82e95ca93f0c1bb8b65816d1dbd5974d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the Tokenizer of the runner's top-level module.  <br /></td></tr>
<tr class="memitem:ga0fac7779f10dededa29013b902ff7455" id="r_ga0fac7779f10dededa29013b902ff7455"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0fac7779f10dededa29013b902ff7455">metta_working_dir</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:ga0fac7779f10dededa29013b902ff7455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the working directory of the runner's environment into a buffer.  <br /></td></tr>
<tr class="memitem:ga9a5092224ff87fd7de602a2667614c4d" id="r_ga9a5092224ff87fd7de602a2667614c4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9a5092224ff87fd7de602a2667614c4d">metta_run</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> parser, <a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:ga9a5092224ff87fd7de602a2667614c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the MeTTa runner until the input text has been fully parsed and evaluated.  <br /></td></tr>
<tr class="memitem:ga2d304e7181fd9d1fb41b618e7d4e0e38" id="r_ga2d304e7181fd9d1fb41b618e7d4e0e38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2d304e7181fd9d1fb41b618e7d4e0e38">metta_evaluate_atom</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, <a class="el" href="structatom__t.html">atom_t</a> atom, <a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:ga2d304e7181fd9d1fb41b618e7d4e0e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the MeTTa runner to evaluate an input Atom.  <br /></td></tr>
<tr class="memitem:gaa191e65a9443e87f8c81b80136fb6439" id="r_gaa191e65a9443e87f8c81b80136fb6439"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmodule__id__t.html">module_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa191e65a9443e87f8c81b80136fb6439">metta_load_module_direct</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> *metta_ref, const char *name_ref, struct <a class="el" href="structmodule__loader__t.html">module_loader_t</a> *loader_mov)</td></tr>
<tr class="memdesc:gaa191e65a9443e87f8c81b80136fb6439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a module directly into the runner, from a <a class="el" href="structmodule__loader__t.html" title="A C representation of the Rust [ModuleLoader] interface. User can provide [ModuleLoader] methods impl...">module_loader_t</a>.  <br /></td></tr>
<tr class="memitem:ga83161daec4c3c076f2bebaf1b675ceb2" id="r_ga83161daec4c3c076f2bebaf1b675ceb2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmodule__id__t.html">module_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga83161daec4c3c076f2bebaf1b675ceb2">metta_load_module_at_path</a> (struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, const char *path, const char *name)</td></tr>
<tr class="memdesc:ga83161daec4c3c076f2bebaf1b675ceb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a module into the runner from a module resource at a file system path.  <br /></td></tr>
<tr class="memitem:gabf884db2b979249261339770d3de86ff" id="r_gabf884db2b979249261339770d3de86ff"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__t.html">space_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabf884db2b979249261339770d3de86ff">metta_get_module_space</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, struct <a class="el" href="structmodule__id__t.html">module_id_t</a> mod_id)</td></tr>
<tr class="memdesc:gabf884db2b979249261339770d3de86ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Space for a loaded module.  <br /></td></tr>
<tr class="memitem:ga807a3a941df92f54e28ceb245671c4f3" id="r_ga807a3a941df92f54e28ceb245671c4f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga807a3a941df92f54e28ceb245671c4f3">run_context_push_parser</a> (struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context, struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> parser)</td></tr>
<tr class="memdesc:ga807a3a941df92f54e28ceb245671c4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the parser to the Run Context's queue of input to run.  <br /></td></tr>
<tr class="memitem:gafbbe0e25cd3e024eb6fa8cd8f2b2b9e5" id="r_gafbbe0e25cd3e024eb6fa8cd8f2b2b9e5"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structmetta__t.html">metta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafbbe0e25cd3e024eb6fa8cd8f2b2b9e5">run_context_get_metta</a> (const struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context)</td></tr>
<tr class="memdesc:gafbbe0e25cd3e024eb6fa8cd8f2b2b9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> runner that a run context is executing within.  <br /></td></tr>
<tr class="memitem:ga7f5e200571764a8f6b24fdf4a993d40e" id="r_ga7f5e200571764a8f6b24fdf4a993d40e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__t.html">space_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f5e200571764a8f6b24fdf4a993d40e">run_context_get_space</a> (const struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context)</td></tr>
<tr class="memdesc:ga7f5e200571764a8f6b24fdf4a993d40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the Space of the currently running module.  <br /></td></tr>
<tr class="memitem:ga7b0eda1064b72452c001980e172de85a" id="r_ga7b0eda1064b72452c001980e172de85a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7b0eda1064b72452c001980e172de85a">run_context_get_tokenizer</a> (const struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context)</td></tr>
<tr class="memdesc:ga7b0eda1064b72452c001980e172de85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the Tokenizer of the currently running module.  <br /></td></tr>
<tr class="memitem:ga5b7ae412e6cc3f7126b1ec6011ce483e" id="r_ga5b7ae412e6cc3f7126b1ec6011ce483e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5b7ae412e6cc3f7126b1ec6011ce483e">run_context_raise_error</a> (struct <a class="el" href="structrun__context__t.html">run_context_t</a> *run_context, const char *message)</td></tr>
<tr class="memdesc:ga5b7ae412e6cc3f7126b1ec6011ce483e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a runtime error.  <br /></td></tr>
<tr class="memitem:ga573f10ed5f78555dc9ee2edc429bd8f4" id="r_ga573f10ed5f78555dc9ee2edc429bd8f4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrunner__state__t.html">runner_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga573f10ed5f78555dc9ee2edc429bd8f4">runner_state_new_with_parser</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> parser)</td></tr>
<tr class="memdesc:ga573f10ed5f78555dc9ee2edc429bd8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a>, to use for step-wise execution of MeTTa text.  <br /></td></tr>
<tr class="memitem:gad99336318e713daa7ed30ebc56b82762" id="r_gad99336318e713daa7ed30ebc56b82762"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrunner__state__t.html">runner_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad99336318e713daa7ed30ebc56b82762">runner_state_new_with_atoms</a> (const struct <a class="el" href="structmetta__t.html">metta_t</a> *metta, const struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> *atoms)</td></tr>
<tr class="memdesc:gad99336318e713daa7ed30ebc56b82762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a>, to use for step-wise execution of a list of atoms.  <br /></td></tr>
<tr class="memitem:gadf3ade0caafe291b2fb3a5ada6154478" id="r_gadf3ade0caafe291b2fb3a5ada6154478"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadf3ade0caafe291b2fb3a5ada6154478">runner_state_free</a> (struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> state)</td></tr>
<tr class="memdesc:gadf3ade0caafe291b2fb3a5ada6154478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a>.  <br /></td></tr>
<tr class="memitem:ga3018cdbc5d450c8b7bb322c641bd7d87" id="r_ga3018cdbc5d450c8b7bb322c641bd7d87"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3018cdbc5d450c8b7bb322c641bd7d87">runner_state_err_str</a> (const struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *state)</td></tr>
<tr class="memdesc:ga3018cdbc5d450c8b7bb322c641bd7d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error string associated with the last <span class="tt">runner_state_step</span>  <br /></td></tr>
<tr class="memitem:gac5d60583dda4bd7c31a876582c42810e" id="r_gac5d60583dda4bd7c31a876582c42810e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac5d60583dda4bd7c31a876582c42810e">runner_state_step</a> (struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *state)</td></tr>
<tr class="memdesc:gac5d60583dda4bd7c31a876582c42810e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs one step of the runner.  <br /></td></tr>
<tr class="memitem:gabe67b8549e322ba0f36c1ef1133b430f" id="r_gabe67b8549e322ba0f36c1ef1133b430f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabe67b8549e322ba0f36c1ef1133b430f">runner_state_is_complete</a> (const struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *state)</td></tr>
<tr class="memdesc:gabe67b8549e322ba0f36c1ef1133b430f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a> has completed all outstanding work.  <br /></td></tr>
<tr class="memitem:ga039ce982dfdf406bf1b05f8b78ec4b1b" id="r_ga039ce982dfdf406bf1b05f8b78ec4b1b"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga039ce982dfdf406bf1b05f8b78ec4b1b">runner_state_to_str</a> (const struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *state, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:ga039ce982dfdf406bf1b05f8b78ec4b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a text description of a <span class="tt"><a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a></span> into a buffer.  <br /></td></tr>
<tr class="memitem:gae96248f793285f209d526284a382963f" id="r_gae96248f793285f209d526284a382963f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae96248f793285f209d526284a382963f">runner_state_current_results</a> (const struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *state, <a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:gae96248f793285f209d526284a382963f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the current in-flight results in the <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a>.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Top-level API to execute MeTTa code. </p>
<p>This Interface includes the types and functions to instantiate a MeTTa interpreter and step through MeTTa code. </p>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga9ab2f56ef27dd6d3c2279ade44a6a4ba" name="ga9ab2f56ef27dd6d3c2279ade44a6a4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ab2f56ef27dd6d3c2279ade44a6a4ba">&#9670;&#160;</a></span>interpret_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstep__result__t.html">step_result_t</a> interpret_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspace__t.html">space_t</a> *</td>          <td class="paramname"><span class="paramname"><em>space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an interpreter operation and take the initial step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>A pointer to the Space in which to perform the operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expr</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> Expression atom to interpret </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> representing the outcome from the initial step </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned value may represent an error, an immediate result value, or it may be necessary to call <span class="tt"><a class="el" href="#ga46c4f6387eff941a375d75e9fb70104b" title="Takes a subsequent step in an in-flight interpreter operation.">interpret_step()</a></span> in a loop to fully evaluate the execution plan. Ultimately <span class="tt"><a class="el" href="#gadab1c155c75bbc732aa5edc83ac73b79" title="Consumes a step_result_t and provides the ultimate outcome of a MeTTa interpreter session.">step_get_result()</a></span> must be called to release the returned <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> </dd></dl>

</div>
</div>
<a id="ga46c4f6387eff941a375d75e9fb70104b" name="ga46c4f6387eff941a375d75e9fb70104b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46c4f6387eff941a375d75e9fb70104b">&#9670;&#160;</a></span>interpret_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstep__result__t.html">step_result_t</a> interpret_step </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstep__result__t.html">step_result_t</a></td>          <td class="paramname"><span class="paramname"><em>step</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a subsequent step in an in-flight interpreter operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>The existing state for the in-flight interpreter operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> representing the outcome from the step </dd></dl>

</div>
</div>
<a id="ga3f1bc3621331808c16eaa05ad22b1417" name="ga3f1bc3621331808c16eaa05ad22b1417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f1bc3621331808c16eaa05ad22b1417">&#9670;&#160;</a></span>metta_clone_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structmetta__t.html">metta_t</a> metta_clone_handle </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>metta</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones a <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta</td><td>The handle to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly cloned <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handle, pointing to the same underlying runner </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span>, and free it with <span class="tt"><a class="el" href="#ga0db9c5ab905ebe5285ff2418779b5dee" title="Frees a metta_t handle.">metta_free()</a></span> </dd></dl>

</div>
</div>
<a id="gac72e96d47a54a372ec1d32c59420ba2d" name="gac72e96d47a54a372ec1d32c59420ba2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac72e96d47a54a372ec1d32c59420ba2d">&#9670;&#160;</a></span>metta_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool metta_eq </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handles to test whether the referenced MeTTa runner is the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A pointer to the first runner handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A pointer to the first runner handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two handles reference the same runner, otherwise False </dd></dl>

</div>
</div>
<a id="gafdfc4efb62fd521a004958ddd55702ea" name="gafdfc4efb62fd521a004958ddd55702ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdfc4efb62fd521a004958ddd55702ea">&#9670;&#160;</a></span>metta_err_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * metta_err_str </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>metta</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the error string associated with the last <span class="tt">metta_run</span>, <span class="tt">metta_evaluate_atom</span>, or <span class="tt">metta_load_module</span> call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta</td><td>A pointer to the MeTTa handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the C-string containing the error that occurred, or NULL if no error occurred </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned pointer should NOT be freed. It must never be accessed after the <a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a> has been freed, or any subsequent call to <span class="tt">metta_run</span>, <span class="tt">metta_evaluate_atom</span>, or <span class="tt">metta_load_module</span> has been made. </dd></dl>

</div>
</div>
<a id="ga2d304e7181fd9d1fb41b618e7d4e0e38" name="ga2d304e7181fd9d1fb41b618e7d4e0e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d304e7181fd9d1fb41b618e7d4e0e38">&#9670;&#160;</a></span>metta_evaluate_atom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void metta_evaluate_atom </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>metta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structatom__t.html">atom_t</a></td>          <td class="paramname"><span class="paramname"><em>atom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the MeTTa runner to evaluate an input Atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta</td><td>A pointer to the runner handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>The <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> representing the atom to evaluate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A function that will be called to provide a vector of atoms produced by the evaluation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A pointer to a caller-defined structure to facilitate communication with the <span class="tt">callback</span> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If this function encounters an error, the callback will not be called and the error may be accessed with <span class="tt"><a class="el" href="#gafdfc4efb62fd521a004958ddd55702ea" title="Returns the error string associated with the last metta_run, metta_evaluate_atom, or metta_load_modul...">metta_err_str()</a></span> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function takes ownership of the provided <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span>, so it must not be subsequently accessed or freed </dd></dl>

</div>
</div>
<a id="ga0db9c5ab905ebe5285ff2418779b5dee" name="ga0db9c5ab905ebe5285ff2418779b5dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0db9c5ab905ebe5285ff2418779b5dee">&#9670;&#160;</a></span>metta_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void metta_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmetta__t.html">metta_t</a></td>          <td class="paramname"><span class="paramname"><em>metta</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta</td><td>The handle to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The underlying runner may be deallocated if all handles that refer to it have been freed, otherwise the runner itself won't be freed </dd></dl>

</div>
</div>
<a id="gabf884db2b979249261339770d3de86ff" name="gabf884db2b979249261339770d3de86ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf884db2b979249261339770d3de86ff">&#9670;&#160;</a></span>metta_get_module_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspace__t.html">space_t</a> metta_get_module_space </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>metta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structmodule__id__t.html">module_id_t</a></td>          <td class="paramname"><span class="paramname"><em>mod_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Space for a loaded module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta</td><td>A pointer to the handle specifying the runner into which to load the module </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod_id</td><td>The <span class="tt"><a class="el" href="structmodule__id__t.html" title="Identifies a loaded module inside a specific metta_t MeTTa runner.">module_id_t</a></span> of the loaded module to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <span class="tt"><a class="el" href="structspace__t.html" title="A Space handle, providing access to a Space in which atoms may exist in relation to other atoms.">space_t</a></span> for the module's Space </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned <span class="tt"><a class="el" href="structspace__t.html" title="A Space handle, providing access to a Space in which atoms may exist in relation to other atoms.">space_t</a></span> must be freed with <span class="tt">space_free</span> </dd></dl>

</div>
</div>
<a id="ga83161daec4c3c076f2bebaf1b675ceb2" name="ga83161daec4c3c076f2bebaf1b675ceb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83161daec4c3c076f2bebaf1b675ceb2">&#9670;&#160;</a></span>metta_load_module_at_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structmodule__id__t.html">module_id_t</a> metta_load_module_at_path </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>metta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a module into the runner from a module resource at a file system path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta</td><td>A pointer to the handle specifying the runner into which to load the module </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>A C-string specifying the path from which to load the module </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A C-string specifying a name for the module, or NULL if you want the module to be private and unable to be loaded by name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <span class="tt"><a class="el" href="structmodule__id__t.html" title="Identifies a loaded module inside a specific metta_t MeTTa runner.">module_id_t</a></span> for the loaded module, or <span class="tt">invalid</span> if there was an error </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function effectively bypasses the catalog, for situations where you wish to load a specific module from disk </dd>
<dd>
If this function encounters an error, the error may be accessed with <span class="tt"><a class="el" href="#gafdfc4efb62fd521a004958ddd55702ea" title="Returns the error string associated with the last metta_run, metta_evaluate_atom, or metta_load_modul...">metta_err_str()</a></span> </dd></dl>

</div>
</div>
<a id="gaa191e65a9443e87f8c81b80136fb6439" name="gaa191e65a9443e87f8c81b80136fb6439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa191e65a9443e87f8c81b80136fb6439">&#9670;&#160;</a></span>metta_load_module_direct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structmodule__id__t.html">module_id_t</a> metta_load_module_direct </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>metta_ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name_ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structmodule__loader__t.html">module_loader_t</a> *</td>          <td class="paramname"><span class="paramname"><em>loader_mov</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a module directly into the runner, from a <a class="el" href="structmodule__loader__t.html" title="A C representation of the Rust [ModuleLoader] interface. User can provide [ModuleLoader] methods impl...">module_loader_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta_ref</td><td>A pointer to the handle specifying the runner into which to load the module </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name_ref</td><td>A C-string specifying a name for the module </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loader_mov</td><td>The <span class="tt"><a class="el" href="structmodule__loader__t.html" title="A C representation of the Rust [ModuleLoader] interface. User can provide [ModuleLoader] methods impl...">module_loader_t</a></span> instance to load the module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <span class="tt"><a class="el" href="structmodule__id__t.html" title="Identifies a loaded module inside a specific metta_t MeTTa runner.">module_id_t</a></span> for the loaded module, or <span class="tt">invalid</span> if there was an error </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function might be useful to provide MeTTa modules that are built-in as part of your application </dd>
<dd>
If this function encounters an error, the error may be accessed with <span class="tt"><a class="el" href="#gafdfc4efb62fd521a004958ddd55702ea" title="Returns the error string associated with the last metta_run, metta_evaluate_atom, or metta_load_modul...">metta_err_str()</a></span> </dd></dl>

</div>
</div>
<a id="ga0fae150c70a9749a63d02af3dec13dcf" name="ga0fae150c70a9749a63d02af3dec13dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fae150c70a9749a63d02af3dec13dcf">&#9670;&#160;</a></span>metta_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structmetta__t.html">metta_t</a> metta_new </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new top-level MeTTa Runner, with only the Rust stdlib loaded. </p>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handle to the newly created runner </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span>, and free it with <span class="tt"><a class="el" href="#ga0db9c5ab905ebe5285ff2418779b5dee" title="Frees a metta_t handle.">metta_free()</a></span> </dd></dl>

</div>
</div>
<a id="ga9bd33f0ebf40f201c1378534f49d0eaf" name="ga9bd33f0ebf40f201c1378534f49d0eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bd33f0ebf40f201c1378534f49d0eaf">&#9670;&#160;</a></span>metta_new_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structmetta__t.html">metta_t</a> metta_new_core </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspace__t.html">space_t</a> *</td>          <td class="paramname"><span class="paramname"><em>space</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structenv__builder__t.html">env_builder_t</a></td>          <td class="paramname"><span class="paramname"><em>env_builder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new core MeTTa runner, with no loaded stdlib nor initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>A pointer to a handle for the Space for use as the space of the top-level module </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">environment</td><td>An <span class="tt"><a class="el" href="structenv__builder__t.html" title="Represents an environment initialization, in progress.">env_builder_t</a></span> handle to configure the environment to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handle to the newly created runner </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span>, and free it with <span class="tt"><a class="el" href="#ga0db9c5ab905ebe5285ff2418779b5dee" title="Frees a metta_t handle.">metta_free()</a></span> </dd>
<dd>
This function does not load any stdlib, nor does it run the <span class="tt">init.metta</span> file from the environment </dd></dl>

</div>
</div>
<a id="ga40bfcb434d9cf2fe79ceb84625894c6d" name="ga40bfcb434d9cf2fe79ceb84625894c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40bfcb434d9cf2fe79ceb84625894c6d">&#9670;&#160;</a></span>metta_new_with_stdlib_loader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structmetta__t.html">metta_t</a> metta_new_with_stdlib_loader </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmodule__loader__t.html">module_loader_t</a> *</td>          <td class="paramname"><span class="paramname"><em>stdlib_loader_mov</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspace__t.html">space_t</a> *</td>          <td class="paramname"><span class="paramname"><em>space_ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structenv__builder__t.html">env_builder_t</a></td>          <td class="paramname"><span class="paramname"><em>env_builder_mov</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new top-level MeTTa Runner, with the specified <span class="tt">stdlib</span> module loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">space_ref</td><td>A pointer to a handle for the Space for use in the Runner's top-level module </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">env_builder_mov</td><td>An <span class="tt"><a class="el" href="structenv__builder__t.html" title="Represents an environment initialization, in progress.">env_builder_t</a></span> handle to configure the environment to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stdlib_loader_mov</td><td>Stdlib loader implemented in C code. Pass NULL to use the default <span class="tt">stdlib</span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handle to the newly created Runner </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span>, and free it with <span class="tt"><a class="el" href="#ga0db9c5ab905ebe5285ff2418779b5dee" title="Frees a metta_t handle.">metta_free()</a></span> </dd>
<dd>
Most callers can simply call <span class="tt">metta_new</span>. This function is provided to support languages with their own stdlib, that needs to be loaded before the init.metta file is run </dd></dl>

</div>
</div>
<a id="ga9a5092224ff87fd7de602a2667614c4d" name="ga9a5092224ff87fd7de602a2667614c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a5092224ff87fd7de602a2667614c4d">&#9670;&#160;</a></span>metta_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void metta_run </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>metta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a></td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the MeTTa runner until the input text has been fully parsed and evaluated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta</td><td>A pointer to the runner handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>An S-Expression Parser containing the MeTTa text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A function that will be called to provide a vector of atoms produced by the evaluation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A pointer to a caller-defined structure to facilitate communication with the <span class="tt">callback</span> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If this function encounters an error, the callback will not be called and the error may be accessed with <span class="tt"><a class="el" href="#gafdfc4efb62fd521a004958ddd55702ea" title="Returns the error string associated with the last metta_run, metta_evaluate_atom, or metta_load_modul...">metta_err_str()</a></span> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Ownership of the provided parser will be taken by this function, so it must not be subsequently accessed nor freed. </dd></dl>

</div>
</div>
<a id="ga7adfab973fdd5ca4806fcba1ec049f13" name="ga7adfab973fdd5ca4806fcba1ec049f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7adfab973fdd5ca4806fcba1ec049f13">&#9670;&#160;</a></span>metta_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspace__t.html">space_t</a> metta_space </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>metta</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the Space of the runner's top-level module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta</td><td>A pointer to the runner handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Space handle, to access the Space of the runner's top-level module </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structspace__t.html" title="A Space handle, providing access to a Space in which atoms may exist in relation to other atoms.">space_t</a></span> and free it with <span class="tt"><a class="el" href="group__space__client__group.html#ga0cc53ed059ecda436d1b973445135a64" title="Frees a space_t handle.">space_free()</a></span> </dd></dl>

</div>
</div>
<a id="ga82e95ca93f0c1bb8b65816d1dbd5974d" name="ga82e95ca93f0c1bb8b65816d1dbd5974d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82e95ca93f0c1bb8b65816d1dbd5974d">&#9670;&#160;</a></span>metta_tokenizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> metta_tokenizer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>metta</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the Tokenizer of the runner's top-level module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta</td><td>A pointer to the runner handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tokenizer handle, to access the Tokenizer of the runner's top-level module </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structtokenizer__t.html" title="Represents a handle to a Tokenizer, capable of recognizing meaningful Token substrings in text.">tokenizer_t</a></span> and free it with <span class="tt"><a class="el" href="group__tokenizer__and__parser__group.html#gad406ea7b7a462ebb00ced9d9052607d5" title="Frees a Tokenizer handle.">tokenizer_free()</a></span> </dd></dl>

</div>
</div>
<a id="ga0fac7779f10dededa29013b902ff7455" name="ga0fac7779f10dededa29013b902ff7455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fac7779f10dededa29013b902ff7455">&#9670;&#160;</a></span>metta_working_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t metta_working_dir </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>metta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t</td>          <td class="paramname"><span class="paramname"><em>buf_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders the working directory of the runner's environment into a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta</td><td>A pointer to the runner handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A buffer into which the path will be rendered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>The maximum allocated size of <span class="tt">buf</span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the path string, minus the string terminator character. Returns 0 if the runner's environment has no working directory. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">return_value &gt; buf_len + 1</span>, then the text was not fully rendered and this function should be called again with a larger buffer. </dd></dl>

</div>
</div>
<a id="gafbbe0e25cd3e024eb6fa8cd8f2b2b9e5" name="gafbbe0e25cd3e024eb6fa8cd8f2b2b9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbbe0e25cd3e024eb6fa8cd8f2b2b9e5">&#9670;&#160;</a></span>run_context_get_metta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structmetta__t.html">metta_t</a> run_context_get_metta </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrun__context__t.html">run_context_t</a> *</td>          <td class="paramname"><span class="paramname"><em>run_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> runner that a run context is executing within. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">run_context</td><td>A pointer to the <span class="tt"><a class="el" href="structrun__context__t.html" title="An interface object providing access to the MeTTa run interface.">run_context_t</a></span> to access the runner API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handle to access the runner </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned <span class="tt"><a class="el" href="structmetta__t.html" title="A top-level MeTTa runner.">metta_t</a></span> handle is must be freed using <span class="tt">metta_free</span> </dd></dl>

</div>
</div>
<a id="ga7f5e200571764a8f6b24fdf4a993d40e" name="ga7f5e200571764a8f6b24fdf4a993d40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f5e200571764a8f6b24fdf4a993d40e">&#9670;&#160;</a></span>run_context_get_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspace__t.html">space_t</a> run_context_get_space </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrun__context__t.html">run_context_t</a> *</td>          <td class="paramname"><span class="paramname"><em>run_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the Space of the currently running module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">run_context</td><td>A pointer to the <span class="tt"><a class="el" href="structrun__context__t.html" title="An interface object providing access to the MeTTa run interface.">run_context_t</a></span> to access the runner API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Space handle, to access the Space of the currently running module </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structspace__t.html" title="A Space handle, providing access to a Space in which atoms may exist in relation to other atoms.">space_t</a></span> and free it with <span class="tt"><a class="el" href="group__space__client__group.html#ga0cc53ed059ecda436d1b973445135a64" title="Frees a space_t handle.">space_free()</a></span> </dd></dl>

</div>
</div>
<a id="ga7b0eda1064b72452c001980e172de85a" name="ga7b0eda1064b72452c001980e172de85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b0eda1064b72452c001980e172de85a">&#9670;&#160;</a></span>run_context_get_tokenizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> run_context_get_tokenizer </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrun__context__t.html">run_context_t</a> *</td>          <td class="paramname"><span class="paramname"><em>run_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the Tokenizer of the currently running module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">run_context</td><td>A pointer to the <span class="tt"><a class="el" href="structrun__context__t.html" title="An interface object providing access to the MeTTa run interface.">run_context_t</a></span> to access the runner API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tokenizer handle, to access the Tokenizer of the currently running module </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structtokenizer__t.html" title="Represents a handle to a Tokenizer, capable of recognizing meaningful Token substrings in text.">tokenizer_t</a></span> and free it with <span class="tt"><a class="el" href="group__tokenizer__and__parser__group.html#gad406ea7b7a462ebb00ced9d9052607d5" title="Frees a Tokenizer handle.">tokenizer_free()</a></span> </dd></dl>

</div>
</div>
<a id="ga807a3a941df92f54e28ceb245671c4f3" name="ga807a3a941df92f54e28ceb245671c4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga807a3a941df92f54e28ceb245671c4f3">&#9670;&#160;</a></span>run_context_push_parser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run_context_push_parser </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrun__context__t.html">run_context_t</a> *</td>          <td class="paramname"><span class="paramname"><em>run_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a></td>          <td class="paramname"><span class="paramname"><em>parser</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the parser to the Run Context's queue of input to run. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">run_context</td><td>A pointer to the <span class="tt"><a class="el" href="structrun__context__t.html" title="An interface object providing access to the MeTTa run interface.">run_context_t</a></span> to access the runner API </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>An S-Expression Parser containing the MeTTa source code to execute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b7ae412e6cc3f7126b1ec6011ce483e" name="ga5b7ae412e6cc3f7126b1ec6011ce483e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b7ae412e6cc3f7126b1ec6011ce483e">&#9670;&#160;</a></span>run_context_raise_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run_context_raise_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrun__context__t.html">run_context_t</a> *</td>          <td class="paramname"><span class="paramname"><em>run_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a runtime error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">run_context</td><td>A pointer to the <span class="tt"><a class="el" href="structrun__context__t.html" title="An interface object providing access to the MeTTa run interface.">run_context_t</a></span> to access the runner API </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>A C-string specifying an error message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Raising an error through this function will cause the MeTTa interpreter to take an error pathway </dd></dl>

</div>
</div>
<a id="gae96248f793285f209d526284a382963f" name="gae96248f793285f209d526284a382963f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae96248f793285f209d526284a382963f">&#9670;&#160;</a></span>runner_state_current_results()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void runner_state_current_results </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the current in-flight results in the <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The <span class="tt"><a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a></span> within which to preview results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A function that will be called to provide a vector of atoms produced by the evaluation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A pointer to a caller-defined structure to facilitate communication with the <span class="tt">callback</span> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The provided results will be overwritten by the next call to <span class="tt">metta_run_step</span>, so the caller must clone the result atoms if they are needed for an extended period of time </dd></dl>

</div>
</div>
<a id="ga3018cdbc5d450c8b7bb322c641bd7d87" name="ga3018cdbc5d450c8b7bb322c641bd7d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3018cdbc5d450c8b7bb322c641bd7d87">&#9670;&#160;</a></span>runner_state_err_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * runner_state_err_str </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the error string associated with the last <span class="tt">runner_state_step</span> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A pointer to the runner state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the C-string containing the error that occurred, or NULL if no error occurred </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned pointer should NOT be freed. It must never be accessed after the <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a> has been freed, or any subsequent call to <span class="tt">runner_state_step</span> has been made. </dd></dl>

</div>
</div>
<a id="gadf3ade0caafe291b2fb3a5ada6154478" name="gadf3ade0caafe291b2fb3a5ada6154478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf3ade0caafe291b2fb3a5ada6154478">&#9670;&#160;</a></span>runner_state_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void runner_state_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrunner__state__t.html">runner_state_t</a></td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The <span class="tt"><a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a></span> to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe67b8549e322ba0f36c1ef1133b430f" name="gabe67b8549e322ba0f36c1ef1133b430f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe67b8549e322ba0f36c1ef1133b430f">&#9670;&#160;</a></span>runner_state_is_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool runner_state_is_complete </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not the <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a> has completed all outstanding work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The <span class="tt"><a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a></span> to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the runner has already concluded, or <span class="tt">false</span> if there is more work to do </dd></dl>

</div>
</div>
<a id="gad99336318e713daa7ed30ebc56b82762" name="gad99336318e713daa7ed30ebc56b82762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad99336318e713daa7ed30ebc56b82762">&#9670;&#160;</a></span>runner_state_new_with_atoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> runner_state_new_with_atoms </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>metta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atoms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a>, to use for step-wise execution of a list of atoms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta</td><td>A pointer to the runner handle in which to perform the run </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atoms</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__vec__t.html" title="Contains a vector (list) of Atoms.">atom_vec_t</a></span> containing the atoms to run </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <span class="tt"><a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a></span>, which can begin evaluating MeTTa code </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The referenced <span class="tt">atoms</span> <span class="tt"><a class="el" href="structatom__vec__t.html" title="Contains a vector (list) of Atoms.">atom_vec_t</a></span> must not be modified nor freed while the <span class="tt"><a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a></span> remains active </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned <span class="tt"><a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a></span> handle must be freed with <span class="tt"><a class="el" href="#gadf3ade0caafe291b2fb3a5ada6154478" title="Frees a runner_state_t.">runner_state_free()</a></span> </dd></dl>

</div>
</div>
<a id="ga573f10ed5f78555dc9ee2edc429bd8f4" name="ga573f10ed5f78555dc9ee2edc429bd8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga573f10ed5f78555dc9ee2edc429bd8f4">&#9670;&#160;</a></span>runner_state_new_with_parser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> runner_state_new_with_parser </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmetta__t.html">metta_t</a> *</td>          <td class="paramname"><span class="paramname"><em>metta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a></td>          <td class="paramname"><span class="paramname"><em>parser</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a>, to use for step-wise execution of MeTTa text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metta</td><td>A pointer to the runner handle in which to perform the run </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>An S-Expression Parser containing the MeTTa text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <span class="tt"><a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a></span>, which can begin evaluating MeTTa code </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Ownership of the provided parser will be taken by this function, so it must not be subsequently accessed nor freed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned <span class="tt"><a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a></span> handle must be freed with <span class="tt"><a class="el" href="#gadf3ade0caafe291b2fb3a5ada6154478" title="Frees a runner_state_t.">runner_state_free()</a></span> </dd></dl>

</div>
</div>
<a id="gac5d60583dda4bd7c31a876582c42810e" name="gac5d60583dda4bd7c31a876582c42810e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d60583dda4bd7c31a876582c42810e">&#9670;&#160;</a></span>runner_state_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void runner_state_step </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs one step of the runner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A pointer to the in-flight runner state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If this function encounters an error, the error may be accessed with <span class="tt"><a class="el" href="#ga3018cdbc5d450c8b7bb322c641bd7d87" title="Returns the error string associated with the last runner_state_step">runner_state_err_str()</a></span> </dd></dl>

</div>
</div>
<a id="ga039ce982dfdf406bf1b05f8b78ec4b1b" name="ga039ce982dfdf406bf1b05f8b78ec4b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga039ce982dfdf406bf1b05f8b78ec4b1b">&#9670;&#160;</a></span>runner_state_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t runner_state_to_str </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrunner__state__t.html">runner_state_t</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t</td>          <td class="paramname"><span class="paramname"><em>buf_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a text description of a <span class="tt"><a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a></span> into a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A pointer to a <span class="tt"><a class="el" href="structrunner__state__t.html" title="Represents the state of an in-flight MeTTa execution run.">runner_state_t</a></span> to render </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A buffer into which the text will be rendered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>The maximum allocated size of <span class="tt">buf</span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the description string, minus the string terminator character. If <span class="tt">return_value &gt; buf_len + 1</span>, then the text was not fully rendered and this function should be called again with a larger buffer. </dd></dl>

</div>
</div>
<a id="gadab1c155c75bbc732aa5edc83ac73b79" name="gadab1c155c75bbc732aa5edc83ac73b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadab1c155c75bbc732aa5edc83ac73b79">&#9670;&#160;</a></span>step_get_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void step_get_result </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstep__result__t.html">step_result_t</a></td>          <td class="paramname"><span class="paramname"><em>step</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumes a <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> and provides the ultimate outcome of a MeTTa interpreter session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>A pointer to a <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> to render </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A function that will be called to provide a vector of all atoms resulting from the interpreter session </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A pointer to a caller-defined structure to facilitate communication with the <span class="tt">callback</span> function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63b1315f944f3c4faa72dfe899526723" name="ga63b1315f944f3c4faa72dfe899526723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63b1315f944f3c4faa72dfe899526723">&#9670;&#160;</a></span>step_has_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool step_has_next </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstep__result__t.html">step_result_t</a> *</td>          <td class="paramname"><span class="paramname"><em>step</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Examines a <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> to determine if more work is needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>A pointer to the <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> representing the in-flight interpreter operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the operation plan indicates that more work is needed to finalize results, otherwise <span class="tt">false</span> </dd></dl>

</div>
</div>
<a id="ga7b4fd14aa654366f9c922e0b55bfaf6c" name="ga7b4fd14aa654366f9c922e0b55bfaf6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b4fd14aa654366f9c922e0b55bfaf6c">&#9670;&#160;</a></span>step_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t step_to_str </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstep__result__t.html">step_result_t</a> *</td>          <td class="paramname"><span class="paramname"><em>step</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t</td>          <td class="paramname"><span class="paramname"><em>buf_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a text description of a <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> into a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>A pointer to a <span class="tt"><a class="el" href="structstep__result__t.html" title="Contains the state for an in-flight interpreter operation.">step_result_t</a></span> to render </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A buffer into which the text will be rendered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>The maximum allocated size of <span class="tt">buf</span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the description string, minus the string terminator character. If <span class="tt">return_value &gt; buf_len + 1</span>, then the text was not fully rendered and this function should be called again with a larger buffer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
