<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hyperon C: Tokenizer and Parser Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hyperon C
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Tokenizer and Parser Interface </div></div>
</div><!--header-->
<div class="contents">

<p>API to parse the MeTTa language from text into Atoms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:tokenizer_5Ft" id="r_tokenizer_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtokenizer__t.html">tokenizer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a handle to a Tokenizer, capable of recognizing meaningful Token substrings in text.  <a href="structtokenizer__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:sexpr_5Fparser_5Ft" id="r_sexpr_5Fparser_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an S-Expression Parser state machine, to parse input text into an Atom.  <a href="structsexpr__parser__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:syntax_5Fnode_5Ft" id="r_syntax_5Fnode_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyntax__node__t.html">syntax_node_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a component in a syntax tree created by parsing MeTTa code.  <a href="structsyntax__node__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:token_5Fapi_5Ft" id="r_token_5Fapi_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtoken__api__t.html">token_api_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table of callback functions to implement custom atom parsing.  <a href="structtoken__api__t.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac384a0391a5289fce4e892c3c1a066c3" id="r_gac384a0391a5289fce4e892c3c1a066c3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac384a0391a5289fce4e892c3c1a066c3">c_syntax_node_callback_t</a>) (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node, void *context)</td></tr>
<tr class="memdesc:gac384a0391a5289fce4e892c3c1a066c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature for a callback providing access to a <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span>  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa712c20d55774112ce9f3890d752a004" id="r_gaa712c20d55774112ce9f3890d752a004"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa712c20d55774112ce9f3890d752a004">syntax_node_type_t</a> { <br />
&#160;&#160;<a class="el" href="#ggaa712c20d55774112ce9f3890d752a004aae696377c19e507b64e16be78ce3bbdb">COMMENT</a>
, <a class="el" href="#ggaa712c20d55774112ce9f3890d752a004a3ce0ede9808c443a2e15006f01fb91d7">VARIABLE_TOKEN</a>
, <a class="el" href="#ggaa712c20d55774112ce9f3890d752a004a67fc1734265f2e84177a9bc259f1b187">STRING_TOKEN</a>
, <a class="el" href="#ggaa712c20d55774112ce9f3890d752a004a1d32fc48eff72113cf76816bf6222739">WORD_TOKEN</a>
, <br />
&#160;&#160;<a class="el" href="#ggaa712c20d55774112ce9f3890d752a004af0b0ce2414f256bad9da221d2532147d">OPEN_PAREN</a>
, <a class="el" href="#ggaa712c20d55774112ce9f3890d752a004a7093c88a2f741fb4dae5c36809a1958f">CLOSE_PAREN</a>
, <a class="el" href="#ggaa712c20d55774112ce9f3890d752a004aba113c37f25d24aada154b75c7dd91ba">WHITESPACE</a>
, <a class="el" href="#ggaa712c20d55774112ce9f3890d752a004a529e12725494ed531cceae5c7cf67207">LEFTOVER_TEXT</a>
, <br />
&#160;&#160;<a class="el" href="#ggaa712c20d55774112ce9f3890d752a004a86e85aeda2fee48d0fb55ddfb18093f8">EXPRESSION_GROUP</a>
, <a class="el" href="#ggaa712c20d55774112ce9f3890d752a004a0f0ed217e6e29f661e404c05543fda61">ERROR_GROUP</a>
<br />
 }</td></tr>
<tr class="memdesc:gaa712c20d55774112ce9f3890d752a004"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of language construct respresented by a <a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a>.  <a href="#gaa712c20d55774112ce9f3890d752a004">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad8614b89e31ed717a51f1055c436744f" id="r_gad8614b89e31ed717a51f1055c436744f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad8614b89e31ed717a51f1055c436744f">tokenizer_new</a> (void)</td></tr>
<tr class="memdesc:gad8614b89e31ed717a51f1055c436744f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Tokenizer, without any registered Tokens.  <br /></td></tr>
<tr class="memitem:gad406ea7b7a462ebb00ced9d9052607d5" id="r_gad406ea7b7a462ebb00ced9d9052607d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad406ea7b7a462ebb00ced9d9052607d5">tokenizer_free</a> (struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> tokenizer)</td></tr>
<tr class="memdesc:gad406ea7b7a462ebb00ced9d9052607d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a Tokenizer handle.  <br /></td></tr>
<tr class="memitem:gaead24238f59d2df002061961866bb6ed" id="r_gaead24238f59d2df002061961866bb6ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaead24238f59d2df002061961866bb6ed">tokenizer_register_token</a> (struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> *tokenizer, const char *regex, const struct <a class="el" href="structtoken__api__t.html">token_api_t</a> *api, void *context)</td></tr>
<tr class="memdesc:gaead24238f59d2df002061961866bb6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new custom Token in a Tokenizer.  <br /></td></tr>
<tr class="memitem:ga56d5697609f691fca9647881fea9112a" id="r_ga56d5697609f691fca9647881fea9112a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga56d5697609f691fca9647881fea9112a">tokenizer_clone</a> (const struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> *tokenizer)</td></tr>
<tr class="memdesc:ga56d5697609f691fca9647881fea9112a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a "deep copy" of a Tokenizer.  <br /></td></tr>
<tr class="memitem:gadd26925a0c7e8ce118c9c4f0bf48f21c" id="r_gadd26925a0c7e8ce118c9c4f0bf48f21c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadd26925a0c7e8ce118c9c4f0bf48f21c">sexpr_parser_new</a> (const char *text)</td></tr>
<tr class="memdesc:gadd26925a0c7e8ce118c9c4f0bf48f21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new S-Expression Parser.  <br /></td></tr>
<tr class="memitem:ga1a64ae026a50cbf1bca6d7c222cea19c" id="r_ga1a64ae026a50cbf1bca6d7c222cea19c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1a64ae026a50cbf1bca6d7c222cea19c">sexpr_parser_free</a> (struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> parser)</td></tr>
<tr class="memdesc:ga1a64ae026a50cbf1bca6d7c222cea19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an S-Expression Parser.  <br /></td></tr>
<tr class="memitem:gaaf9c0c5587ad4fa324c7dd2f744031fa" id="r_gaaf9c0c5587ad4fa324c7dd2f744031fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaf9c0c5587ad4fa324c7dd2f744031fa">sexpr_parser_parse</a> (struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> *parser, const struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> *tokenizer)</td></tr>
<tr class="memdesc:gaaf9c0c5587ad4fa324c7dd2f744031fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the text associated with an <span class="tt"><a class="el" href="structsexpr__parser__t.html" title="Represents an S-Expression Parser state machine, to parse input text into an Atom.">sexpr_parser_t</a></span>, and creates the corresponding Atom.  <br /></td></tr>
<tr class="memitem:ga30dd580bc479b4115c44e3158719d746" id="r_ga30dd580bc479b4115c44e3158719d746"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga30dd580bc479b4115c44e3158719d746">sexpr_parser_err_str</a> (const struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> *parser)</td></tr>
<tr class="memdesc:ga30dd580bc479b4115c44e3158719d746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error string associated with the last <span class="tt">sexpr_parser_parse</span> call.  <br /></td></tr>
<tr class="memitem:ga8bd019b50118713e56eb22c460520d94" id="r_ga8bd019b50118713e56eb22c460520d94"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8bd019b50118713e56eb22c460520d94">sexpr_parser_parse_to_syntax_tree</a> (struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> *parser)</td></tr>
<tr class="memdesc:ga8bd019b50118713e56eb22c460520d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the text associated with an <span class="tt"><a class="el" href="structsexpr__parser__t.html" title="Represents an S-Expression Parser state machine, to parse input text into an Atom.">sexpr_parser_t</a></span>, and creates a syntax tree.  <br /></td></tr>
<tr class="memitem:gabf7e8877026914bcbcfe4828e207ce74" id="r_gabf7e8877026914bcbcfe4828e207ce74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabf7e8877026914bcbcfe4828e207ce74">syntax_node_free</a> (struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> node)</td></tr>
<tr class="memdesc:gabf7e8877026914bcbcfe4828e207ce74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a>.  <br /></td></tr>
<tr class="memitem:ga2848d589e097d56d39fd5ca160daaf9b" id="r_ga2848d589e097d56d39fd5ca160daaf9b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2848d589e097d56d39fd5ca160daaf9b">syntax_node_clone</a> (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node)</td></tr>
<tr class="memdesc:ga2848d589e097d56d39fd5ca160daaf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of a <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span>  <br /></td></tr>
<tr class="memitem:ga0161a7f0efb123c485646516bf8b1c52" id="r_ga0161a7f0efb123c485646516bf8b1c52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0161a7f0efb123c485646516bf8b1c52">syntax_node_iterate</a> (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node, <a class="el" href="#gac384a0391a5289fce4e892c3c1a066c3">c_syntax_node_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:ga0161a7f0efb123c485646516bf8b1c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a depth-first iteration of all child syntax nodes within a syntax tree.  <br /></td></tr>
<tr class="memitem:ga8a87568403de72d2607c0e6bd08410ff" id="r_ga8a87568403de72d2607c0e6bd08410ff"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="#gaa712c20d55774112ce9f3890d752a004">syntax_node_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8a87568403de72d2607c0e6bd08410ff">syntax_node_type</a> (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node)</td></tr>
<tr class="memdesc:ga8a87568403de72d2607c0e6bd08410ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of a <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span>  <br /></td></tr>
<tr class="memitem:gac27310c183211f17a923c46befb31f1d" id="r_gac27310c183211f17a923c46befb31f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac27310c183211f17a923c46befb31f1d">syntax_node_is_null</a> (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node)</td></tr>
<tr class="memdesc:gac27310c183211f17a923c46befb31f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if a syntax node represents the end of the stream.  <br /></td></tr>
<tr class="memitem:ga2f904f0820cf14f8e94e31c72480ae03" id="r_ga2f904f0820cf14f8e94e31c72480ae03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2f904f0820cf14f8e94e31c72480ae03">syntax_node_is_leaf</a> (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node)</td></tr>
<tr class="memdesc:ga2f904f0820cf14f8e94e31c72480ae03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if a syntax node is a leaf (has no children) and <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:ga9682eedb0f5bfd0d43c9af3e3a1b2bb9" id="r_ga9682eedb0f5bfd0d43c9af3e3a1b2bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9682eedb0f5bfd0d43c9af3e3a1b2bb9">syntax_node_src_range</a> (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node, uintptr_t *range_start, uintptr_t *range_end)</td></tr>
<tr class="memdesc:ga9682eedb0f5bfd0d43c9af3e3a1b2bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beginning and end positions in the parsed source of the text represented by the syntax node.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>API to parse the MeTTa language from text into Atoms. </p>
<p>This interface facilitates parsing textual representations of MeTTa into atom representations, and can be extended to parse custom atom types with specialized syntax. </p>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="gac384a0391a5289fce4e892c3c1a066c3" name="gac384a0391a5289fce4e892c3c1a066c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac384a0391a5289fce4e892c3c1a066c3">&#9670;&#160;</a></span>c_syntax_node_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* c_syntax_node_callback_t) (const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *node, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function signature for a callback providing access to a <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> being provided. This node should not be modified or freed by the callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context state pointer initially passed to the upstream function initiating the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa712c20d55774112ce9f3890d752a004" name="gaa712c20d55774112ce9f3890d752a004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa712c20d55774112ce9f3890d752a004">&#9670;&#160;</a></span>syntax_node_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gaa712c20d55774112ce9f3890d752a004">syntax_node_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of language construct respresented by a <a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa712c20d55774112ce9f3890d752a004aae696377c19e507b64e16be78ce3bbdb" name="ggaa712c20d55774112ce9f3890d752a004aae696377c19e507b64e16be78ce3bbdb"></a>COMMENT&#160;</td><td class="fielddoc"><p>A Comment, beginning with a ';' character. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa712c20d55774112ce9f3890d752a004a3ce0ede9808c443a2e15006f01fb91d7" name="ggaa712c20d55774112ce9f3890d752a004a3ce0ede9808c443a2e15006f01fb91d7"></a>VARIABLE_TOKEN&#160;</td><td class="fielddoc"><p>A variable. A symbol immediately preceded by a '$' sigil. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa712c20d55774112ce9f3890d752a004a67fc1734265f2e84177a9bc259f1b187" name="ggaa712c20d55774112ce9f3890d752a004a67fc1734265f2e84177a9bc259f1b187"></a>STRING_TOKEN&#160;</td><td class="fielddoc"><p>A String Literal. All text between non-escaped '"' (double quote) characters. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa712c20d55774112ce9f3890d752a004a1d32fc48eff72113cf76816bf6222739" name="ggaa712c20d55774112ce9f3890d752a004a1d32fc48eff72113cf76816bf6222739"></a>WORD_TOKEN&#160;</td><td class="fielddoc"><p>Word Token. Any other whitespace-delimited token that isn't a VARIABLE_TOKEN or STRING_TOKEN. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa712c20d55774112ce9f3890d752a004af0b0ce2414f256bad9da221d2532147d" name="ggaa712c20d55774112ce9f3890d752a004af0b0ce2414f256bad9da221d2532147d"></a>OPEN_PAREN&#160;</td><td class="fielddoc"><p>Open Parenthesis. A non-escaped '(' character indicating the beginning of an expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa712c20d55774112ce9f3890d752a004a7093c88a2f741fb4dae5c36809a1958f" name="ggaa712c20d55774112ce9f3890d752a004a7093c88a2f741fb4dae5c36809a1958f"></a>CLOSE_PAREN&#160;</td><td class="fielddoc"><p>Close Parenthesis. A non-escaped ')' character indicating the end of an expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa712c20d55774112ce9f3890d752a004aba113c37f25d24aada154b75c7dd91ba" name="ggaa712c20d55774112ce9f3890d752a004aba113c37f25d24aada154b75c7dd91ba"></a>WHITESPACE&#160;</td><td class="fielddoc"><p>Whitespace. One or more whitespace chars. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa712c20d55774112ce9f3890d752a004a529e12725494ed531cceae5c7cf67207" name="ggaa712c20d55774112ce9f3890d752a004a529e12725494ed531cceae5c7cf67207"></a>LEFTOVER_TEXT&#160;</td><td class="fielddoc"><p>Leftover Text that remains unparsed after a parse error has occurred. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa712c20d55774112ce9f3890d752a004a86e85aeda2fee48d0fb55ddfb18093f8" name="ggaa712c20d55774112ce9f3890d752a004a86e85aeda2fee48d0fb55ddfb18093f8"></a>EXPRESSION_GROUP&#160;</td><td class="fielddoc"><p>A Group of nodes between an <span class="tt">OPEN_PAREN</span> and a matching <span class="tt">CLOSE_PAREN</span> </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa712c20d55774112ce9f3890d752a004a0f0ed217e6e29f661e404c05543fda61" name="ggaa712c20d55774112ce9f3890d752a004a0f0ed217e6e29f661e404c05543fda61"></a>ERROR_GROUP&#160;</td><td class="fielddoc"><p>A Group of nodes that cannot be combined into a coherent atom due to a parse error, even if some of the individual nodes could represent valid atoms. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga30dd580bc479b4115c44e3158719d746" name="ga30dd580bc479b4115c44e3158719d746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30dd580bc479b4115c44e3158719d746">&#9670;&#160;</a></span>sexpr_parser_err_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * sexpr_parser_err_str </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the error string associated with the last <span class="tt">sexpr_parser_parse</span> call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>A pointer to the Parser, which is associated with the text to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the C-string containing the parse error that occurred, or NULL if no parse error occurred </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned pointer should NOT be freed. It must never be accessed after the <a class="el" href="structsexpr__parser__t.html" title="Represents an S-Expression Parser state machine, to parse input text into an Atom.">sexpr_parser_t</a> has been freed, or any subsequent call to <span class="tt">sexpr_parser_parse</span> or <span class="tt">sexpr_parser_parse_to_syntax_tree</span> has been made. </dd></dl>

</div>
</div>
<a id="ga1a64ae026a50cbf1bca6d7c222cea19c" name="ga1a64ae026a50cbf1bca6d7c222cea19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a64ae026a50cbf1bca6d7c222cea19c">&#9670;&#160;</a></span>sexpr_parser_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sexpr_parser_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a></td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees an S-Expression Parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>The <span class="tt"><a class="el" href="structsexpr__parser__t.html" title="Represents an S-Expression Parser state machine, to parse input text into an Atom.">sexpr_parser_t</a></span> handle to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd26925a0c7e8ce118c9c4f0bf48f21c" name="gadd26925a0c7e8ce118c9c4f0bf48f21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd26925a0c7e8ce118c9c4f0bf48f21c">&#9670;&#160;</a></span>sexpr_parser_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> sexpr_parser_new </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new S-Expression Parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>A C-style string containing the input text to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <span class="tt"><a class="el" href="structsexpr__parser__t.html" title="Represents an S-Expression Parser state machine, to parse input text into an Atom.">sexpr_parser_t</a></span>, ready to parse the text </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned <span class="tt"><a class="el" href="structsexpr__parser__t.html" title="Represents an S-Expression Parser state machine, to parse input text into an Atom.">sexpr_parser_t</a></span> must be freed with <span class="tt"><a class="el" href="#ga1a64ae026a50cbf1bca6d7c222cea19c" title="Frees an S-Expression Parser.">sexpr_parser_free()</a></span> or passed to another function that takes ownership </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned <span class="tt"><a class="el" href="structsexpr__parser__t.html" title="Represents an S-Expression Parser state machine, to parse input text into an Atom.">sexpr_parser_t</a></span> borrows a reference to the <span class="tt">text</span>, so the returned <span class="tt"><a class="el" href="structsexpr__parser__t.html" title="Represents an S-Expression Parser state machine, to parse input text into an Atom.">sexpr_parser_t</a></span> must be freed before the <span class="tt">text</span> is freed or allowed to go out of scope. </dd></dl>

</div>
</div>
<a id="gaaf9c0c5587ad4fa324c7dd2f744031fa" name="gaaf9c0c5587ad4fa324c7dd2f744031fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf9c0c5587ad4fa324c7dd2f744031fa">&#9670;&#160;</a></span>sexpr_parser_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> sexpr_parser_parse </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tokenizer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the text associated with an <span class="tt"><a class="el" href="structsexpr__parser__t.html" title="Represents an S-Expression Parser state machine, to parse input text into an Atom.">sexpr_parser_t</a></span>, and creates the corresponding Atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>A pointer to the Parser, which is associated with the text to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tokenizer</td><td>A pointer to the Tokenizer, to use to interpret atoms within the expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span>, which may be an Expression atom with many child atoms. Returns a <span class="tt">none</span> atom if parsing is finished, or an error expression atom if a parse error occurred. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span>, and ultimately free it with <span class="tt"><a class="el" href="group__atom__group.html#ga16c30a26365362d512d39e7bfb657ec9" title="Frees an atom and all associated resources.">atom_free()</a></span> or pass it to another function that takes ownership responsibility </dd>
<dd>
If this function encounters an error, the error may be accessed with <span class="tt"><a class="el" href="#ga30dd580bc479b4115c44e3158719d746" title="Returns the error string associated with the last sexpr_parser_parse call.">sexpr_parser_err_str()</a></span> </dd></dl>

</div>
</div>
<a id="ga8bd019b50118713e56eb22c460520d94" name="ga8bd019b50118713e56eb22c460520d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bd019b50118713e56eb22c460520d94">&#9670;&#160;</a></span>sexpr_parser_parse_to_syntax_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> sexpr_parser_parse_to_syntax_tree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsexpr__parser__t.html">sexpr_parser_t</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the text associated with an <span class="tt"><a class="el" href="structsexpr__parser__t.html" title="Represents an S-Expression Parser state machine, to parse input text into an Atom.">sexpr_parser_t</a></span>, and creates a syntax tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>A pointer to the Parser, which is associated with the text to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> representing the root of the parsed tree </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span>, and ultimately free it with <span class="tt"><a class="el" href="#gabf7e8877026914bcbcfe4828e207ce74" title="Frees a syntax_node_t.">syntax_node_free()</a></span> </dd></dl>

</div>
</div>
<a id="ga2848d589e097d56d39fd5ca160daaf9b" name="ga2848d589e097d56d39fd5ca160daaf9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2848d589e097d56d39fd5ca160daaf9b">&#9670;&#160;</a></span>syntax_node_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> syntax_node_clone </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of a <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> representing the cloned syntax node </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span>, and ultimately free it with <span class="tt"><a class="el" href="#gabf7e8877026914bcbcfe4828e207ce74" title="Frees a syntax_node_t.">syntax_node_free()</a></span> </dd></dl>

</div>
</div>
<a id="gabf7e8877026914bcbcfe4828e207ce74" name="gabf7e8877026914bcbcfe4828e207ce74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf7e8877026914bcbcfe4828e207ce74">&#9670;&#160;</a></span>syntax_node_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syntax_node_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a></td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f904f0820cf14f8e94e31c72480ae03" name="ga2f904f0820cf14f8e94e31c72480ae03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f904f0820cf14f8e94e31c72480ae03">&#9670;&#160;</a></span>syntax_node_is_leaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool syntax_node_is_leaf </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if a syntax node is a leaf (has no children) and <span class="tt">false</span> otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The boolean value indicating if the node is a leaf </dd></dl>

</div>
</div>
<a id="gac27310c183211f17a923c46befb31f1d" name="gac27310c183211f17a923c46befb31f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac27310c183211f17a923c46befb31f1d">&#9670;&#160;</a></span>syntax_node_is_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool syntax_node_is_null </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if a syntax node represents the end of the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The boolean value indicating if the node is a a null node </dd></dl>

</div>
</div>
<a id="ga0161a7f0efb123c485646516bf8b1c52" name="ga0161a7f0efb123c485646516bf8b1c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0161a7f0efb123c485646516bf8b1c52">&#9670;&#160;</a></span>syntax_node_iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syntax_node_iterate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gac384a0391a5289fce4e892c3c1a066c3">c_syntax_node_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a depth-first iteration of all child syntax nodes within a syntax tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the top-level <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> representing the syntax tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A function that will be called to provide a vector of all type atoms associated with the <span class="tt">atom</span> argument atom </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A pointer to a caller-defined structure to facilitate communication with the <span class="tt">callback</span> function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9682eedb0f5bfd0d43c9af3e3a1b2bb9" name="ga9682eedb0f5bfd0d43c9af3e3a1b2bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9682eedb0f5bfd0d43c9af3e3a1b2bb9">&#9670;&#160;</a></span>syntax_node_src_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syntax_node_src_range </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *</td>          <td class="paramname"><span class="paramname"><em>range_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *</td>          <td class="paramname"><span class="paramname"><em>range_end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the beginning and end positions in the parsed source of the text represented by the syntax node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">range_start</td><td>A pointer to a value, into which the starting offset of the range will be written </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">range_end</td><td>A pointer to a value, into which the ending offset of the range will be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a87568403de72d2607c0e6bd08410ff" name="ga8a87568403de72d2607c0e6bd08410ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a87568403de72d2607c0e6bd08410ff">&#9670;&#160;</a></span>syntax_node_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gaa712c20d55774112ce9f3890d752a004">syntax_node_type_t</a> syntax_node_type </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsyntax__node__t.html">syntax_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of a <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the <span class="tt"><a class="el" href="structsyntax__node__t.html" title="Represents a component in a syntax tree created by parsing MeTTa code.">syntax_node_t</a></span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <span class="tt"><a class="el" href="#gaa712c20d55774112ce9f3890d752a004" title="The type of language construct respresented by a syntax_node_t.">syntax_node_type_t</a></span> representing the type of the syntax node </dd></dl>

</div>
</div>
<a id="ga56d5697609f691fca9647881fea9112a" name="ga56d5697609f691fca9647881fea9112a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56d5697609f691fca9647881fea9112a">&#9670;&#160;</a></span>tokenizer_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> tokenizer_clone </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tokenizer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a "deep copy" of a Tokenizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tokenizer</td><td>A pointer to the Tokenizer to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new Tokenizer, containing all registered Tokens belonging to the original Tokenizer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned <span class="tt"><a class="el" href="structtokenizer__t.html" title="Represents a handle to a Tokenizer, capable of recognizing meaningful Token substrings in text.">tokenizer_t</a></span> must be freed with <span class="tt"><a class="el" href="#gad406ea7b7a462ebb00ced9d9052607d5" title="Frees a Tokenizer handle.">tokenizer_free()</a></span> </dd></dl>

</div>
</div>
<a id="gad406ea7b7a462ebb00ced9d9052607d5" name="gad406ea7b7a462ebb00ced9d9052607d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad406ea7b7a462ebb00ced9d9052607d5">&#9670;&#160;</a></span>tokenizer_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tokenizer_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a></td>          <td class="paramname"><span class="paramname"><em>tokenizer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a Tokenizer handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tokenizer</td><td>The <span class="tt"><a class="el" href="structtokenizer__t.html" title="Represents a handle to a Tokenizer, capable of recognizing meaningful Token substrings in text.">tokenizer_t</a></span> handle to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When the last <span class="tt"><a class="el" href="structtokenizer__t.html" title="Represents a handle to a Tokenizer, capable of recognizing meaningful Token substrings in text.">tokenizer_t</a></span> handle for an underlying Tokenizer has been freed, then the Tokenizer will be deallocated </dd></dl>

</div>
</div>
<a id="gad8614b89e31ed717a51f1055c436744f" name="gad8614b89e31ed717a51f1055c436744f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8614b89e31ed717a51f1055c436744f">&#9670;&#160;</a></span>tokenizer_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> tokenizer_new </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new Tokenizer, without any registered Tokens. </p>
<dl class="section return"><dt>Returns</dt><dd>an <span class="tt"><a class="el" href="structtokenizer__t.html" title="Represents a handle to a Tokenizer, capable of recognizing meaningful Token substrings in text.">tokenizer_t</a></span> handle to access the newly created Tokenizer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned <span class="tt"><a class="el" href="structtokenizer__t.html" title="Represents a handle to a Tokenizer, capable of recognizing meaningful Token substrings in text.">tokenizer_t</a></span> handle must be freed with <span class="tt"><a class="el" href="#gad406ea7b7a462ebb00ced9d9052607d5" title="Frees a Tokenizer handle.">tokenizer_free()</a></span> </dd></dl>

</div>
</div>
<a id="gaead24238f59d2df002061961866bb6ed" name="gaead24238f59d2df002061961866bb6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead24238f59d2df002061961866bb6ed">&#9670;&#160;</a></span>tokenizer_register_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tokenizer_register_token </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtokenizer__t.html">tokenizer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tokenizer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>regex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structtoken__api__t.html">token_api_t</a> *</td>          <td class="paramname"><span class="paramname"><em>api</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a new custom Token in a Tokenizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tokenizer</td><td>A pointer to the Tokenizer in which to register the Token </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regex</td><td>A regular expression to match the incoming text, triggering this token to generate a new atom </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api</td><td>A table of functions to manage the token </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A caller-defined structure to communicate any state necessary to implement the Token parser </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Hyperon uses the Rust RegEx engine and syntax, <a href="https://docs.rs/regex/latest/regex/">documented here</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
