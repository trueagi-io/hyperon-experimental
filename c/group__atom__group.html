<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hyperon C: Atom Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hyperon C
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Atom Interface </div></div>
</div><!--header-->
<div class="contents">

<p>Functions for working directly with atoms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:atom_5Fref_5Ft" id="r_atom_5Fref_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatom__ref__t.html">atom_ref_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refers to an Atom owned by another object.  <a href="structatom__ref__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:atom_5Ft" id="r_atom_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatom__t.html">atom_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an Atom of any type.  <a href="structatom__t.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0feaa3726ea80b9198f76603e94d5360" id="r_ga0feaa3726ea80b9198f76603e94d5360"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0feaa3726ea80b9198f76603e94d5360">c_atom_callback_t</a>) (<a class="el" href="structatom__ref__t.html">atom_ref_t</a> atom, void *context)</td></tr>
<tr class="memdesc:ga0feaa3726ea80b9198f76603e94d5360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature for a callback providing access to an atom.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga8a39750896676dfd62ad63a45839dd9a" id="r_ga8a39750896676dfd62ad63a45839dd9a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8a39750896676dfd62ad63a45839dd9a">atom_type_t</a> { <a class="el" href="#gga8a39750896676dfd62ad63a45839dd9aae3d30ffaffa3c06ed917e565dda1fbc5">SYMBOL</a>
, <a class="el" href="#gga8a39750896676dfd62ad63a45839dd9aa39031ce5df6f91d3778590d6d644b9ea">VARIABLE</a>
, <a class="el" href="#gga8a39750896676dfd62ad63a45839dd9aabf65150431dad5e3c992e73b24f45e25">EXPR</a>
, <a class="el" href="#gga8a39750896676dfd62ad63a45839dd9aaefa0f3ce09b7d810dde1e3cde60f7c4f">GROUNDED</a>
 }</td></tr>
<tr class="memdesc:ga8a39750896676dfd62ad63a45839dd9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents whether an atom is a Symbol, Variable, Expression, or Grounded atom.  <a href="#ga8a39750896676dfd62ad63a45839dd9a">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf9671a4df299e680d2bb6cb70c9afb62" id="r_gaf9671a4df299e680d2bb6cb70c9afb62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__ref__t.html">atom_ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf9671a4df299e680d2bb6cb70c9afb62">atom_ref</a> (const <a class="el" href="structatom__t.html">atom_t</a> *atom)</td></tr>
<tr class="memdesc:gaf9671a4df299e680d2bb6cb70c9afb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> that points to another atom you own.  <br /></td></tr>
<tr class="memitem:gac67bdec25b726b7f680b7a843fa4e9b1" id="r_gac67bdec25b726b7f680b7a843fa4e9b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__ref__t.html">atom_ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac67bdec25b726b7f680b7a843fa4e9b1">atom_ref_null</a> (void)</td></tr>
<tr class="memdesc:gac67bdec25b726b7f680b7a843fa4e9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> that points nothing.  <br /></td></tr>
<tr class="memitem:ga419a4d0d779527802b50326a88c37332" id="r_ga419a4d0d779527802b50326a88c37332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga419a4d0d779527802b50326a88c37332">atom_sym</a> (const char *name)</td></tr>
<tr class="memdesc:ga419a4d0d779527802b50326a88c37332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Symbol atom with the specified name.  <br /></td></tr>
<tr class="memitem:gae9065279c5f5521f414d512e4e3bd0a8" id="r_gae9065279c5f5521f414d512e4e3bd0a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae9065279c5f5521f414d512e4e3bd0a8">atom_expr</a> (<a class="el" href="structatom__t.html">atom_t</a> *children, uintptr_t size)</td></tr>
<tr class="memdesc:gae9065279c5f5521f414d512e4e3bd0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Expression atom with the specified children atoms.  <br /></td></tr>
<tr class="memitem:ga451b5cfce6e30f79df7d21c51a3fdb21" id="r_ga451b5cfce6e30f79df7d21c51a3fdb21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga451b5cfce6e30f79df7d21c51a3fdb21">atom_expr_from_vec</a> (struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a> children)</td></tr>
<tr class="memdesc:ga451b5cfce6e30f79df7d21c51a3fdb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Expression atom with the children contained in an <span class="tt"><a class="el" href="structatom__vec__t.html" title="Contains a vector (list) of Atoms.">atom_vec_t</a></span>  <br /></td></tr>
<tr class="memitem:ga8e9de2900187565d44bca5b70a0c669e" id="r_ga8e9de2900187565d44bca5b70a0c669e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e9de2900187565d44bca5b70a0c669e">atom_var</a> (const char *name)</td></tr>
<tr class="memdesc:ga8e9de2900187565d44bca5b70a0c669e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Variable atom with the specified name.  <br /></td></tr>
<tr class="memitem:ga39f1ba2bb039593e0bfa4a3d70169b16" id="r_ga39f1ba2bb039593e0bfa4a3d70169b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga39f1ba2bb039593e0bfa4a3d70169b16">atom_var_parse_name</a> (const char *name)</td></tr>
<tr class="memdesc:ga39f1ba2bb039593e0bfa4a3d70169b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Variable atom parsing full formatted name of the variable.  <br /></td></tr>
<tr class="memitem:gadd7da962227a991c28186299170f5e60" id="r_gadd7da962227a991c28186299170f5e60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadd7da962227a991c28186299170f5e60">atom_gnd</a> (struct <a class="el" href="structgnd__t.html">gnd_t</a> *gnd)</td></tr>
<tr class="memitem:gabfa567d250ef52a7f2a407f2bd7c24d7" id="r_gabfa567d250ef52a7f2a407f2bd7c24d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabfa567d250ef52a7f2a407f2bd7c24d7">atom_bool</a> (bool b)</td></tr>
<tr class="memitem:ga7cc11147cfa0b6c2680327eaab2645ad" id="r_ga7cc11147cfa0b6c2680327eaab2645ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7cc11147cfa0b6c2680327eaab2645ad">atom_int</a> (int64_t n)</td></tr>
<tr class="memitem:ga64ec88ca53b4ce8dfd3b9da1a9b67f8e" id="r_ga64ec88ca53b4ce8dfd3b9da1a9b67f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga64ec88ca53b4ce8dfd3b9da1a9b67f8e">atom_float</a> (double f)</td></tr>
<tr class="memitem:ga4edfc284c01c335e48f7264cf5ab027c" id="r_ga4edfc284c01c335e48f7264cf5ab027c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4edfc284c01c335e48f7264cf5ab027c">atom_gnd_for_space</a> (const struct <a class="el" href="structspace__t.html">space_t</a> *space)</td></tr>
<tr class="memdesc:ga4edfc284c01c335e48f7264cf5ab027c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Grounded Atom referencing a Space.  <br /></td></tr>
<tr class="memitem:ga16c30a26365362d512d39e7bfb657ec9" id="r_ga16c30a26365362d512d39e7bfb657ec9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga16c30a26365362d512d39e7bfb657ec9">atom_free</a> (<a class="el" href="structatom__t.html">atom_t</a> atom)</td></tr>
<tr class="memdesc:ga16c30a26365362d512d39e7bfb657ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an atom and all associated resources.  <br /></td></tr>
<tr class="memitem:ga753b37b98ea33342e6c59ae4f6f531b3" id="r_ga753b37b98ea33342e6c59ae4f6f531b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga753b37b98ea33342e6c59ae4f6f531b3">atom_clone</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga753b37b98ea33342e6c59ae4f6f531b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a "deep copy" of an atom. Useful to turn an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> into an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span>  <br /></td></tr>
<tr class="memitem:ga81c594ac890274ec2032ead659b4955f" id="r_ga81c594ac890274ec2032ead659b4955f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga81c594ac890274ec2032ead659b4955f">atom_eq</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *a, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *b)</td></tr>
<tr class="memdesc:ga81c594ac890274ec2032ead659b4955f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two atom objects represent the same conceptual atom.  <br /></td></tr>
<tr class="memitem:ga0948ea12bfa73f1c2453634186ef1c07" id="r_ga0948ea12bfa73f1c2453634186ef1c07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0948ea12bfa73f1c2453634186ef1c07">atoms_are_equivalent</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *a, const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *b)</td></tr>
<tr class="memdesc:ga0948ea12bfa73f1c2453634186ef1c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two atoms are alpha equivalent.  <br /></td></tr>
<tr class="memitem:ga45019285d58a93a88327a5557895130b" id="r_ga45019285d58a93a88327a5557895130b"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="#ga8a39750896676dfd62ad63a45839dd9a">atom_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga45019285d58a93a88327a5557895130b">atom_get_metatype</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga45019285d58a93a88327a5557895130b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the metatype of an atom.  <br /></td></tr>
<tr class="memitem:ga49806bfca2937236779b59778b978d0e" id="r_ga49806bfca2937236779b59778b978d0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga49806bfca2937236779b59778b978d0e">atom_is_null</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga49806bfca2937236779b59778b978d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if the referenced atom is invalid, otherwise returns <span class="tt">false</span>  <br /></td></tr>
<tr class="memitem:gad6b7bebbdd94cf9b0579e1f12e398533" id="r_gad6b7bebbdd94cf9b0579e1f12e398533"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad6b7bebbdd94cf9b0579e1f12e398533">atom_to_str</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:gad6b7bebbdd94cf9b0579e1f12e398533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a human-readable text description of an atom.  <br /></td></tr>
<tr class="memitem:ga8033d8be97cbebc5c9b9323fe1d4c1b9" id="r_ga8033d8be97cbebc5c9b9323fe1d4c1b9"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8033d8be97cbebc5c9b9323fe1d4c1b9">atom_get_name</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom, char *buf, uintptr_t buf_len)</td></tr>
<tr class="memdesc:ga8033d8be97cbebc5c9b9323fe1d4c1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the name of an atom into a text buffer.  <br /></td></tr>
<tr class="memitem:gab21346868ef5fa3a7b455723ae9e2d9d" id="r_gab21346868ef5fa3a7b455723ae9e2d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab21346868ef5fa3a7b455723ae9e2d9d">atom_get_children</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom, <a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:gab21346868ef5fa3a7b455723ae9e2d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to all children atoms within an expression atom.  <br /></td></tr>
<tr class="memitem:ga4d798c34510a3eb93989ac2e7dcee706" id="r_ga4d798c34510a3eb93989ac2e7dcee706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4d798c34510a3eb93989ac2e7dcee706">atom_iterate</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom, <a class="el" href="#ga0feaa3726ea80b9198f76603e94d5360">c_atom_callback_t</a> callback, void *context)</td></tr>
<tr class="memdesc:ga4d798c34510a3eb93989ac2e7dcee706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a depth-first exhaustive iteration of an atom and all its children recursively.  <br /></td></tr>
<tr class="memitem:ga415aae7c3525dc8cab37cf88ff2ebfc5" id="r_ga415aae7c3525dc8cab37cf88ff2ebfc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structatom__t.html">atom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga415aae7c3525dc8cab37cf88ff2ebfc5">atom_get_grounded_type</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga415aae7c3525dc8cab37cf88ff2ebfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the grounded type of a Grounded Atom.  <br /></td></tr>
<tr class="memitem:gae8ac0fb8c56481d89c2db8b6b8d20709" id="r_gae8ac0fb8c56481d89c2db8b6b8d20709"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structgnd__t.html">gnd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae8ac0fb8c56481d89c2db8b6b8d20709">atom_get_object</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:gae8ac0fb8c56481d89c2db8b6b8d20709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a pointer to an object backing a Grounded Atom.  <br /></td></tr>
<tr class="memitem:gae19d9f3cdeb87547c1c82d7ff1696d90" id="r_gae19d9f3cdeb87547c1c82d7ff1696d90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae19d9f3cdeb87547c1c82d7ff1696d90">atom_is_cgrounded</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:gae19d9f3cdeb87547c1c82d7ff1696d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the atom refers to CGrounded object.  <br /></td></tr>
<tr class="memitem:ga7c9055ced20b4a177700cd6962ff34e4" id="r_ga7c9055ced20b4a177700cd6962ff34e4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspace__t.html">space_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7c9055ced20b4a177700cd6962ff34e4">atom_get_space</a> (const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *atom)</td></tr>
<tr class="memdesc:ga7c9055ced20b4a177700cd6962ff34e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the space wrapped inside a Grounded atom.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Functions for working directly with atoms. </p>
<p>These functions are used to create, inspect, modify, and free atoms. </p>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ga0feaa3726ea80b9198f76603e94d5360" name="ga0feaa3726ea80b9198f76603e94d5360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0feaa3726ea80b9198f76603e94d5360">&#9670;&#160;</a></span>c_atom_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* c_atom_callback_t) (<a class="el" href="structatom__ref__t.html">atom_ref_t</a> atom, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function signature for a callback providing access to an atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>A reference to the atom. This atom should not be modified or freed by the callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context state pointer initially passed to the upstream function initiating the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="ga8a39750896676dfd62ad63a45839dd9a" name="ga8a39750896676dfd62ad63a45839dd9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a39750896676dfd62ad63a45839dd9a">&#9670;&#160;</a></span>atom_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga8a39750896676dfd62ad63a45839dd9a">atom_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents whether an atom is a Symbol, Variable, Expression, or Grounded atom. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8a39750896676dfd62ad63a45839dd9aae3d30ffaffa3c06ed917e565dda1fbc5" name="gga8a39750896676dfd62ad63a45839dd9aae3d30ffaffa3c06ed917e565dda1fbc5"></a>SYMBOL&#160;</td><td class="fielddoc"><p>The atom is a Symbol atom. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8a39750896676dfd62ad63a45839dd9aa39031ce5df6f91d3778590d6d644b9ea" name="gga8a39750896676dfd62ad63a45839dd9aa39031ce5df6f91d3778590d6d644b9ea"></a>VARIABLE&#160;</td><td class="fielddoc"><p>The atom is a Variable atom. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8a39750896676dfd62ad63a45839dd9aabf65150431dad5e3c992e73b24f45e25" name="gga8a39750896676dfd62ad63a45839dd9aabf65150431dad5e3c992e73b24f45e25"></a>EXPR&#160;</td><td class="fielddoc"><p>The atom is an Expression atom. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8a39750896676dfd62ad63a45839dd9aaefa0f3ce09b7d810dde1e3cde60f7c4f" name="gga8a39750896676dfd62ad63a45839dd9aaefa0f3ce09b7d810dde1e3cde60f7c4f"></a>GROUNDED&#160;</td><td class="fielddoc"><p>The atom is a Grounded atom. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gabfa567d250ef52a7f2a407f2bd7c24d7" name="gabfa567d250ef52a7f2a407f2bd7c24d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfa567d250ef52a7f2a407f2bd7c24d7">&#9670;&#160;</a></span>atom_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> atom_bool </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>boolean value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> for the Bool Grounded atom </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> </dd></dl>

</div>
</div>
<a id="ga753b37b98ea33342e6c59ae4f6f531b3" name="ga753b37b98ea33342e6c59ae4f6f531b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga753b37b98ea33342e6c59ae4f6f531b3">&#9670;&#160;</a></span>atom_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> atom_clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atom</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a "deep copy" of an atom. Useful to turn an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> into an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> for the cloned atom </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> </dd></dl>

</div>
</div>
<a id="ga81c594ac890274ec2032ead659b4955f" name="ga81c594ac890274ec2032ead659b4955f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81c594ac890274ec2032ead659b4955f">&#9670;&#160;</a></span>atom_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atom_eq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two atom objects represent the same conceptual atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> representing the first atom </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> representing the second atom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> is the atoms are conceptually identical </dd></dl>

</div>
</div>
<a id="gae9065279c5f5521f414d512e4e3bd0a8" name="gae9065279c5f5521f414d512e4e3bd0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9065279c5f5521f414d512e4e3bd0a8">&#9670;&#160;</a></span>atom_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> atom_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structatom__t.html">atom_t</a> *</td>          <td class="paramname"><span class="paramname"><em>children</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Expression atom with the specified children atoms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">children</td><td>A packed buffer of <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a> *</span>, representing the children atoms </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in <span class="tt">children</span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> for the Expression atom, containing all 'children' atoms </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function takes ownership of all <span class="tt">children</span> atoms, so they must not be subsequently accessed </dd></dl>

</div>
</div>
<a id="ga451b5cfce6e30f79df7d21c51a3fdb21" name="ga451b5cfce6e30f79df7d21c51a3fdb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga451b5cfce6e30f79df7d21c51a3fdb21">&#9670;&#160;</a></span>atom_expr_from_vec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> atom_expr_from_vec </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structatom__vec__t.html">atom_vec_t</a></td>          <td class="paramname"><span class="paramname"><em>children</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Expression atom with the children contained in an <span class="tt"><a class="el" href="structatom__vec__t.html" title="Contains a vector (list) of Atoms.">atom_vec_t</a></span> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">children</td><td>An <span class="tt"><a class="el" href="structatom__vec__t.html" title="Contains a vector (list) of Atoms.">atom_vec_t</a></span> containing all children atoms </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> for the Expression atom, containing all 'children' atoms </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function takes ownership of the <span class="tt">children</span> vec, so it must not be subsequently accessed </dd></dl>

</div>
</div>
<a id="ga64ec88ca53b4ce8dfd3b9da1a9b67f8e" name="ga64ec88ca53b4ce8dfd3b9da1a9b67f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64ec88ca53b4ce8dfd3b9da1a9b67f8e">&#9670;&#160;</a></span>atom_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> atom_float </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>float number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> for the Number Grounded atom </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> </dd></dl>

</div>
</div>
<a id="ga16c30a26365362d512d39e7bfb657ec9" name="ga16c30a26365362d512d39e7bfb657ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16c30a26365362d512d39e7bfb657ec9">&#9670;&#160;</a></span>atom_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atom_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structatom__t.html">atom_t</a></td>          <td class="paramname"><span class="paramname"><em>atom</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees an atom and all associated resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>The atom to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab21346868ef5fa3a7b455723ae9e2d9d" name="gab21346868ef5fa3a7b455723ae9e2d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab21346868ef5fa3a7b455723ae9e2d9d">&#9670;&#160;</a></span>atom_get_children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atom_get_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__atom__vec__group.html#ga8fd8a99298ab86ca0f4007a26b9009e3">c_atom_vec_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to all children atoms within an expression atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> to access </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A function that will be called to return access to each atom </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A pointer to a caller-defined structure to facilitate communication with the <span class="tt">callback</span> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should only be called with Expression atoms </dd></dl>

</div>
</div>
<a id="ga415aae7c3525dc8cab37cf88ff2ebfc5" name="ga415aae7c3525dc8cab37cf88ff2ebfc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga415aae7c3525dc8cab37cf88ff2ebfc5">&#9670;&#160;</a></span>atom_get_grounded_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> atom_get_grounded_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atom</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the grounded type of a Grounded Atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> expressing the grounded type of <span class="tt">atom</span> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Grounded Types are themselves atoms used by the MeTTa type system for customized behavior. A grounded type is different from a generic atom type, expressed by <span class="tt"><a class="el" href="#ga8a39750896676dfd62ad63a45839dd9a" title="Represents whether an atom is a Symbol, Variable, Expression, or Grounded atom.">atom_type_t</a></span>. Only Grounded atoms have grounded types. TODO: Where to LINK to learn more?? </dd>
<dd>
The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> </dd></dl>

</div>
</div>
<a id="ga45019285d58a93a88327a5557895130b" name="ga45019285d58a93a88327a5557895130b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45019285d58a93a88327a5557895130b">&#9670;&#160;</a></span>atom_get_metatype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga8a39750896676dfd62ad63a45839dd9a">atom_type_t</a> atom_get_metatype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atom</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the metatype of an atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <span class="tt"><a class="el" href="#ga8a39750896676dfd62ad63a45839dd9a" title="Represents whether an atom is a Symbol, Variable, Expression, or Grounded atom.">atom_type_t</a></span> indicating the type of <span class="tt">atom</span> </dd></dl>

</div>
</div>
<a id="ga8033d8be97cbebc5c9b9323fe1d4c1b9" name="ga8033d8be97cbebc5c9b9323fe1d4c1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8033d8be97cbebc5c9b9323fe1d4c1b9">&#9670;&#160;</a></span>atom_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t atom_get_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t</td>          <td class="paramname"><span class="paramname"><em>buf_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders the name of an atom into a text buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> to get the name of </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A buffer into which the text will be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>The maximum allocated size of <span class="tt">buf</span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the name string, minus the string terminator character. If <span class="tt">return_value &gt; buf_len + 1</span>, then the text was not fully written and this function should be called again with a larger buffer. </dd></dl>

</div>
</div>
<a id="gae8ac0fb8c56481d89c2db8b6b8d20709" name="gae8ac0fb8c56481d89c2db8b6b8d20709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8ac0fb8c56481d89c2db8b6b8d20709">&#9670;&#160;</a></span>atom_get_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structgnd__t.html">gnd_t</a> * atom_get_object </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atom</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a pointer to an object backing a Grounded Atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the <span class="tt"><a class="el" href="structgnd__t.html" title="A struct header that must preface a buffer used as a backing object for a Grounded Atom.">gnd_t</a></span> orginally used to create the Grounded Atom </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is only valid for Grounded Atoms implemented via the HyperonC API </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned pointer must not be accessed after the atom has been freed or modified elsewhere </dd></dl>

</div>
</div>
<a id="ga7c9055ced20b4a177700cd6962ff34e4" name="ga7c9055ced20b4a177700cd6962ff34e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c9055ced20b4a177700cd6962ff34e4">&#9670;&#160;</a></span>atom_get_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspace__t.html">space_t</a> atom_get_space </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atom</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the space wrapped inside a Grounded atom. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga4edfc284c01c335e48f7264cf5ab027c" title="Creates a Grounded Atom referencing a Space.">atom_gnd_for_space</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> that wraps a Space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Space handle to the space inside a grounded atom </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned space is borrowed from the atom. It must not be accessed after the atom has been freed or modified elsewhere </dd></dl>

</div>
</div>
<a id="gadd7da962227a991c28186299170f5e60" name="gadd7da962227a991c28186299170f5e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd7da962227a991c28186299170f5e60">&#9670;&#160;</a></span>atom_gnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> atom_gnd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structgnd__t.html">gnd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>gnd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gnd</td><td>A pointer to a buffer to back the new Grounded Atom. See the documentation of <span class="tt"><a class="el" href="structgnd__t.html" title="A struct header that must preface a buffer used as a backing object for a Grounded Atom.">gnd_t</a></span> for more info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> for the Grounded atom </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> </dd></dl>

</div>
</div>
<a id="ga4edfc284c01c335e48f7264cf5ab027c" name="ga4edfc284c01c335e48f7264cf5ab027c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4edfc284c01c335e48f7264cf5ab027c">&#9670;&#160;</a></span>atom_gnd_for_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> atom_gnd_for_space </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspace__t.html">space_t</a> *</td>          <td class="paramname"><span class="paramname"><em>space</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Grounded Atom referencing a Space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>A pointer to an <span class="tt"><a class="el" href="structspace__t.html" title="A Space handle, providing access to a Space in which atoms may exist in relation to other atoms.">space_t</a></span> for accessing the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> for the Grounded atom </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> </dd>
<dd>
This function does not consume the space and the space still must be freed with <span class="tt"><a class="el" href="group__space__client__group.html#ga0cc53ed059ecda436d1b973445135a64" title="Frees a space_t handle.">space_free()</a></span> </dd></dl>

</div>
</div>
<a id="ga7cc11147cfa0b6c2680327eaab2645ad" name="ga7cc11147cfa0b6c2680327eaab2645ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cc11147cfa0b6c2680327eaab2645ad">&#9670;&#160;</a></span>atom_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> atom_int </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>integer number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> for the Number Grounded atom </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> </dd></dl>

</div>
</div>
<a id="gae19d9f3cdeb87547c1c82d7ff1696d90" name="gae19d9f3cdeb87547c1c82d7ff1696d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae19d9f3cdeb87547c1c82d7ff1696d90">&#9670;&#160;</a></span>atom_is_cgrounded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atom_is_cgrounded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atom</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the atom refers to CGrounded object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the atom_get_object can be used on this atom without panic </dd></dl>

</div>
</div>
<a id="ga49806bfca2937236779b59778b978d0e" name="ga49806bfca2937236779b59778b978d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49806bfca2937236779b59778b978d0e">&#9670;&#160;</a></span>atom_is_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atom_is_null </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atom</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if the referenced atom is invalid, otherwise returns <span class="tt">false</span> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the referenced atom is invalid, otherwise returns <span class="tt">false</span> </dd></dl>

</div>
</div>
<a id="ga4d798c34510a3eb93989ac2e7dcee706" name="ga4d798c34510a3eb93989ac2e7dcee706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d798c34510a3eb93989ac2e7dcee706">&#9670;&#160;</a></span>atom_iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atom_iterate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga0feaa3726ea80b9198f76603e94d5360">c_atom_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a depth-first exhaustive iteration of an atom and all its children recursively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> to iterate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A function that will be called to return access to each contained atom </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A pointer to a caller-defined structure to facilitate communication with the <span class="tt">callback</span> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The first result returned will be the atom itself. Only Expression atoms contain deeper trees to iterate. </dd></dl>

</div>
</div>
<a id="gaf9671a4df299e680d2bb6cb70c9afb62" name="gaf9671a4df299e680d2bb6cb70c9afb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9671a4df299e680d2bb6cb70c9afb62">&#9670;&#160;</a></span>atom_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__ref__t.html">atom_ref_t</a> atom_ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__t.html">atom_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atom</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> that points to another atom you own. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>The atom to reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> referencing <span class="tt">atom</span> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> must not be accessed after the atom it refers to has been freed, or after ownership of the original atom has been transferred to another function</dd></dl>
<p>Returns an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> that points to the supplied atom. </p>

</div>
</div>
<a id="gac67bdec25b726b7f680b7a843fa4e9b1" name="gac67bdec25b726b7f680b7a843fa4e9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac67bdec25b726b7f680b7a843fa4e9b1">&#9670;&#160;</a></span>atom_ref_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__ref__t.html">atom_ref_t</a> atom_ref_null </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> that points nothing. </p>
<dl class="section return"><dt>Returns</dt><dd>an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> referencing nothing</dd></dl>
<p>Returns an <a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a> that does not point to any atom </p>

</div>
</div>
<a id="ga419a4d0d779527802b50326a88c37332" name="ga419a4d0d779527802b50326a88c37332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga419a4d0d779527802b50326a88c37332">&#9670;&#160;</a></span>atom_sym()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> atom_sym </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Symbol atom with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the symbol </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> for the Symbol Atom </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span></dd></dl>
<p>Create a new Symbol atom with the specified name. </p>

</div>
</div>
<a id="gad6b7bebbdd94cf9b0579e1f12e398533" name="gad6b7bebbdd94cf9b0579e1f12e398533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6b7bebbdd94cf9b0579e1f12e398533">&#9670;&#160;</a></span>atom_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t atom_to_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>atom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t</td>          <td class="paramname"><span class="paramname"><em>buf_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a human-readable text description of an atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atom</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> to render </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A buffer into which the text will be rendered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>The maximum allocated size of <span class="tt">buf</span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the description string, minus the string terminator character. If <span class="tt">return_value &gt; buf_len + 1</span>, then the text was not fully rendered and this function should be called again with a larger buffer. </dd></dl>

</div>
</div>
<a id="ga8e9de2900187565d44bca5b70a0c669e" name="ga8e9de2900187565d44bca5b70a0c669e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e9de2900187565d44bca5b70a0c669e">&#9670;&#160;</a></span>atom_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> atom_var </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Variable atom with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name for the newly created Variable atom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> for the Variable atom </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> </dd></dl>

</div>
</div>
<a id="ga39f1ba2bb039593e0bfa4a3d70169b16" name="ga39f1ba2bb039593e0bfa4a3d70169b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39f1ba2bb039593e0bfa4a3d70169b16">&#9670;&#160;</a></span>atom_var_parse_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structatom__t.html">atom_t</a> atom_var_parse_name </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Variable atom parsing full formatted name of the variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name for the newly created Variable atom in a format <span class="tt">&lt;name&gt;#id</span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> for the Variable atom, returns <span class="tt">atom_t::null()</span> when parsing fails </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must take ownership responsibility for the returned <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> </dd></dl>

</div>
</div>
<a id="ga0948ea12bfa73f1c2453634186ef1c07" name="ga0948ea12bfa73f1c2453634186ef1c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0948ea12bfa73f1c2453634186ef1c07">&#9670;&#160;</a></span>atoms_are_equivalent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atoms_are_equivalent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structatom__ref__t.html">atom_ref_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two atoms are alpha equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> representing the first atom </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A pointer to an <span class="tt"><a class="el" href="structatom__t.html" title="Represents an Atom of any type.">atom_t</a></span> or an <span class="tt"><a class="el" href="structatom__ref__t.html" title="Refers to an Atom owned by another object.">atom_ref_t</a></span> representing the second atom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the atoms can be converted to each other by renaming variables, otherwise <span class="tt">false</span> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
