<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Contains types and functions which are necessary to create and manipulate separate atoms. There are four kinds or meta-types of atoms: Atom::Symbol, Atom::Variable, Atom::Grounded and Atom::Expression."><title>hyperon_atom - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="hyperon_atom" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.0 (254b59607 2026-01-19)" data-channel="1.93.0" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate hyperon_atom</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../hyperon_atom/index.html">hyperon_<wbr>atom</a><span class="version">0.2.10</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>hyperon_<wbr>atom</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/hyperon_atom/lib.rs.html#1-1410">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Contains types and functions which are necessary to create and
manipulate separate atoms. There are four kinds or meta-types of atoms:
<a href="enum.Atom.html#variant.Symbol" title="variant hyperon_atom::Atom::Symbol">Atom::Symbol</a>, <a href="enum.Atom.html#variant.Variable" title="variant hyperon_atom::Atom::Variable">Atom::Variable</a>, <a href="enum.Atom.html#variant.Grounded" title="variant hyperon_atom::Atom::Grounded">Atom::Grounded</a> and <a href="enum.Atom.html#variant.Expression" title="variant hyperon_atom::Atom::Expression">Atom::Expression</a>.</p>
<p><a href="enum.Atom.html#variant.Symbol" title="variant hyperon_atom::Atom::Symbol">Atom::Symbol</a> represents a single concepts which is identified by name.
Two symbols which have the same name reference the same concept.</p>
<p><a href="enum.Atom.html#variant.Variable" title="variant hyperon_atom::Atom::Variable">Atom::Variable</a> represents a variable like a variable in the pattern.
Variable itself doesn’t keep its value inside it but instead can be used
as a key in a <a href="matcher/struct.Bindings.html" title="struct hyperon_atom::matcher::Bindings">matcher::Bindings</a> to get the real value.</p>
<p><a href="enum.Atom.html#variant.Grounded" title="variant hyperon_atom::Atom::Grounded">Atom::Grounded</a> represents sub-symbolic knowledge. On the API level it
allows keeping data and behaviour inside an atom. There are three aspects
of the grounded atom which can be customized:</p>
<ul>
<li>the type of grounded atom is provided by the atom itself;</li>
<li>matching algorithm of the atom can be modified by the user;</li>
<li>atom can be made executable; such atom can be used to apply some
sub-symbolic operations to other atoms as arguments.</li>
</ul>
<p><a href="enum.Atom.html#variant.Expression" title="variant hyperon_atom::Atom::Expression">Atom::Expression</a> combines other kinds of atoms including expressions
themselves.</p>
<p>All kinds of atoms except grounded can be relatively simply created
using corresponding constructors: <a href="enum.Atom.html#method.sym" title="associated function hyperon_atom::Atom::sym">Atom::sym</a>, <a href="enum.Atom.html#method.var" title="associated function hyperon_atom::Atom::var">Atom::var</a>, <a href="enum.Atom.html#method.expr" title="associated function hyperon_atom::Atom::expr">Atom::expr</a>.
Grounded atoms are more complex because they can represent any Rust
value.</p>
<p>There are two flavors of Grounded atoms. When Rust value implements
<a href="trait.AutoGroundedType.html" title="trait hyperon_atom::AutoGroundedType">AutoGroundedType</a> trait (which is automatically implemented for any value
implementing <code>'static + PartialEq + Clone + Debug</code>) then one
can easily wrap it into atom using <a href="enum.Atom.html#method.value" title="associated function hyperon_atom::Atom::value">Atom::value</a> constructor. Resulting
atom contains the value, has autogenerated type <code>Atom::sym(&lt;name of T&gt;)</code>
where <code>T</code> is a Rust type of the value. This atom is not executable and
matches with other grounded atom when <code>PartialEq::eq</code> returns <code>true</code> for
the values inside these atoms.</p>
<p>To override any aspect of this predefined grounded atom behaviour, one
should make <a href="trait.CustomGroundedType.html" title="trait hyperon_atom::CustomGroundedType">CustomGroundedType</a> implementable for the Rust value. In other
words one should implement two additional traits: <a href="trait.Grounded.html" title="trait hyperon_atom::Grounded">Grounded</a> and <a href="https://doc.rust-lang.org/1.93.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>.
<a href="https://doc.rust-lang.org/1.93.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> is used to represent grounded atom as a string. By implementing
<a href="trait.Grounded.html" title="trait hyperon_atom::Grounded">Grounded</a> one can make atom executable, implement custom matching logic
or return a custom type of the atom. See example in <a href="trait.Grounded.html" title="trait hyperon_atom::Grounded">Grounded</a> section.</p>
<p>There are predefined functions which can be used to reuse default
behaviour if needed:</p>
<ul>
<li><a href="fn.rust_type_atom.html" title="fn hyperon_atom::rust_type_atom">rust_type_atom</a> - return Rust type name calculated by compiler;</li>
<li><a href="fn.match_by_equality.html" title="fn hyperon_atom::match_by_equality">match_by_equality</a> - match two atoms when <code>PartialEq::eq</code> returns <code>true</code>;</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="gnd/index.html" title="mod hyperon_atom::gnd">gnd</a></dt><dt><a class="mod" href="matcher/index.html" title="mod hyperon_atom::matcher">matcher</a></dt><dd>Module contains functions to match atoms and work with variable bindings.</dd><dt><a class="mod" href="serial/index.html" title="mod hyperon_atom::serial">serial</a></dt><dt><a class="mod" href="subexpr/index.html" title="mod hyperon_atom::subexpr">subexpr</a></dt><dd>Contains algorithms to walk through subexpressions of expression in
different ways.</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.bind.html" title="macro hyperon_atom::bind">bind</a></dt><dd>Constructs new instance of the <a href="matcher/struct.Bindings.html" title="struct hyperon_atom::matcher::Bindings">Bindings</a> with predefined content.
Macros takes variable/value pairs as arguments. If value is a single
variable then the pair means variable equality. Otherwise pair means
assigning value. May be ineffective, should be used mainly in unit tests.</dd><dt><a class="macro" href="macro.bind_set.html" title="macro hyperon_atom::bind_set">bind_<wbr>set</a></dt><dd>Constructs a new <a href="matcher/struct.BindingsSet.html" title="struct hyperon_atom::matcher::BindingsSet">BindingsSet</a> with predefined content.
Macros takes variable/value pairs as arguments. If value is a single
variable then the pair means variable equality. Otherwise pair means
assigning value. May be ineffective, should be used mainly in unit tests.</dd><dt><a class="macro" href="macro.expr.html" title="macro hyperon_atom::expr">expr</a></dt><dd>Constructs new Atom using symplified syntax for expressions.
Macros has a perfomance penalty because it creates and uses an additional
wrapper for grounded atoms. It is intended for using mainly in the unit
tests. Use string literals for symbols, identifiers for variables,
braces for grounded symbols and S-expressions syntax for expressions.</dd><dt><a class="macro" href="macro.sym.html" title="macro hyperon_atom::sym">sym</a></dt><dd>Constructs new symbol atom. Can be used to construct <code>const</code> instances.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AtomIter.html" title="struct hyperon_atom::AtomIter">Atom<wbr>Iter</a></dt><dd>Iterator of the sub-atoms of the <a href="enum.Atom.html" title="enum hyperon_atom::Atom">Atom</a>.</dd><dt><a class="struct" href="struct.AtomIterMut.html" title="struct hyperon_atom::AtomIterMut">Atom<wbr>Iter<wbr>Mut</a></dt><dd>Mutable iterator of the sub-atoms of the <a href="enum.Atom.html" title="enum hyperon_atom::Atom">Atom</a>.</dd><dt><a class="struct" href="struct.ExpressionAtom.html" title="struct hyperon_atom::ExpressionAtom">Expression<wbr>Atom</a></dt><dd>An expression atom structure.</dd><dt><a class="struct" href="struct.SymbolAtom.html" title="struct hyperon_atom::SymbolAtom">Symbol<wbr>Atom</a></dt><dd>A symbol atom structure.</dd><dt><a class="struct" href="struct.VariableAtom.html" title="struct hyperon_atom::VariableAtom">Variable<wbr>Atom</a></dt><dd>A variable atom structure</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Atom.html" title="enum hyperon_atom::Atom">Atom</a></dt><dd>Atoms are main components of the atomspace. There are four meta-types of
atoms: symbol, expression, variable and grounded.</dd><dt><a class="enum" href="enum.ExecError.html" title="enum hyperon_atom::ExecError">Exec<wbr>Error</a></dt><dd>Grounded function execution error.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.AutoGroundedType.html" title="trait hyperon_atom::AutoGroundedType">Auto<wbr>Grounded<wbr>Type</a></dt><dd>Alias for the list of traits required for the standard Rust types to be
automatically wrapped into <a href="trait.GroundedAtom.html" title="trait hyperon_atom::GroundedAtom">GroundedAtom</a>. It is implemented automatically
when type implements <code>'static + PartialEq + Clone + Debug</code>. No need
to implement its manually.</dd><dt><a class="trait" href="trait.ConvertingSerializer.html" title="trait hyperon_atom::ConvertingSerializer">Converting<wbr>Serializer</a></dt><dd>Converts serializable grounded atom into native Rust type <code>T</code>.
Returning error from this serializer is not expected as usually it should
just write data into a memory buffer for conversion. <a href="https://doc.rust-lang.org/1.93.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> is required
to instantiate it in <a href="trait.ConvertingSerializer.html#method.convert" title="associated function hyperon_atom::ConvertingSerializer::convert">ConvertingSerializer::convert</a> method.</dd><dt><a class="trait" href="trait.CustomExecute.html" title="trait hyperon_atom::CustomExecute">Custom<wbr>Execute</a></dt><dd>Trait for implementing custom execution logic. Using this trait one can
represent a grounded function as an atom. In order to make it work
one should also implement <a href="trait.Grounded.html#method.as_execute" title="method hyperon_atom::Grounded::as_execute">Grounded::as_execute</a> method.</dd><dt><a class="trait" href="trait.CustomGroundedType.html" title="trait hyperon_atom::CustomGroundedType">Custom<wbr>Grounded<wbr>Type</a></dt><dd>Alias for the list of traits required for a custom Rust grounded type
to be successfully wrapped into <a href="trait.GroundedAtom.html" title="trait hyperon_atom::GroundedAtom">GroundedAtom</a>. It is implemented automatically
when type implements <code>AutoGroundedType + Display + Grounded</code>. No need to
implement it manually. Implement <a href="trait.Grounded.html" title="trait hyperon_atom::Grounded">Grounded</a> and <code>Display</code> instead.</dd><dt><a class="trait" href="trait.CustomMatch.html" title="trait hyperon_atom::CustomMatch">Custom<wbr>Match</a></dt><dd>Trait for implementing custom matching logic. In order to make it work
one should also implement <a href="trait.Grounded.html#method.as_match" title="method hyperon_atom::Grounded::as_match">Grounded::as_match</a> method.</dd><dt><a class="trait" href="trait.Grounded.html" title="trait hyperon_atom::Grounded">Grounded</a></dt><dd>Trait allows implementing grounded atom with custom behavior. If no custom
behavior is needed then simpler way is using <a href="enum.Atom.html#method.value" title="associated function hyperon_atom::Atom::value">Atom::value</a> function for
automatic grounding.</dd><dt><a class="trait" href="trait.GroundedAtom.html" title="trait hyperon_atom::GroundedAtom">Grounded<wbr>Atom</a></dt><dd>A trait to erase an actual type of the grounded atom. Not intended to be
implemented by users. Use <a href="enum.Atom.html#method.value" title="associated function hyperon_atom::Atom::value">Atom::value</a> or implement <a href="trait.Grounded.html" title="trait hyperon_atom::Grounded">Grounded</a> and use
<a href="enum.Atom.html#method.gnd" title="associated function hyperon_atom::Atom::gnd">Atom::gnd</a> instead.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.make_variables_unique.html" title="fn hyperon_atom::make_variables_unique">make_<wbr>variables_<wbr>unique</a></dt><dd>Returns <code>atom</code> with all variables replaced by unique instances.</dd><dt><a class="fn" href="fn.match_by_equality.html" title="fn hyperon_atom::match_by_equality">match_<wbr>by_<wbr>equality</a></dt><dd>Returns either single empty <a href="matcher/struct.Bindings.html" title="struct hyperon_atom::matcher::Bindings">matcher::Bindings</a> instance if <code>self</code> and
<code>other</code> are equal or empty iterator if not. This is a default
implementation of <code>match_()</code> for the grounded types wrapped automatically.</dd><dt><a class="fn" href="fn.match_by_string_equality.html" title="fn hyperon_atom::match_by_string_equality">match_<wbr>by_<wbr>string_<wbr>equality</a></dt><dd>Returns either single empty <a href="matcher/struct.Bindings.html" title="struct hyperon_atom::matcher::Bindings">matcher::Bindings</a> instance if the string representing <code>self</code> and
<code>other</code> render are identical strings, or an empty iterator if not.</dd><dt><a class="fn" href="fn.rust_type_atom.html" title="fn hyperon_atom::rust_type_atom">rust_<wbr>type_<wbr>atom</a></dt><dd>Returns the name of the Rust type wrapped into <a href="enum.Atom.html#variant.Symbol" title="variant hyperon_atom::Atom::Symbol">Atom::Symbol</a>. This is a
default implementation of <code>type_()</code> for the grounded types wrapped
automatically.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.BoxedIter.html" title="type hyperon_atom::BoxedIter">Boxed<wbr>Iter</a></dt><dd>Boxed iterator type to simplify type annotations</dd></dl></section></div></main></body></html>